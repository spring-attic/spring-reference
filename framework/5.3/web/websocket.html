<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>WebSockets :: Spring</title>
    <meta name="generator" content="Antora 3.0.0-alpha.8">
    <link rel="stylesheet" href="../../../_/css/site.css">

<link href="../../../_/img/favicon.ico" rel='shortcut icon' type='image/vnd.microsoft.icon'>
<link rel="stylesheet" href="../../../_/css/vendor/docsearch.min.css">
<!-- fetched from https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css -->
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://spring.io">
        <img id="springlogo" class="block" src="../../../_/img/spring-logo.svg" alt="Spring">
      </a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Why Spring</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://spring.io/why-spring">Overview</a>
            <a class="navbar-item" href="https://spring.io/microservices">Microservices</a>
            <a class="navbar-item" href="https://spring.io/reactive">Reactive</a>
            <a class="navbar-item" href="https://spring.io/event-driven">Event Driven</a>
            <a class="navbar-item" href="https://spring.io/cloud">Cloud</a>
            <a class="navbar-item" href="https://spring.io/web-applications">Web Applications</a>
            <a class="navbar-item" href="https://spring.io/serverless">Serverless</a>
            <a class="navbar-item" href="https://spring.io/batch">Batch</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Learn</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://spring.io/learn">Overview</a>
            <a class="navbar-item" href="https://spring.io/quickstart">Quickstart</a>
            <a class="navbar-item" href="https://spring.io/guides">Guides</a>
            <a class="navbar-item" href="https://spring.io/blog">Blog</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Projects</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://spring.io/projects">Overview</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-boot">Spring Boot</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-framework">Spring Framework</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-cloud">Spring Cloud</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-cloud-dataflow">Spring Cloud Data Flow</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-data">Spring Data</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-integration">Spring Integration</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-batch">Spring Batch</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-security">Spring Security</a>
            <a class="navbar-item navbar-item-special" href="https://spring.io/projects">View all projects</a>
            <a class="navbar-item" href="https://spring.io/tools">Spring Tools 4</a>
            <a class="navbar-item navbar-item-special-2" href="https://start.spring.io">Spring Initializr <svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><polyline points="15 10.94 15 15 1 15 1 1 5.06 1" fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="2"></polyline><polyline points="8.93 1 15 1 15 7.07" fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="2"></polyline><line x1="15" y1="1" x2="8" y2="8" fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="2"></line></svg></a>
          </div>
        </div>

        <a class="navbar-item" href="https://spring.io/training">Training</a>
        <a class="navbar-item" href="https://spring.io/support">Support</a>
        <div class="navbar-item has-dropdown is-hoverable is-community">
          <a class="navbar-link" href="#">Community</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://spring.io/community">Overview</a>
            <a class="navbar-item" href="https://spring.io/events">Events</a>
            <a class="navbar-item" href="https://spring.io/team">Team</a>
          </div>
        </div>
      </div>
    </div>
    <div id="switch-theme">
      <input type="checkbox" id="switch-theme-checkbox" />
      <label for="switch-theme-checkbox">Dark Theme</label>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="framework" data-version="5.3">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Spring Framework</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../overview.html">Overview</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../core.html">Core</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../core/beans/index.html">The IoC Container</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../core/beans/container.html">Container Overview</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../core/beans/bean.html">Bean Overview</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../core/beans/dependencies.html">Bean Dependencies</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../core/beans/scopes.html">Bean Scopes</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../core/beans/customizing.html">Customizing the Nature of a Bean</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../core/beans/inheritance.html">Bean Definition Inheritance</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../core/beans/extension.html">Container Extension Points</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../core/beans/annotation.html">Annotation-based Container Configuration</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../core/beans/scanning.html">Classpath Scanning and Managed Components</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../core/beans/jsr330.html">Using JSR 330 Standard Annotations</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../core/beans/java.html">Java-based Container configuration</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../core/beans/env.html">Environment Abstraction</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../core/beans/loadtimeweaver.html">Registering a LoadTimeWeaver</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../core/beans/applicationcontext.html">Additional Capabilities of the ApplicationContext</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../core/beans/beanfactory.html">The BeanFactory</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../core/resources.html">Resources</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../core/validation.html">Validation, Data Binding, and Type Conversion</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../core/aop.html">Aspect Oriented Programming with Spring</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../core/aop-api.html">Spring AOP APIs</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../core/null-safety.html">Null-safety</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../core/databuffer-codec.html">Data Buffers and Codecs</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../core/spring-jcl.html">Logging</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../core/appendix.html">Appendix</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../testing.html">Testing</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../data-access.html">Data Access</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../web.html">Web Servlet</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../web-reactive.html">Web Reactive</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../integration.html">Integration</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../languages.html">Languages</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../appendix.html">Appendix</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Spring Framework</span>
    <span class="version">5.3</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">Spring Framework</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">5.3</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../security/index.html">Spring Security</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../security/index.html">6</a>
        </li>
        <li class="version">
          <a href="../../../security/5.6/index.html">5.6</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../session/2.6/index.html">Spring Session</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../session/2.6/index.html">2.6</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Spring Framework</a></li>
    <li><a href="websocket.html">WebSockets</a></li>
  </ul>
</nav>
<div class="search">
  <input id="search-input" type="text" placeholder="Search docs">
</div>
  <div class="edit-this-page"><a href="https://github.com/rwinch/spring-framework/edit/antora-2.x/src/docs/antora/modules/ROOT/pages/web/websocket.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<div class="admonitionblock important">
  <table>
    <tbody><tr>
      <td class="icon">
        <i class="fa icon-important" title="Important"></i>
      </td>
      <td class="content">
        <div class="paragraph">
          <p>There is a newer version available. Please update to <a href="#">Spring Framework </a>!</p>
        </div>
      </td>
    </tr></tbody>
  </table>
</div>
<h1 id="page-title" class="page">WebSockets</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This part of the reference documentation covers support for Servlet stack, WebSocket
messaging that includes raw WebSocket interactions, WebSocket emulation through SockJS, and
publish-subscribe messaging through STOMP as a sub-protocol over WebSocket.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="websocket-intro"><a class="anchor" href="#websocket-intro"></a>Introduction to WebSocket</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The WebSocket protocol, <a href="https://tools.ietf.org/html/rfc6455">RFC 6455</a>, provides a standardized
way to establish a full-duplex, two-way communication channel between client and server
over a single TCP connection. It is a different TCP protocol from HTTP but is designed to
work over HTTP, using ports 80 and 443 and allowing re-use of existing firewall rules.</p>
</div>
<div class="paragraph">
<p>A WebSocket interaction begins with an HTTP request that uses the HTTP <code>Upgrade</code> header
to upgrade or, in this case, to switch to the WebSocket protocol. The following example
shows such an interaction:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">GET /spring-websocket-portfolio/portfolio HTTP/1.1
Host: localhost:8080
Upgrade: websocket <i class="conum" data-value="1"></i><b>(1)</b>
Connection: Upgrade <i class="conum" data-value="2"></i><b>(2)</b>
Sec-WebSocket-Key: Uc9l9TMkWGbHFD2qnFHltg==
Sec-WebSocket-Protocol: v10.stomp, v11.stomp
Sec-WebSocket-Version: 13
Origin: http://localhost:8080</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>Upgrade</code> header.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Using the <code>Upgrade</code> connection.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Instead of the usual 200 status code, a server with WebSocket support returns output
similar to the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">HTTP/1.1 101 Switching Protocols <i class="conum" data-value="1"></i><b>(1)</b>
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: 1qVdfYHU9hPOl4JYYNXF623Gzn0=
Sec-WebSocket-Protocol: v10.stomp</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Protocol switch</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>After a successful handshake, the TCP socket underlying the HTTP upgrade request remains
open for both the client and the server to continue to send and receive messages.</p>
</div>
<div class="paragraph">
<p>A complete introduction of how WebSockets work is beyond the scope of this document.
See RFC 6455, the WebSocket chapter of HTML5, or any of the many introductions and
tutorials on the Web.</p>
</div>
<div class="paragraph">
<p>Note that, if a WebSocket server is running behind a web server (e.g. nginx), you
likely need to configure it to pass WebSocket upgrade requests on to the WebSocket
server. Likewise, if the application runs in a cloud environment, check the
instructions of the cloud provider related to WebSocket support.</p>
</div>
<div class="sect2">
<h3 id="websocket-intro-architecture"><a class="anchor" href="#websocket-intro-architecture"></a>HTTP Versus WebSocket</h3>
<div class="paragraph">
<p>Even though WebSocket is designed to be HTTP-compatible and starts with an HTTP request,
it is important to understand that the two protocols lead to very different
architectures and application programming models.</p>
</div>
<div class="paragraph">
<p>In HTTP and REST, an application is modeled as many URLs. To interact with the application,
clients access those URLs, request-response style. Servers route requests to the
appropriate handler based on the HTTP URL, method, and headers.</p>
</div>
<div class="paragraph">
<p>By contrast, in WebSockets, there is usually only one URL for the initial connect.
Subsequently, all application messages flow on that same TCP connection. This points to
an entirely different asynchronous, event-driven, messaging architecture.</p>
</div>
<div class="paragraph">
<p>WebSocket is also a low-level transport protocol, which, unlike HTTP, does not prescribe
any semantics to the content of messages. That means that there is no way to route or process
a message unless the client and the server agree on message semantics.</p>
</div>
<div class="paragraph">
<p>WebSocket clients and servers can negotiate the use of a higher-level, messaging protocol
(for example, STOMP), through the <code>Sec-WebSocket-Protocol</code> header on the HTTP handshake request.
In the absence of that, they need to come up with their own conventions.</p>
</div>
</div>
<div class="sect2">
<h3 id="websocket-intro-when-to-use"><a class="anchor" href="#websocket-intro-when-to-use"></a>When to Use WebSockets</h3>
<div class="paragraph">
<p>WebSockets can make a web page be dynamic and interactive. However, in many cases,
a combination of Ajax and HTTP streaming or long polling can provide a simple and
effective solution.</p>
</div>
<div class="paragraph">
<p>For example, news, mail, and social feeds need to update dynamically, but it may be
perfectly okay to do so every few minutes. Collaboration, games, and financial apps, on
the other hand, need to be much closer to real-time.</p>
</div>
<div class="paragraph">
<p>Latency alone is not a deciding factor. If the volume of messages is relatively low (for example,
monitoring network failures) HTTP streaming or polling can provide an effective solution.
It is the combination of low latency, high frequency, and high volume that make the best
case for the use of WebSocket.</p>
</div>
<div class="paragraph">
<p>Keep in mind also that over the Internet, restrictive proxies that are outside of your control
may preclude WebSocket interactions, either because they are not configured to pass on the
<code>Upgrade</code> header or because they close long-lived connections that appear idle. This
means that the use of WebSocket for internal applications within the firewall is a more
straightforward decision than it is for public facing applications.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="websocket-server"><a class="anchor" href="#websocket-server"></a>WebSocket API</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-websocket-server" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>The Spring Framework provides a WebSocket API that you can use to write client- and
server-side applications that handle WebSocket messages.</p>
</div>
<div class="sect2">
<h3 id="websocket-server-handler"><a class="anchor" href="#websocket-server-handler"></a><code>WebSocketHandler</code></h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-websocket-server-handler" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>Creating a WebSocket server is as simple as implementing <code>WebSocketHandler</code> or, more
likely, extending either <code>TextWebSocketHandler</code> or <code>BinaryWebSocketHandler</code>. The following
example uses <code>TextWebSocketHandler</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.web.socket.WebSocketHandler;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.TextMessage;

public class MyHandler extends TextWebSocketHandler {

	@Override
	public void handleTextMessage(WebSocketSession session, TextMessage message) {
		// ...
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is dedicated WebSocket Java configuration and XML namespace support for mapping the preceding
WebSocket handler to a specific URL, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.web.socket.config.annotation.EnableWebSocket;
import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;

@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

	@Override
	public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
		registry.addHandler(myHandler(), "/myHandler");
	}

	@Bean
	public WebSocketHandler myHandler() {
		return new MyHandler();
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the XML configuration equivalent of the preceding example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:websocket="http://www.springframework.org/schema/websocket"
	xsi:schemaLocation="
		http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/websocket
		https://www.springframework.org/schema/websocket/spring-websocket.xsd"&gt;

	&lt;websocket:handlers&gt;
		&lt;websocket:mapping path="/myHandler" handler="myHandler"/&gt;
	&lt;/websocket:handlers&gt;

	&lt;bean id="myHandler" class="org.springframework.samples.MyHandler"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding example is for use in Spring MVC applications and should be included
in the configuration of a <a href="#mvc-servlet"><code>DispatcherServlet</code></a>. However, Spring&#8217;s
WebSocket support does not depend on Spring MVC. It is relatively simple to
integrate a <code>WebSocketHandler</code> into other HTTP-serving environments with the help of
<a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/web/socket/server/support/WebSocketHttpRequestHandler.html"><code>WebSocketHttpRequestHandler</code></a>.</p>
</div>
<div class="paragraph">
<p>When using the <code>WebSocketHandler</code> API directly vs indirectly, e.g. through the
<a href="#websocket-stomp">STOMP</a> messaging, the application must synchronize the sending of messages
since the underlying standard WebSocket session (JSR-356) does not allow concurrent
sending. One option is to wrap the <code>WebSocketSession</code> with
<a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/web/socket/handler/ConcurrentWebSocketSessionDecorator.html"><code>ConcurrentWebSocketSessionDecorator</code></a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="websocket-server-handshake"><a class="anchor" href="#websocket-server-handshake"></a>WebSocket Handshake</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-websocket-server-handshake" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>The easiest way to customize the initial HTTP WebSocket handshake request is through
a <code>HandshakeInterceptor</code>, which exposes methods for &#8220;before&#8221; and &#8220;after&#8221; the handshake.
You can use such an interceptor to preclude the handshake or to make any attributes
available to the <code>WebSocketSession</code>. The following example uses a built-in interceptor
to pass HTTP session attributes to the WebSocket session:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

	@Override
	public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
		registry.addHandler(new MyHandler(), "/myHandler")
			.addInterceptors(new HttpSessionHandshakeInterceptor());
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the XML configuration equivalent of the preceding example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:websocket="http://www.springframework.org/schema/websocket"
	xsi:schemaLocation="
		http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/websocket
		https://www.springframework.org/schema/websocket/spring-websocket.xsd"&gt;

	&lt;websocket:handlers&gt;
		&lt;websocket:mapping path="/myHandler" handler="myHandler"/&gt;
		&lt;websocket:handshake-interceptors&gt;
			&lt;bean class="org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor"/&gt;
		&lt;/websocket:handshake-interceptors&gt;
	&lt;/websocket:handlers&gt;

	&lt;bean id="myHandler" class="org.springframework.samples.MyHandler"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A more advanced option is to extend the <code>DefaultHandshakeHandler</code> that performs
the steps of the WebSocket handshake, including validating the client origin,
negotiating a sub-protocol, and other details. An application may also need to use this
option if it needs to configure a custom <code>RequestUpgradeStrategy</code> in order to
adapt to a WebSocket server engine and version that is not yet supported
(see <a href="#websocket-server-deployment">Deployment</a> for more on this subject).
Both the Java configuration and XML namespace make it possible to configure a custom
<code>HandshakeHandler</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Spring provides a <code>WebSocketHandlerDecorator</code> base class that you can use to decorate
a <code>WebSocketHandler</code> with additional behavior. Logging and exception handling
implementations are provided and added by default when using the WebSocket Java configuration
or XML namespace. The <code>ExceptionWebSocketHandlerDecorator</code> catches all uncaught
exceptions that arise from any <code>WebSocketHandler</code> method and closes the WebSocket
session with status <code>1011</code>, which indicates a server error.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="websocket-server-deployment"><a class="anchor" href="#websocket-server-deployment"></a>Deployment</h3>
<div class="paragraph">
<p>The Spring WebSocket API is easy to integrate into a Spring MVC application where
the <code>DispatcherServlet</code> serves both HTTP WebSocket handshake and other
HTTP requests. It is also easy to integrate into other HTTP processing scenarios
by invoking <code>WebSocketHttpRequestHandler</code>. This is convenient and easy to
understand. However, special considerations apply with regards to JSR-356 runtimes.</p>
</div>
<div class="paragraph">
<p>The Java WebSocket API (JSR-356) provides two deployment mechanisms. The first
involves a Servlet container classpath scan (a Servlet 3 feature) at startup.
The other is a registration API to use at Servlet container initialization.
Neither of these mechanism makes it possible to use a single &#8220;front controller&#8221;
for all HTTP processing&#8201;&#8212;&#8201;including WebSocket handshake and all other HTTP
requests&#8201;&#8212;&#8201;such as Spring MVC&#8217;s <code>DispatcherServlet</code>.</p>
</div>
<div class="paragraph">
<p>This is a significant limitation of JSR-356 that Spring&#8217;s WebSocket support addresses with
server-specific <code>RequestUpgradeStrategy</code> implementations even when running in a JSR-356 runtime.
Such strategies currently exist for Tomcat, Jetty, GlassFish, WebLogic, WebSphere, and
Undertow (and WildFly).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A request to overcome the preceding limitation in the Java WebSocket API has been
created and can be followed at
<a href="https://github.com/eclipse-ee4j/websocket-api/issues/211">eclipse-ee4j/websocket-api#211</a>.
Tomcat, Undertow, and WebSphere provide their own API alternatives that
make it possible to do this, and it is also possible with Jetty. We are hopeful
that more servers will do the same.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A secondary consideration is that Servlet containers with JSR-356 support are expected
to perform a <code>ServletContainerInitializer</code> (SCI) scan that can slow down application
startup&#8201;&#8212;&#8201;in some cases, dramatically. If a significant impact is observed after an
upgrade to a Servlet container version with JSR-356 support, it should
be possible to selectively enable or disable web fragments (and SCI scanning)
through the use of the <code>&lt;absolute-ordering /&gt;</code> element in <code>web.xml</code>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="
		http://java.sun.com/xml/ns/javaee
		https://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
	version="3.0"&gt;

	&lt;absolute-ordering/&gt;

&lt;/web-app&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can then selectively enable web fragments by name, such as Spring&#8217;s own
<code>SpringServletContainerInitializer</code> that provides support for the Servlet 3
Java initialization API. The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="
		http://java.sun.com/xml/ns/javaee
		https://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
	version="3.0"&gt;

	&lt;absolute-ordering&gt;
		&lt;name&gt;spring_web&lt;/name&gt;
	&lt;/absolute-ordering&gt;

&lt;/web-app&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="websocket-server-runtime-configuration"><a class="anchor" href="#websocket-server-runtime-configuration"></a>Server Configuration</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-websocket-server-config" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>Each underlying WebSocket engine exposes configuration properties that control
runtime characteristics, such as the size of message buffer sizes, idle timeout,
and others.</p>
</div>
<div class="paragraph">
<p>For Tomcat, WildFly, and GlassFish, you can add a <code>ServletServerContainerFactoryBean</code> to your
WebSocket Java config, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

	@Bean
	public ServletServerContainerFactoryBean createWebSocketContainer() {
		ServletServerContainerFactoryBean container = new ServletServerContainerFactoryBean();
		container.setMaxTextMessageBufferSize(8192);
		container.setMaxBinaryMessageBufferSize(8192);
		return container;
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the XML configuration equivalent of the preceding example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:websocket="http://www.springframework.org/schema/websocket"
	xsi:schemaLocation="
		http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/websocket
		https://www.springframework.org/schema/websocket/spring-websocket.xsd"&gt;

	&lt;bean class="org.springframework...ServletServerContainerFactoryBean"&gt;
		&lt;property name="maxTextMessageBufferSize" value="8192"/&gt;
		&lt;property name="maxBinaryMessageBufferSize" value="8192"/&gt;
	&lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For client-side WebSocket configuration, you should use <code>WebSocketContainerFactoryBean</code>
(XML) or <code>ContainerProvider.getWebSocketContainer()</code> (Java configuration).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For Jetty, you need to supply a pre-configured Jetty <code>WebSocketServerFactory</code> and plug
that into Spring&#8217;s <code>DefaultHandshakeHandler</code> through your WebSocket Java config.
The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

	@Override
	public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
		registry.addHandler(echoWebSocketHandler(),
			"/echo").setHandshakeHandler(handshakeHandler());
	}

	@Bean
	public DefaultHandshakeHandler handshakeHandler() {

		WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);
		policy.setInputBufferSize(8192);
		policy.setIdleTimeout(600000);

		return new DefaultHandshakeHandler(
				new JettyRequestUpgradeStrategy(new WebSocketServerFactory(policy)));
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the XML configuration equivalent of the preceding example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:websocket="http://www.springframework.org/schema/websocket"
	xsi:schemaLocation="
		http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/websocket
		https://www.springframework.org/schema/websocket/spring-websocket.xsd"&gt;

	&lt;websocket:handlers&gt;
		&lt;websocket:mapping path="/echo" handler="echoHandler"/&gt;
		&lt;websocket:handshake-handler ref="handshakeHandler"/&gt;
	&lt;/websocket:handlers&gt;

	&lt;bean id="handshakeHandler" class="org.springframework...DefaultHandshakeHandler"&gt;
		&lt;constructor-arg ref="upgradeStrategy"/&gt;
	&lt;/bean&gt;

	&lt;bean id="upgradeStrategy" class="org.springframework...JettyRequestUpgradeStrategy"&gt;
		&lt;constructor-arg ref="serverFactory"/&gt;
	&lt;/bean&gt;

	&lt;bean id="serverFactory" class="org.eclipse.jetty...WebSocketServerFactory"&gt;
		&lt;constructor-arg&gt;
			&lt;bean class="org.eclipse.jetty...WebSocketPolicy"&gt;
				&lt;constructor-arg value="SERVER"/&gt;
				&lt;property name="inputBufferSize" value="8092"/&gt;
				&lt;property name="idleTimeout" value="600000"/&gt;
			&lt;/bean&gt;
		&lt;/constructor-arg&gt;
	&lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="websocket-server-allowed-origins"><a class="anchor" href="#websocket-server-allowed-origins"></a>Allowed Origins</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-websocket-server-cors" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>As of Spring Framework 4.1.5, the default behavior for WebSocket and SockJS is to accept
only same-origin requests. It is also possible to allow all or a specified list of origins.
This check is mostly designed for browser clients. Nothing prevents other types
of clients from modifying the <code>Origin</code> header value (see
<a href="https://tools.ietf.org/html/rfc6454">RFC 6454: The Web Origin Concept</a> for more details).</p>
</div>
<div class="paragraph">
<p>The three possible behaviors are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Allow only same-origin requests (default): In this mode, when SockJS is enabled, the
Iframe HTTP response header <code>X-Frame-Options</code> is set to <code>SAMEORIGIN</code>, and JSONP
transport is disabled, since it does not allow checking the origin of a request.
As a consequence, IE6 and IE7 are not supported when this mode is enabled.</p>
</li>
<li>
<p>Allow a specified list of origins: Each allowed origin must start with <code>http://</code>
or <code>https://</code>. In this mode, when SockJS is enabled, IFrame transport is disabled.
As a consequence, IE6 through IE9 are not supported when this
mode is enabled.</p>
</li>
<li>
<p>Allow all origins: To enable this mode, you should provide <code>*</code> as the allowed origin
value. In this mode, all transports are available.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can configure WebSocket and SockJS allowed origins, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.web.socket.config.annotation.EnableWebSocket;
import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;

@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

	@Override
	public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
		registry.addHandler(myHandler(), "/myHandler").setAllowedOrigins("https://mydomain.com");
	}

	@Bean
	public WebSocketHandler myHandler() {
		return new MyHandler();
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the XML configuration equivalent of the preceding example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:websocket="http://www.springframework.org/schema/websocket"
	xsi:schemaLocation="
		http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/websocket
		https://www.springframework.org/schema/websocket/spring-websocket.xsd"&gt;

	&lt;websocket:handlers allowed-origins="https://mydomain.com"&gt;
		&lt;websocket:mapping path="/myHandler" handler="myHandler" /&gt;
	&lt;/websocket:handlers&gt;

	&lt;bean id="myHandler" class="org.springframework.samples.MyHandler"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="websocket-fallback"><a class="anchor" href="#websocket-fallback"></a>SockJS Fallback</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Over the public Internet, restrictive proxies outside your control may preclude WebSocket
interactions, either because they are not configured to pass on the <code>Upgrade</code> header or
because they close long-lived connections that appear to be idle.</p>
</div>
<div class="paragraph">
<p>The solution to this problem is WebSocket emulation&#8201;&#8212;&#8201;that is, attempting to use WebSocket
first and then falling back on HTTP-based techniques that emulate a WebSocket
interaction and expose the same application-level API.</p>
</div>
<div class="paragraph">
<p>On the Servlet stack, the Spring Framework provides both server (and also client) support
for the SockJS protocol.</p>
</div>
<div class="sect2">
<h3 id="websocket-fallback-sockjs-overview"><a class="anchor" href="#websocket-fallback-sockjs-overview"></a>Overview</h3>
<div class="paragraph">
<p>The goal of SockJS is to let applications use a WebSocket API but fall back to
non-WebSocket alternatives when necessary at runtime, without the need to
change application code.</p>
</div>
<div class="paragraph">
<p>SockJS consists of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="https://github.com/sockjs/sockjs-protocol">SockJS protocol</a>
defined in the form of executable
<a href="https://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html">narrated tests</a>.</p>
</li>
<li>
<p>The <a href="https://github.com/sockjs/sockjs-client/">SockJS JavaScript client</a>&#8201;&#8212;&#8201;a client library for use in browsers.</p>
</li>
<li>
<p>SockJS server implementations, including one in the Spring Framework <code>spring-websocket</code> module.</p>
</li>
<li>
<p>A SockJS Java client in the <code>spring-websocket</code> module (since version 4.1).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>SockJS is designed for use in browsers. It uses a variety of techniques
to support a wide range of browser versions.
For the full list of SockJS transport types and browsers, see the
<a href="https://github.com/sockjs/sockjs-client/">SockJS client</a> page. Transports
fall in three general categories: WebSocket, HTTP Streaming, and HTTP Long Polling.
For an overview of these categories, see
<a href="https://spring.io/blog/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/">this blog post</a>.</p>
</div>
<div class="paragraph">
<p>The SockJS client begins by sending <code>GET /info</code> to
obtain basic information from the server. After that, it must decide what transport
to use. If possible, WebSocket is used. If not, in most browsers,
there is at least one HTTP streaming option. If not, then HTTP (long)
polling is used.</p>
</div>
<div class="paragraph">
<p>All transport requests have the following URL structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>https://host:port/myApp/myEndpoint/{server-id}/{session-id}/{transport}</pre>
</div>
</div>
<div class="paragraph">
<p>where:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>{server-id}</code> is useful for routing requests in a cluster but is not used otherwise.</p>
</li>
<li>
<p><code>{session-id}</code> correlates HTTP requests belonging to a SockJS session.</p>
</li>
<li>
<p><code>{transport}</code> indicates the transport type (for example, <code>websocket</code>, <code>xhr-streaming</code>, and others).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The WebSocket transport needs only a single HTTP request to do the WebSocket handshake.
All messages thereafter are exchanged on that socket.</p>
</div>
<div class="paragraph">
<p>HTTP transports require more requests. Ajax/XHR streaming, for example, relies on
one long-running request for server-to-client messages and additional HTTP POST
requests for client-to-server messages. Long polling is similar, except that it
ends the current request after each server-to-client send.</p>
</div>
<div class="paragraph">
<p>SockJS adds minimal message framing. For example, the server sends the letter <code>o</code>
(&#8220;open&#8221; frame) initially, messages are sent as <code>a["message1","message2"]</code>
(JSON-encoded array), the letter <code>h</code> (&#8220;heartbeat&#8221; frame) if no messages flow
for 25 seconds (by default), and the letter <code>c</code> (&#8220;close&#8221; frame) to close the session.</p>
</div>
<div class="paragraph">
<p>To learn more, run an example in a browser and watch the HTTP requests.
The SockJS client allows fixing the list of transports, so it is possible to
see each transport one at a time. The SockJS client also provides a debug flag,
which enables helpful messages in the browser console. On the server side, you can enable
<code>TRACE</code> logging for <code>org.springframework.web.socket</code>.
For even more detail, see the SockJS protocol
<a href="https://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html">narrated test</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="websocket-fallback-sockjs-enable"><a class="anchor" href="#websocket-fallback-sockjs-enable"></a>Enabling SockJS</h3>
<div class="paragraph">
<p>You can enable SockJS through Java configuration, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

	@Override
	public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
		registry.addHandler(myHandler(), "/myHandler").withSockJS();
	}

	@Bean
	public WebSocketHandler myHandler() {
		return new MyHandler();
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the XML configuration equivalent of the preceding example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:websocket="http://www.springframework.org/schema/websocket"
	xsi:schemaLocation="
		http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/websocket
		https://www.springframework.org/schema/websocket/spring-websocket.xsd"&gt;

	&lt;websocket:handlers&gt;
		&lt;websocket:mapping path="/myHandler" handler="myHandler"/&gt;
		&lt;websocket:sockjs/&gt;
	&lt;/websocket:handlers&gt;

	&lt;bean id="myHandler" class="org.springframework.samples.MyHandler"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding example is for use in Spring MVC applications and should be included in the
configuration of a <a href="#mvc-servlet"><code>DispatcherServlet</code></a>. However, Spring&#8217;s WebSocket
and SockJS support does not depend on Spring MVC. It is relatively simple to
integrate into other HTTP serving environments with the help of
<a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/web/socket/sockjs/support/SockJsHttpRequestHandler.html"><code>SockJsHttpRequestHandler</code></a>.</p>
</div>
<div class="paragraph">
<p>On the browser side, applications can use the
<a href="https://github.com/sockjs/sockjs-client/"><code>sockjs-client</code></a> (version 1.0.x). It
emulates the W3C WebSocket API and communicates with the server to select the best
transport option, depending on the browser in which it runs. See the
<a href="https://github.com/sockjs/sockjs-client/">sockjs-client</a> page and the list of
transport types supported by browser. The client also provides several
configuration options&#8201;&#8212;&#8201;for example, to specify which transports to include.</p>
</div>
</div>
<div class="sect2">
<h3 id="websocket-fallback-xhr-vs-iframe"><a class="anchor" href="#websocket-fallback-xhr-vs-iframe"></a>IE 8 and 9</h3>
<div class="paragraph">
<p>Internet Explorer 8 and 9 remain in use. They are
a key reason for having SockJS. This section covers important
considerations about running in those browsers.</p>
</div>
<div class="paragraph">
<p>The SockJS client supports Ajax/XHR streaming in IE 8 and 9 by using Microsoft&#8217;s
<a href="https://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx"><code>XDomainRequest</code></a>.
That works across domains but does not support sending cookies.
Cookies are often essential for Java applications.
However, since the SockJS client can be used with many server
types (not just Java ones), it needs to know whether cookies matter.
If so, the SockJS client prefers Ajax/XHR for streaming. Otherwise, it
relies on an iframe-based technique.</p>
</div>
<div class="paragraph">
<p>The first <code>/info</code> request from the SockJS client is a request for
information that can influence the client&#8217;s choice of transports.
One of those details is whether the server application relies on cookies
(for example, for authentication purposes or clustering with sticky sessions).
Spring&#8217;s SockJS support includes a property called <code>sessionCookieNeeded</code>.
It is enabled by default, since most Java applications rely on the <code>JSESSIONID</code>
cookie. If your application does not need it, you can turn off this option,
and SockJS client should then choose <code>xdr-streaming</code> in IE 8 and 9.</p>
</div>
<div class="paragraph">
<p>If you do use an iframe-based transport, keep in mind
that browsers can be instructed to block the use of IFrames on a given page by
setting the HTTP response header <code>X-Frame-Options</code> to <code>DENY</code>,
<code>SAMEORIGIN</code>, or <code>ALLOW-FROM &lt;origin&gt;</code>. This is used to prevent
<a href="https://www.owasp.org/index.php/Clickjacking">clickjacking</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring Security 3.2+ provides support for setting <code>X-Frame-Options</code> on every
response. By default, the Spring Security Java configuration sets it to <code>DENY</code>.
In 3.2, the Spring Security XML namespace does not set that header by default
but can be configured to do so. In the future, it may set it by default.</p>
</div>
<div class="paragraph">
<p>See <a href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers">Default Security Headers</a>
of the Spring Security documentation for details on how to configure the
setting of the <code>X-Frame-Options</code> header. You can also see
<a href="https://jira.spring.io/browse/SEC-2501">SEC-2501</a> for additional background.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If your application adds the <code>X-Frame-Options</code> response header (as it should!)
and relies on an iframe-based transport, you need to set the header value to
<code>SAMEORIGIN</code> or <code>ALLOW-FROM &lt;origin&gt;</code>. The Spring SockJS
support also needs to know the location of the SockJS client, because it is loaded
from the iframe. By default, the iframe is set to download the SockJS client
from a CDN location. It is a good idea to configure this option to use
a URL from the same origin as the application.</p>
</div>
<div class="paragraph">
<p>The following example shows how to do so in Java configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

	@Override
	public void registerStompEndpoints(StompEndpointRegistry registry) {
		registry.addEndpoint("/portfolio").withSockJS()
				.setClientLibraryUrl("http://localhost:8080/myapp/js/sockjs-client.js");
	}

	// ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The XML namespace provides a similar option through the <code>&lt;websocket:sockjs&gt;</code> element.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
During initial development, do enable the SockJS client <code>devel</code> mode that prevents
the browser from caching SockJS requests (like the iframe) that would otherwise
be cached. For details on how to enable it see the
<a href="https://github.com/sockjs/sockjs-client/">SockJS client</a> page.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="websocket-fallback-sockjs-heartbeat"><a class="anchor" href="#websocket-fallback-sockjs-heartbeat"></a>Heartbeats</h3>
<div class="paragraph">
<p>The SockJS protocol requires servers to send heartbeat messages to preclude proxies
from concluding that a connection is hung. The Spring SockJS configuration has a property
called <code>heartbeatTime</code> that you can use to customize the frequency. By default, a
heartbeat is sent after 25 seconds, assuming no other messages were sent on that
connection. This 25-second value is in line with the following
<a href="https://tools.ietf.org/html/rfc6202">IETF recommendation</a> for public Internet applications.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When using STOMP over WebSocket and SockJS, if the STOMP client and server negotiate
heartbeats to be exchanged, the SockJS heartbeats are disabled.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The Spring SockJS support also lets you configure the <code>TaskScheduler</code> to
schedule heartbeats tasks. The task scheduler is backed by a thread pool,
with default settings based on the number of available processors. Your
should consider customizing the settings according to your specific needs.</p>
</div>
</div>
<div class="sect2">
<h3 id="websocket-fallback-sockjs-servlet3-async"><a class="anchor" href="#websocket-fallback-sockjs-servlet3-async"></a>Client Disconnects</h3>
<div class="paragraph">
<p>HTTP streaming and HTTP long polling SockJS transports require a connection to remain
open longer than usual. For an overview of these techniques, see
<a href="https://spring.io/blog/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/">this blog post</a>.</p>
</div>
<div class="paragraph">
<p>In Servlet containers, this is done through Servlet 3 asynchronous support that
allows exiting the Servlet container thread, processing a request, and continuing
to write to the response from another thread.</p>
</div>
<div class="paragraph">
<p>A specific issue is that the Servlet API does not provide notifications for a client
that has gone away. See <a href="https://github.com/eclipse-ee4j/servlet-api/issues/44">eclipse-ee4j/servlet-api#44</a>.
However, Servlet containers raise an exception on subsequent attempts to write
to the response. Since Spring&#8217;s SockJS Service supports server-sent heartbeats (every
25 seconds by default), that means a client disconnect is usually detected within that
time period (or earlier, if messages are sent more frequently).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As a result, network I/O failures can occur because a client has disconnected, which
can fill the log with unnecessary stack traces. Spring makes a best effort to identify
such network failures that represent client disconnects (specific to each server) and log
a minimal message by using the dedicated log category, <code>DISCONNECTED_CLIENT_LOG_CATEGORY</code>
(defined in <code>AbstractSockJsSession</code>). If you need to see the stack traces, you can set that
log category to TRACE.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="websocket-fallback-cors"><a class="anchor" href="#websocket-fallback-cors"></a>SockJS and CORS</h3>
<div class="paragraph">
<p>If you allow cross-origin requests (see <a href="#websocket-server-allowed-origins">Allowed Origins</a>), the SockJS protocol
uses CORS for cross-domain support in the XHR streaming and polling transports. Therefore,
CORS headers are added automatically, unless the presence of CORS headers in the response
is detected. So, if an application is already configured to provide CORS support (for example,
through a Servlet Filter), Spring&#8217;s <code>SockJsService</code> skips this part.</p>
</div>
<div class="paragraph">
<p>It is also possible to disable the addition of these CORS headers by setting the
<code>suppressCors</code> property in Spring&#8217;s SockJsService.</p>
</div>
<div class="paragraph">
<p>SockJS expects the following headers and values:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Access-Control-Allow-Origin</code>: Initialized from the value of the <code>Origin</code> request header.</p>
</li>
<li>
<p><code>Access-Control-Allow-Credentials</code>: Always set to <code>true</code>.</p>
</li>
<li>
<p><code>Access-Control-Request-Headers</code>: Initialized from values from the equivalent request header.</p>
</li>
<li>
<p><code>Access-Control-Allow-Methods</code>: The HTTP methods a transport supports (see <code>TransportType</code> enum).</p>
</li>
<li>
<p><code>Access-Control-Max-Age</code>: Set to 31536000 (1 year).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For the exact implementation, see <code>addCorsHeaders</code> in <code>AbstractSockJsService</code> and
the <code>TransportType</code> enum in the source code.</p>
</div>
<div class="paragraph">
<p>Alternatively, if the CORS configuration allows it, consider excluding URLs with the
SockJS endpoint prefix, thus letting Spring&#8217;s <code>SockJsService</code> handle it.</p>
</div>
</div>
<div class="sect2">
<h3 id="websocket-fallback-sockjs-client"><a class="anchor" href="#websocket-fallback-sockjs-client"></a><code>SockJsClient</code></h3>
<div class="paragraph">
<p>Spring provides a SockJS Java client to connect to remote SockJS endpoints without
using a browser. This can be especially useful when there is a need for bidirectional
communication between two servers over a public network (that is, where network proxies can
preclude the use of the WebSocket protocol). A SockJS Java client is also very useful
for testing purposes (for example, to simulate a large number of concurrent users).</p>
</div>
<div class="paragraph">
<p>The SockJS Java client supports the <code>websocket</code>, <code>xhr-streaming</code>, and <code>xhr-polling</code>
transports. The remaining ones only make sense for use in a browser.</p>
</div>
<div class="paragraph">
<p>You can configure the <code>WebSocketTransport</code> with:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>StandardWebSocketClient</code> in a JSR-356 runtime.</p>
</li>
<li>
<p><code>JettyWebSocketClient</code> by using the Jetty 9+ native WebSocket API.</p>
</li>
<li>
<p>Any implementation of Spring&#8217;s <code>WebSocketClient</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>An <code>XhrTransport</code>, by definition, supports both <code>xhr-streaming</code> and <code>xhr-polling</code>, since,
from a client perspective, there is no difference other than in the URL used to connect
to the server. At present there are two implementations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RestTemplateXhrTransport</code> uses Spring&#8217;s <code>RestTemplate</code> for HTTP requests.</p>
</li>
<li>
<p><code>JettyXhrTransport</code> uses Jetty&#8217;s <code>HttpClient</code> for HTTP requests.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example shows how to create a SockJS client and connect to a SockJS endpoint:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">List&lt;Transport&gt; transports = new ArrayList&lt;&gt;(2);
transports.add(new WebSocketTransport(new StandardWebSocketClient()));
transports.add(new RestTemplateXhrTransport());

SockJsClient sockJsClient = new SockJsClient(transports);
sockJsClient.doHandshake(new MyWebSocketHandler(), "ws://example.com:8080/sockjs");</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
SockJS uses JSON formatted arrays for messages. By default, Jackson 2 is used and needs
to be on the classpath. Alternatively, you can configure a custom implementation of
<code>SockJsMessageCodec</code> and configure it on the <code>SockJsClient</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To use <code>SockJsClient</code> to simulate a large number of concurrent users, you
need to configure the underlying HTTP client (for XHR transports) to allow a sufficient
number of connections and threads. The following example shows how to do so with Jetty:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HttpClient jettyHttpClient = new HttpClient();
jettyHttpClient.setMaxConnectionsPerDestination(1000);
jettyHttpClient.setExecutor(new QueuedThreadPool(1000));</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the server-side SockJS-related properties (see javadoc for details)
that you should also consider customizing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class WebSocketConfig extends WebSocketMessageBrokerConfigurationSupport {

	@Override
	public void registerStompEndpoints(StompEndpointRegistry registry) {
		registry.addEndpoint("/sockjs").withSockJS()
			.setStreamBytesLimit(512 * 1024) <i class="conum" data-value="1"></i><b>(1)</b>
			.setHttpMessageCacheSize(1000) <i class="conum" data-value="2"></i><b>(2)</b>
			.setDisconnectDelay(30 * 1000); <i class="conum" data-value="3"></i><b>(3)</b>
	}

	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Set the <code>streamBytesLimit</code> property to 512KB (the default is 128KB&#8201;&#8212;&#8201;<code>128 * 1024</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Set the <code>httpMessageCacheSize</code> property to 1,000 (the default is <code>100</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Set the <code>disconnectDelay</code> property to 30 property seconds (the default is five seconds&#8201;&#8212;&#8201;<code>5 * 1000</code>).</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="websocket-stomp"><a class="anchor" href="#websocket-stomp"></a>STOMP</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The WebSocket protocol defines two types of messages (text and binary), but their
content is undefined. The protocol defines a mechanism for client and server to negotiate a
sub-protocol (that is, a higher-level messaging protocol) to use on top of WebSocket to
define what kind of messages each can send, what the format is, the content of each
message, and so on. The use of a sub-protocol is optional but, either way, the client and
the server need to agree on some protocol that defines message content.</p>
</div>
<div class="sect2">
<h3 id="websocket-stomp-overview"><a class="anchor" href="#websocket-stomp-overview"></a>Overview</h3>
<div class="paragraph">
<p><a href="https://stomp.github.io/stomp-specification-1.2.html#Abstract">STOMP</a> (Simple
Text Oriented Messaging Protocol) was originally created for scripting languages
(such as Ruby, Python, and Perl) to connect to enterprise message brokers. It is
designed to address a minimal subset of commonly used messaging patterns. STOMP can be
used over any reliable two-way streaming network protocol, such as TCP and WebSocket.
Although STOMP is a text-oriented protocol, message payloads can be
either text or binary.</p>
</div>
<div class="paragraph">
<p>STOMP is a frame-based protocol whose frames are modeled on HTTP. The following listing shows the structure
of a STOMP frame:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>COMMAND
header1:value1
header2:value2

Body^@</pre>
</div>
</div>
<div class="paragraph">
<p>Clients can use the <code>SEND</code> or <code>SUBSCRIBE</code> commands to send or subscribe for
messages, along with a <code>destination</code> header that describes what the
message is about and who should receive it. This enables a simple
publish-subscribe mechanism that you can use to send messages through the broker
to other connected clients or to send messages to the server to request that
some work be performed.</p>
</div>
<div class="paragraph">
<p>When you use Spring&#8217;s STOMP support, the Spring WebSocket application acts
as the STOMP broker to clients. Messages are routed to <code>@Controller</code> message-handling
methods or to a simple in-memory broker that keeps track of subscriptions and
broadcasts messages to subscribed users. You can also configure Spring to work
with a dedicated STOMP broker (such as RabbitMQ, ActiveMQ, and others) for the actual
broadcasting of messages. In that case, Spring maintains
TCP connections to the broker, relays messages to it, and passes messages
from it down to connected WebSocket clients. Thus, Spring web applications can
rely on unified HTTP-based security, common validation, and a familiar programming
model for message handling.</p>
</div>
<div class="paragraph">
<p>The following example shows a client subscribing to receive stock quotes, which
the server may emit periodically (for example, via a scheduled task that sends messages
through a <code>SimpMessagingTemplate</code> to the broker):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SUBSCRIBE
id:sub-1
destination:/topic/price.stock.*

^@</pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows a client that sends a trade request, which the server
can handle through an <code>@MessageMapping</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SEND
destination:/queue/trade
content-type:application/json
content-length:44

{"action":"BUY","ticker":"MMM","shares",44}^@</pre>
</div>
</div>
<div class="paragraph">
<p>After the execution, the server can
broadcast a trade confirmation message and details down to the client.</p>
</div>
<div class="paragraph">
<p>The meaning of a destination is intentionally left opaque in the STOMP spec. It can
be any string, and it is entirely up to STOMP servers to define the semantics and
the syntax of the destinations that they support. It is very common, however, for
destinations to be path-like strings where <code>/topic/..</code> implies publish-subscribe
(one-to-many) and <code>/queue/</code> implies point-to-point (one-to-one) message
exchanges.</p>
</div>
<div class="paragraph">
<p>STOMP servers can use the <code>MESSAGE</code> command to broadcast messages to all subscribers.
The following example shows a server sending a stock quote to a subscribed client:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>MESSAGE
message-id:nxahklf6-1
subscription:sub-1
destination:/topic/price.stock.MMM

{"ticker":"MMM","price":129.45}^@</pre>
</div>
</div>
<div class="paragraph">
<p>A server cannot send unsolicited messages. All messages
from a server must be in response to a specific client subscription, and the
<code>subscription-id</code> header of the server message must match the <code>id</code> header of the
client subscription.</p>
</div>
<div class="paragraph">
<p>The preceding overview is intended to provide the most basic understanding of the
STOMP protocol. We recommended reviewing the protocol
<a href="https://stomp.github.io/stomp-specification-1.2.html">specification</a> in full.</p>
</div>
</div>
<div class="sect2">
<h3 id="websocket-stomp-benefits"><a class="anchor" href="#websocket-stomp-benefits"></a>Benefits</h3>
<div class="paragraph">
<p>Using STOMP as a sub-protocol lets the Spring Framework and Spring Security
provide a richer programming model versus using raw WebSockets. The same point can be
made about HTTP versus raw TCP and how it lets Spring MVC and other web frameworks
provide rich functionality. The following is a list of benefits:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>No need to invent a custom messaging protocol and message format.</p>
</li>
<li>
<p>STOMP clients, including a <a href="#websocket-stomp-client">Java client</a>
in the Spring Framework, are available.</p>
</li>
<li>
<p>You can (optionally) use message brokers (such as RabbitMQ, ActiveMQ, and others) to
manage subscriptions and broadcast messages.</p>
</li>
<li>
<p>Application logic can be organized in any number of <code>@Controller</code> instances and messages can be
routed to them based on the STOMP destination header versus handling raw WebSocket messages
with a single <code>WebSocketHandler</code> for a given connection.</p>
</li>
<li>
<p>You can use Spring Security to secure messages based on STOMP destinations and message types.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="websocket-stomp-enable"><a class="anchor" href="#websocket-stomp-enable"></a>Enable STOMP</h3>
<div class="paragraph">
<p>STOMP over WebSocket support is available in the <code>spring-messaging</code> and
<code>spring-websocket</code> modules. Once you have those dependencies, you can expose a STOMP
endpoints, over WebSocket with <a href="#websocket-fallback">SockJS Fallback</a>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;

@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

	@Override
	public void registerStompEndpoints(StompEndpointRegistry registry) {
		registry.addEndpoint("/portfolio").withSockJS();  <i class="conum" data-value="1"></i><b>(1)</b>
	}

	@Override
	public void configureMessageBroker(MessageBrokerRegistry config) {
		config.setApplicationDestinationPrefixes("/app"); <i class="conum" data-value="2"></i><b>(2)</b>
		config.enableSimpleBroker("/topic", "/queue"); <i class="conum" data-value="3"></i><b>(3)</b>
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>/portfolio</code> is the HTTP URL for the endpoint to which a WebSocket (or SockJS)
client needs to connect for the WebSocket handshake.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>STOMP messages whose destination header begins with <code>/app</code> are routed to
<code>@MessageMapping</code> methods in <code>@Controller</code> classes.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Use the built-in message broker for subscriptions and broadcasting and
route messages whose destination header begins with <code>/topic `or `/queue</code> to the broker.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows the XML configuration equivalent of the preceding example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:websocket="http://www.springframework.org/schema/websocket"
	xsi:schemaLocation="
		http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/websocket
		https://www.springframework.org/schema/websocket/spring-websocket.xsd"&gt;

	&lt;websocket:message-broker application-destination-prefix="/app"&gt;
		&lt;websocket:stomp-endpoint path="/portfolio"&gt;
			&lt;websocket:sockjs/&gt;
		&lt;/websocket:stomp-endpoint&gt;
		&lt;websocket:simple-broker prefix="/topic, /queue"/&gt;
	&lt;/websocket:message-broker&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For the built-in simple broker, the <code>/topic</code> and <code>/queue</code> prefixes do not have any special
meaning. They are merely a convention to differentiate between pub-sub versus point-to-point
messaging (that is, many subscribers versus one consumer). When you use an external broker,
check the STOMP page of the broker to understand what kind of STOMP destinations and
prefixes it supports.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To connect from a browser, for SockJS, you can use the
<a href="https://github.com/sockjs/sockjs-client"><code>sockjs-client</code></a>. For STOMP, many applications have
used the <a href="https://github.com/jmesnil/stomp-websocket">jmesnil/stomp-websocket</a> library
(also known as stomp.js), which is feature-complete and has been used in production for
years but is no longer maintained. At present the
<a href="https://github.com/JSteunou/webstomp-client">JSteunou/webstomp-client</a> is the most
actively maintained and evolving successor of that library. The following example code
is based on it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">var socket = new SockJS("/spring-websocket-portfolio/portfolio");
var stompClient = webstomp.over(socket);

stompClient.connect({}, function(frame) {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, if you connect through WebSocket (without SockJS), you can use the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">var socket = new WebSocket("/spring-websocket-portfolio/portfolio");
var stompClient = Stomp.over(socket);

stompClient.connect({}, function(frame) {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that <code>stompClient</code> in the preceding example does not need to specify <code>login</code>
and <code>passcode</code> headers. Even if it did, they would be ignored (or, rather,
overridden) on the server side. See <a href="#websocket-stomp-handle-broker-relay-configure">Connecting to a Broker</a>
and <a href="#websocket-stomp-authentication">Authentication</a> for more information on authentication.</p>
</div>
<div class="paragraph">
<p>For more example code see:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://spring.io/guides/gs/messaging-stomp-websocket/">Using WebSocket to build an
interactive web application</a>&#8201;&#8212;&#8201;a getting started guide.</p>
</li>
<li>
<p><a href="https://github.com/rstoyanchev/spring-websocket-portfolio">Stock Portfolio</a>&#8201;&#8212;&#8201;a sample
application.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="websocket-stomp-server-config"><a class="anchor" href="#websocket-stomp-server-config"></a>WebSocket Server</h3>
<div class="paragraph">
<p>To configure the underlying WebSocket server, the information in
<a href="#websocket-server-runtime-configuration">Server Configuration</a> applies. For Jetty, however you need to set
the <code>HandshakeHandler</code> and <code>WebSocketPolicy</code> through the <code>StompEndpointRegistry</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

	@Override
	public void registerStompEndpoints(StompEndpointRegistry registry) {
		registry.addEndpoint("/portfolio").setHandshakeHandler(handshakeHandler());
	}

	@Bean
	public DefaultHandshakeHandler handshakeHandler() {

		WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);
		policy.setInputBufferSize(8192);
		policy.setIdleTimeout(600000);

		return new DefaultHandshakeHandler(
				new JettyRequestUpgradeStrategy(new WebSocketServerFactory(policy)));
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="websocket-stomp-message-flow"><a class="anchor" href="#websocket-stomp-message-flow"></a>Flow of Messages</h3>
<div class="paragraph">
<p>Once a STOMP endpoint is exposed, the Spring application becomes a STOMP broker for
connected clients. This section describes the flow of messages on the server side.</p>
</div>
<div class="paragraph">
<p>The <code>spring-messaging</code> module contains foundational support for messaging applications
that originated in <a href="https://spring.io/spring-integration">Spring Integration</a> and was
later extracted and incorporated into the Spring Framework for broader use across many
<a href="https://spring.io/projects">Spring projects</a> and application scenarios.
The following list briefly describes a few of the available messaging abstractions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/messaging/Message.html">Message</a>:
Simple representation for a message, including headers and payload.</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/messaging/MessageHandler.html">MessageHandler</a>:
Contract for handling a message.</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/messaging/MessageChannel.html">MessageChannel</a>:
Contract for sending a message that enables loose coupling between producers and consumers.</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/messaging/SubscribableChannel.html">SubscribableChannel</a>:
<code>MessageChannel</code> with <code>MessageHandler</code> subscribers.</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/messaging/support/ExecutorSubscribableChannel.html">ExecutorSubscribableChannel</a>:
<code>SubscribableChannel</code> that uses an <code>Executor</code> for delivering messages.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Both the Java configuration (that is, <code>@EnableWebSocketMessageBroker</code>) and the XML namespace configuration
(that is,<code>&lt;websocket:message-broker&gt;</code>) use the preceding components to assemble a message
workflow. The following diagram shows the components used when the simple built-in message
broker is enabled:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/message-flow-simple-broker.png" alt="message flow simple broker">
</div>
</div>
<div class="paragraph">
<p>The preceding diagram shows three message channels:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>clientInboundChannel</code>: For passing messages received from WebSocket clients.</p>
</li>
<li>
<p><code>clientOutboundChannel</code>: For sending server messages to WebSocket clients.</p>
</li>
<li>
<p><code>brokerChannel</code>: For sending messages to the message broker from within
server-side application code.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The next diagram shows the components used when an external broker (such as RabbitMQ)
is configured for managing subscriptions and broadcasting messages:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/message-flow-broker-relay.png" alt="message flow broker relay">
</div>
</div>
<div class="paragraph">
<p>The main difference between the two preceding diagrams is the use of the &#8220;broker relay&#8221; for passing
messages up to the external STOMP broker over TCP and for passing messages down from the
broker to subscribed clients.</p>
</div>
<div class="paragraph">
<p>When messages are received from a WebSocket connection, they are decoded to STOMP frames,
turned into a Spring <code>Message</code> representation, and sent to the
<code>clientInboundChannel</code> for further processing. For example, STOMP messages whose
destination headers start with <code>/app</code> may be routed to <code>@MessageMapping</code> methods in
annotated controllers, while <code>/topic</code> and <code>/queue</code> messages may be routed directly
to the message broker.</p>
</div>
<div class="paragraph">
<p>An annotated <code>@Controller</code> that handles a STOMP message from a client may send a message to
the message broker through the <code>brokerChannel</code>, and the broker broadcasts the
message to matching subscribers through the <code>clientOutboundChannel</code>. The same
controller can also do the same in response to HTTP requests, so a client can perform an
HTTP POST, and then a <code>@PostMapping</code> method can send a message to the message broker
to broadcast to subscribed clients.</p>
</div>
<div class="paragraph">
<p>We can trace the flow through a simple example. Consider the following example, which sets up a server:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

	@Override
	public void registerStompEndpoints(StompEndpointRegistry registry) {
		registry.addEndpoint("/portfolio");
	}

	@Override
	public void configureMessageBroker(MessageBrokerRegistry registry) {
		registry.setApplicationDestinationPrefixes("/app");
		registry.enableSimpleBroker("/topic");
	}
}

@Controller
public class GreetingController {

	@MessageMapping("/greeting") {
	public String handle(String greeting) {
		return "[" + getTimestamp() + ": " + greeting;
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding example supports the following flow:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The client connects to <code><a href="http://localhost:8080/portfolio" class="bare">http://localhost:8080/portfolio</a></code> and, once a WebSocket connection
is established, STOMP frames begin to flow on it.</p>
</li>
<li>
<p>The client sends a SUBSCRIBE frame with a destination header of <code>/topic/greeting</code>. Once received
and decoded, the message is sent to the <code>clientInboundChannel</code> and is then routed to the
message broker, which stores the client subscription.</p>
</li>
<li>
<p>The client sends a aSEND frame to <code>/app/greeting</code>. The <code>/app</code> prefix helps to route it to
annotated controllers. After the <code>/app</code> prefix is stripped, the remaining <code>/greeting</code>
part of the destination is mapped to the <code>@MessageMapping</code> method in <code>GreetingController</code>.</p>
</li>
<li>
<p>The value returned from <code>GreetingController</code> is turned into a Spring <code>Message</code> with
a payload based on the return value and a default destination header of
<code>/topic/greeting</code> (derived from the input destination with <code>/app</code> replaced by
<code>/topic</code>). The resulting message is sent to the <code>brokerChannel</code> and handled
by the message broker.</p>
</li>
<li>
<p>The message broker finds all matching subscribers and sends a MESSAGE frame to each one
through the <code>clientOutboundChannel</code>, from where messages are encoded as STOMP frames
and sent on the WebSocket connection.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The next section provides more details on annotated methods, including the
kinds of arguments and return values that are supported.</p>
</div>
</div>
<div class="sect2">
<h3 id="websocket-stomp-handle-annotations"><a class="anchor" href="#websocket-stomp-handle-annotations"></a>Annotated Controllers</h3>
<div class="paragraph">
<p>Applications can use annotated <code>@Controller</code> classes to handle messages from clients.
Such classes can declare <code>@MessageMapping</code>, <code>@SubscribeMapping</code>, and <code>@ExceptionHandler</code>
methods, as described in the following topics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#websocket-stomp-message-mapping"><code>@MessageMapping</code></a></p>
</li>
<li>
<p><a href="#websocket-stomp-subscribe-mapping"><code>@SubscribeMapping</code></a></p>
</li>
<li>
<p><a href="#websocket-stomp-exception-handler"><code>@MessageExceptionHandler</code></a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="websocket-stomp-message-mapping"><a class="anchor" href="#websocket-stomp-message-mapping"></a><code>@MessageMapping</code></h4>
<div class="paragraph">
<p>You can use <code>@MessageMapping</code> to annotate methods that route messages based on their
destination. It is supported at the method level as well as at the type level. At the type
level, <code>@MessageMapping</code> is used to express shared mappings across all methods in a
controller.</p>
</div>
<div class="paragraph">
<p>By default, the mapping values are Ant-style path patterns (for example <code>/thing*</code>, <code>/thing/**</code>),
including support for template variables (for example, <code>/thing/{id}</code>). The values can be
referenced through <code>@DestinationVariable</code> method arguments. Applications can also switch to
a dot-separated destination convention for mappings, as explained in
<a href="#websocket-stomp-destination-separator">Dots as Separators</a>.</p>
</div>
<div class="sect4">
<h5 id="_supported_method_arguments"><a class="anchor" href="#_supported_method_arguments"></a>Supported Method Arguments</h5>
<div class="paragraph">
<p>The following table describes the method arguments:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Method argument</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Message</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to the complete message.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MessageHeaders</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to the headers within the <code>Message</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MessageHeaderAccessor</code>, <code>SimpMessageHeaderAccessor</code>, and <code>StompHeaderAccessor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to the headers through typed accessor methods.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Payload</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to the payload of the message, converted (for example, from JSON) by a configured
<code>MessageConverter</code>.</p>
<p class="tableblock">The presence of this annotation is not required since it is, by default, assumed if no
other argument is matched.</p>
<p class="tableblock">You can annotate payload arguments with <code>@javax.validation.Valid</code> or Spring&#8217;s <code>@Validated</code>,
to have the payload arguments be automatically validated.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Header</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to a specific header value&#8201;&#8212;&#8201;along with type conversion using an
<code>org.springframework.core.convert.converter.Converter</code>, if necessary.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Headers</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to all headers in the message. This argument must be assignable to
<code>java.util.Map</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@DestinationVariable</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to template variables extracted from the message destination.
Values are converted to the declared method argument type as necessary.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.security.Principal</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reflects the user logged in at the time of the WebSocket HTTP handshake.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="_return_values"><a class="anchor" href="#_return_values"></a>Return Values</h5>
<div class="paragraph">
<p>By default, the return value from a <code>@MessageMapping</code> method is serialized to a payload
through a matching <code>MessageConverter</code> and sent as a <code>Message</code> to the <code>brokerChannel</code>,
from where it is broadcast to subscribers. The destination of the outbound message is the
same as that of the inbound message but prefixed with <code>/topic</code>.</p>
</div>
<div class="paragraph">
<p>You can use the <code>@SendTo</code> and <code>@SendToUser</code> annotations to customize the destination of
the output message. <code>@SendTo</code> is used to customize the target destination or to
specify multiple destinations. <code>@SendToUser</code> is used to direct the output message
to only the user associated with the input message. See <a href="#websocket-stomp-user-destination">User Destinations</a>.</p>
</div>
<div class="paragraph">
<p>You can use both <code>@SendTo</code> and <code>@SendToUser</code> at the same time on the same method, and both
are supported at the class level, in which case they act as a default for methods in the
class. However, keep in mind that any method-level <code>@SendTo</code> or <code>@SendToUser</code> annotations
override any such annotations at the class level.</p>
</div>
<div class="paragraph">
<p>Messages can be handled asynchronously and a <code>@MessageMapping</code> method can return
<code>ListenableFuture</code>, <code>CompletableFuture</code>, or <code>CompletionStage</code>.</p>
</div>
<div class="paragraph">
<p>Note that <code>@SendTo</code> and <code>@SendToUser</code> are merely a convenience that amounts to using the
<code>SimpMessagingTemplate</code> to send messages. If necessary, for more advanced scenarios,
<code>@MessageMapping</code> methods can fall back on using the <code>SimpMessagingTemplate</code> directly.
This can be done instead of, or possibly in addition to, returning a value.
See <a href="#websocket-stomp-handle-send">Sending Messages</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-subscribe-mapping"><a class="anchor" href="#websocket-stomp-subscribe-mapping"></a><code>@SubscribeMapping</code></h4>
<div class="paragraph">
<p><code>@SubscribeMapping</code> is similar to <code>@MessageMapping</code> but narrows the mapping to
subscription messages only. It supports the same
<a href="#websocket-stomp-message-mapping">method arguments</a> as <code>@MessageMapping</code>. However
for the return value, by default, a message is sent directly to the client (through
<code>clientOutboundChannel</code>, in response to the subscription) and not to the broker (through
<code>brokerChannel</code>, as a broadcast to matching subscriptions). Adding <code>@SendTo</code> or
<code>@SendToUser</code> overrides this behavior and sends to the broker instead.</p>
</div>
<div class="paragraph">
<p>When is this useful? Assume that the broker is mapped to <code>/topic</code> and <code>/queue</code>, while
application controllers are mapped to <code>/app</code>. In this setup, the broker stores all
subscriptions to <code>/topic</code> and <code>/queue</code> that are intended for repeated broadcasts, and
there is no need for the application to get involved. A client could also subscribe to
some <code>/app</code> destination, and a controller could return a value in response to that
subscription without involving the broker without storing or using the subscription again
(effectively a one-time request-reply exchange). One use case for this is populating a UI
with initial data on startup.</p>
</div>
<div class="paragraph">
<p>When is this not useful? Do not try to map broker and controllers to the same destination
prefix unless you want both to independently process messages, including subscriptions,
for some reason. Inbound messages are handled in parallel. There are no guarantees whether
a broker or a controller processes a given message first. If the goal is to be notified
when a subscription is stored and ready for broadcasts, a client should ask for a
receipt if the server supports it (simple broker does not). For example, with the Java
<a href="#websocket-stomp-client">STOMP client</a>, you could do the following to add a receipt:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired
private TaskScheduler messageBrokerTaskScheduler;

// During initialization..
stompClient.setTaskScheduler(this.messageBrokerTaskScheduler);

// When subscribing..
StompHeaders headers = new StompHeaders();
headers.setDestination("/topic/...");
headers.setReceipt("r1");
FrameHandler handler = ...;
stompSession.subscribe(headers, handler).addReceiptTask(() -&gt; {
	// Subscription ready...
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>A server side option is <a href="#websocket-stomp-interceptors">to register</a> an
<code>ExecutorChannelInterceptor</code> on the <code>brokerChannel</code> and implement the <code>afterMessageHandled</code>
method that is invoked after messages, including subscriptions, have been handled.</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-exception-handler"><a class="anchor" href="#websocket-stomp-exception-handler"></a><code>@MessageExceptionHandler</code></h4>
<div class="paragraph">
<p>An application can use <code>@MessageExceptionHandler</code> methods to handle exceptions from
<code>@MessageMapping</code> methods. You can declare exceptions in the annotation
itself or through a method argument if you want to get access to the exception instance.
The following example declares an exception through a method argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
public class MyController {

	// ...

	@MessageExceptionHandler
	public ApplicationError handleException(MyException exception) {
		// ...
		return appError;
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@MessageExceptionHandler</code> methods support flexible method signatures and support
the same method argument types and return values as
<a href="#websocket-stomp-message-mapping"><code>@MessageMapping</code></a> methods.</p>
</div>
<div class="paragraph">
<p>Typically, <code>@MessageExceptionHandler</code> methods apply within the <code>@Controller</code> class
(or class hierarchy) in which they are declared. If you want such methods to apply
more globally (across controllers), you can declare them in a class marked with
<code>@ControllerAdvice</code>. This is comparable to the
<a href="../web.html#mvc-ann-controller-advice" class="page">similar support</a> available in Spring MVC.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="websocket-stomp-handle-send"><a class="anchor" href="#websocket-stomp-handle-send"></a>Sending Messages</h3>
<div class="paragraph">
<p>What if you want to send messages to connected clients from any part of the
application? Any application component can send messages to the <code>brokerChannel</code>.
The easiest way to do so is to inject a <code>SimpMessagingTemplate</code> and
use it to send messages. Typically, you would inject it by
type, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
public class GreetingController {

	private SimpMessagingTemplate template;

	@Autowired
	public GreetingController(SimpMessagingTemplate template) {
		this.template = template;
	}

	@RequestMapping(path="/greetings", method=POST)
	public void greet(String greeting) {
		String text = "[" + getTimestamp() + "]:" + greeting;
		this.template.convertAndSend("/topic/greetings", text);
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, you can also qualify it by its name (<code>brokerMessagingTemplate</code>), if another
bean of the same type exists.</p>
</div>
</div>
<div class="sect2">
<h3 id="websocket-stomp-handle-simple-broker"><a class="anchor" href="#websocket-stomp-handle-simple-broker"></a>Simple Broker</h3>
<div class="paragraph">
<p>The built-in simple message broker handles subscription requests from clients,
stores them in memory, and broadcasts messages to connected clients that have matching
destinations. The broker supports path-like destinations, including subscriptions
to Ant-style destination patterns.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Applications can also use dot-separated (rather than slash-separated) destinations.
See <a href="#websocket-stomp-destination-separator">Dots as Separators</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If configured with a task scheduler, the simple broker supports
<a href="https://stomp.github.io/stomp-specification-1.2.html#Heart-beating">STOMP heartbeats</a>.
For that, you can declare your own scheduler or use the one that is automatically
declared and used internally. The following example shows how to declare your own scheduler:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

	private TaskScheduler messageBrokerTaskScheduler;

	@Autowired
	public void setMessageBrokerTaskScheduler(TaskScheduler taskScheduler) {
		this.messageBrokerTaskScheduler = taskScheduler;
	}

	@Override
	public void configureMessageBroker(MessageBrokerRegistry registry) {

		registry.enableSimpleBroker("/queue/", "/topic/")
				.setHeartbeatValue(new long[] {10000, 20000})
				.setTaskScheduler(this.messageBrokerTaskScheduler);

		// ...
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="websocket-stomp-handle-broker-relay"><a class="anchor" href="#websocket-stomp-handle-broker-relay"></a>External Broker</h3>
<div class="paragraph">
<p>The simple broker is great for getting started but supports only a subset of
STOMP commands (it does not support acks, receipts, and some other features),
relies on a simple message-sending loop, and is not suitable for clustering.
As an alternative, you can upgrade your applications to use a full-featured
message broker.</p>
</div>
<div class="paragraph">
<p>See the STOMP documentation for your message broker of choice (such as
<a href="https://www.rabbitmq.com/stomp.html">RabbitMQ</a>,
<a href="https://activemq.apache.org/stomp.html">ActiveMQ</a>, and others), install the broker,
and run it with STOMP support enabled. Then you can enable the STOMP broker relay
(instead of the simple broker) in the Spring configuration.</p>
</div>
<div class="paragraph">
<p>The following example configuration enables a full-featured broker:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

	@Override
	public void registerStompEndpoints(StompEndpointRegistry registry) {
		registry.addEndpoint("/portfolio").withSockJS();
	}

	@Override
	public void configureMessageBroker(MessageBrokerRegistry registry) {
		registry.enableStompBrokerRelay("/topic", "/queue");
		registry.setApplicationDestinationPrefixes("/app");
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the XML configuration equivalent of the preceding example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:websocket="http://www.springframework.org/schema/websocket"
	xsi:schemaLocation="
		http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/websocket
		https://www.springframework.org/schema/websocket/spring-websocket.xsd"&gt;

	&lt;websocket:message-broker application-destination-prefix="/app"&gt;
		&lt;websocket:stomp-endpoint path="/portfolio" /&gt;
			&lt;websocket:sockjs/&gt;
		&lt;/websocket:stomp-endpoint&gt;
		&lt;websocket:stomp-broker-relay prefix="/topic,/queue" /&gt;
	&lt;/websocket:message-broker&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The STOMP broker relay in the preceding configuration is a Spring
<a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/messaging/MessageHandler.html"><code>MessageHandler</code></a>
that handles messages by forwarding them to an external message broker.
To do so, it establishes TCP connections to the broker, forwards all messages to it,
and then forwards all messages received from the broker to clients through their
WebSocket sessions. Essentially, it acts as a &#8220;relay&#8221; that forwards messages
in both directions.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Add <code>io.projectreactor.netty:reactor-netty</code> and <code>io.netty:netty-all</code>
dependencies to your project for TCP connection management.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Furthermore, application components (such as HTTP request handling methods,
business services, and others) can also send messages to the broker relay, as described
in <a href="#websocket-stomp-handle-send">Sending Messages</a>, to broadcast messages to subscribed WebSocket clients.</p>
</div>
<div class="paragraph">
<p>In effect, the broker relay enables robust and scalable message broadcasting.</p>
</div>
</div>
<div class="sect2">
<h3 id="websocket-stomp-handle-broker-relay-configure"><a class="anchor" href="#websocket-stomp-handle-broker-relay-configure"></a>Connecting to a Broker</h3>
<div class="paragraph">
<p>A STOMP broker relay maintains a single &#8220;system&#8221; TCP connection to the broker.
This connection is used for messages originating from the server-side application
only, not for receiving messages. You can configure the STOMP credentials (that is,
the STOMP frame <code>login</code> and <code>passcode</code> headers) for this connection. This is exposed
in both the XML namespace and Java configuration as the <code>systemLogin</code> and
<code>systemPasscode</code> properties with default values of <code>guest</code> and <code>guest</code>.</p>
</div>
<div class="paragraph">
<p>The STOMP broker relay also creates a separate TCP connection for every connected
WebSocket client. You can configure the STOMP credentials that are used for all TCP
connections created on behalf of clients. This is exposed in both the XML namespace
and Java configuration as the <code>clientLogin</code> and <code>clientPasscode</code> properties with default
values of <code>guest</code> and <code>guest</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The STOMP broker relay always sets the <code>login</code> and <code>passcode</code> headers on every <code>CONNECT</code>
frame that it forwards to the broker on behalf of clients. Therefore, WebSocket clients
need not set those headers. They are ignored. As the <a href="#websocket-stomp-authentication">Authentication</a>
section explains, WebSocket clients should instead rely on HTTP authentication to protect
the WebSocket endpoint and establish the client identity.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The STOMP broker relay also sends and receives heartbeats to and from the message
broker over the &#8220;system&#8221; TCP connection. You can configure the intervals for sending
and receiving heartbeats (10 seconds each by default). If connectivity to the broker
is lost, the broker relay continues to try to reconnect, every 5 seconds,
until it succeeds.</p>
</div>
<div class="paragraph">
<p>Any Spring bean can implement <code>ApplicationListener&lt;BrokerAvailabilityEvent&gt;</code>
to receive notifications when the &#8220;system&#8221; connection to the broker is lost and
re-established. For example, a Stock Quote service that broadcasts stock quotes can
stop trying to send messages when there is no active &#8220;system&#8221; connection.</p>
</div>
<div class="paragraph">
<p>By default, the STOMP broker relay always connects, and reconnects as needed if
connectivity is lost, to the same host and port. If you wish to supply multiple addresses,
on each attempt to connect, you can configure a supplier of addresses, instead of a
fixed host and port. The following example shows how to do that:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer {

	// ...

	@Override
	public void configureMessageBroker(MessageBrokerRegistry registry) {
		registry.enableStompBrokerRelay("/queue/", "/topic/").setTcpClient(createTcpClient());
		registry.setApplicationDestinationPrefixes("/app");
	}

	private ReactorNettyTcpClient&lt;byte[]&gt; createTcpClient() {
		return new ReactorNettyTcpClient&lt;&gt;(
				client -&gt; client.addressSupplier(() -&gt; ... ),
				new StompReactorNettyCodec());
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also configure the STOMP broker relay with a <code>virtualHost</code> property.
The value of this property is set as the <code>host</code> header of every <code>CONNECT</code> frame
and can be useful (for example, in a cloud environment where the actual host to which
the TCP connection is established differs from the host that provides the
cloud-based STOMP service).</p>
</div>
</div>
<div class="sect2">
<h3 id="websocket-stomp-destination-separator"><a class="anchor" href="#websocket-stomp-destination-separator"></a>Dots as Separators</h3>
<div class="paragraph">
<p>When messages are routed to <code>@MessageMapping</code> methods, they are matched with
<code>AntPathMatcher</code>. By default, patterns are expected to use slash (<code>/</code>) as the separator.
This is a good convention in web applications and similar to HTTP URLs. However, if
you are more used to messaging conventions, you can switch to using dot (<code>.</code>) as the separator.</p>
</div>
<div class="paragraph">
<p>The following example shows how to do so in Java configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

	// ...

	@Override
	public void configureMessageBroker(MessageBrokerRegistry registry) {
		registry.setPathMatcher(new AntPathMatcher("."));
		registry.enableStompBrokerRelay("/queue", "/topic");
		registry.setApplicationDestinationPrefixes("/app");
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the XML configuration equivalent of the preceding example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:websocket="http://www.springframework.org/schema/websocket"
		xsi:schemaLocation="
				http://www.springframework.org/schema/beans
				https://www.springframework.org/schema/beans/spring-beans.xsd
				http://www.springframework.org/schema/websocket
				https://www.springframework.org/schema/websocket/spring-websocket.xsd"&gt;

	&lt;websocket:message-broker application-destination-prefix="/app" path-matcher="pathMatcher"&gt;
		&lt;websocket:stomp-endpoint path="/stomp"/&gt;
		&lt;websocket:stomp-broker-relay prefix="/topic,/queue" /&gt;
	&lt;/websocket:message-broker&gt;

	&lt;bean id="pathMatcher" class="org.springframework.util.AntPathMatcher"&gt;
		&lt;constructor-arg index="0" value="."/&gt;
	&lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>After that, a controller can use a dot (<code>.</code>) as the separator in <code>@MessageMapping</code> methods,
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
@MessageMapping("red")
public class RedController {

	@MessageMapping("blue.{green}")
	public void handleGreen(@DestinationVariable String green) {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The client can now send a message to <code>/app/red.blue.green123</code>.</p>
</div>
<div class="paragraph">
<p>In the preceding example, we did not change the prefixes on the &#8220;broker relay&#8221;, because those
depend entirely on the external message broker. See the STOMP documentation pages for
the broker you use to see what conventions it supports for the destination header.</p>
</div>
<div class="paragraph">
<p>The &#8220;simple broker&#8221;, on the other hand, does rely on the configured <code>PathMatcher</code>, so, if
you switch the separator, that change also applies to the broker and the way the broker matches
destinations from a message to patterns in subscriptions.</p>
</div>
</div>
<div class="sect2">
<h3 id="websocket-stomp-authentication"><a class="anchor" href="#websocket-stomp-authentication"></a>Authentication</h3>
<div class="paragraph">
<p>Every STOMP over WebSocket messaging session begins with an HTTP request.
That can be a request to upgrade to WebSockets (that is, a WebSocket handshake)
or, in the case of SockJS fallbacks, a series of SockJS HTTP transport requests.</p>
</div>
<div class="paragraph">
<p>Many web applications already have authentication and authorization in place to
secure HTTP requests. Typically, a user is authenticated through Spring Security
by using some mechanism such as a login page, HTTP basic authentication, or another way.
The security context for the authenticated user is saved in the HTTP session
and is associated with subsequent requests in the same cookie-based session.</p>
</div>
<div class="paragraph">
<p>Therefore, for a WebSocket handshake or for SockJS HTTP transport requests,
typically, there is already an authenticated user accessible through
<code>HttpServletRequest#getUserPrincipal()</code>. Spring automatically associates that user
with a WebSocket or SockJS session created for them and, subsequently, with all
STOMP messages transported over that session through a user header.</p>
</div>
<div class="paragraph">
<p>In short, a typical web application needs to do nothing
beyond what it already does for security. The user is authenticated at
the HTTP request level with a security context that is maintained through a cookie-based
HTTP session (which is then associated with WebSocket or SockJS sessions created
for that user) and results in a user header being stamped on every <code>Message</code> flowing
through the application.</p>
</div>
<div class="paragraph">
<p>Note that the STOMP protocol does have <code>login</code> and <code>passcode</code> headers
on the <code>CONNECT</code> frame. Those were originally designed for and are still needed,
for example, for STOMP over TCP. However, for STOMP over WebSocket, by default,
Spring ignores authorization headers at the STOMP protocol level, assumes that
the user is already authenticated at the HTTP transport level, and expects that
the WebSocket or SockJS session contain the authenticated user.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Security provides
<a href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#websocket">WebSocket sub-protocol authorization</a>
that uses a <code>ChannelInterceptor</code> to authorize messages based on the user header in them.
Also, Spring Session provides a
<a href="https://docs.spring.io/spring-session/docs/current/reference/html5/#websocket">WebSocket integration</a>
that ensures the user HTTP session does not expire when the WebSocket session is still active.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="websocket-stomp-authentication-token-based"><a class="anchor" href="#websocket-stomp-authentication-token-based"></a>Token Authentication</h3>
<div class="paragraph">
<p><a href="https://github.com/spring-projects/spring-security-oauth">Spring Security OAuth</a>
provides support for token based security, including JSON Web Token (JWT).
You can use this as the authentication mechanism in Web applications,
including STOMP over WebSocket interactions, as described in the previous
section (that is, to maintain identity through a cookie-based session).</p>
</div>
<div class="paragraph">
<p>At the same time, cookie-based sessions are not always the best fit (for example,
in applications that do not maintain a server-side session or in
mobile applications where it is common to use headers for authentication).</p>
</div>
<div class="paragraph">
<p>The <a href="https://tools.ietf.org/html/rfc6455#section-10.5">WebSocket protocol, RFC 6455</a>
"doesn&#8217;t prescribe any particular way that servers can authenticate clients during
the WebSocket handshake." In practice, however, browser clients can use only standard
authentication headers (that is, basic HTTP authentication) or cookies and cannot (for example)
provide custom headers. Likewise, the SockJS JavaScript client does not provide
a way to send HTTP headers with SockJS transport requests. See
<a href="https://github.com/sockjs/sockjs-client/issues/196">sockjs-client issue 196</a>.
Instead, it does allow sending query parameters that you can use to send a token,
but that has its own drawbacks (for example, the token may be inadvertently
logged with the URL in server logs).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The preceding limitations are for browser-based clients and do not apply to the
Spring Java-based STOMP client, which does support sending headers with both
WebSocket and SockJS requests.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Therefore, applications that wish to avoid the use of cookies may not have any good
alternatives for authentication at the HTTP protocol level. Instead of using cookies,
they may prefer to authenticate with headers at the STOMP messaging protocol level
Doing so requires two simple steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Use the STOMP client to pass authentication headers at connect time.</p>
</li>
<li>
<p>Process the authentication headers with a <code>ChannelInterceptor</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The next example uses server-side configuration to register a custom authentication
interceptor. Note that an interceptor needs only to authenticate and set
the user header on the CONNECT <code>Message</code>. Spring notes and saves the authenticated
user and associate it with subsequent STOMP messages on the same session. The following
example shows how register a custom authentication interceptor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebSocketMessageBroker
public class MyConfig implements WebSocketMessageBrokerConfigurer {

	@Override
	public void configureClientInboundChannel(ChannelRegistration registration) {
		registration.interceptors(new ChannelInterceptor() {
			@Override
			public Message&lt;?&gt; preSend(Message&lt;?&gt; message, MessageChannel channel) {
				StompHeaderAccessor accessor =
						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);
				if (StompCommand.CONNECT.equals(accessor.getCommand())) {
					Authentication user = ... ; // access authentication header(s)
					accessor.setUser(user);
				}
				return message;
			}
		});
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Also, note that, when you use Spring Security&#8217;s authorization for messages, at present,
you need to ensure that the authentication <code>ChannelInterceptor</code> config is ordered
ahead of Spring Security&#8217;s. This is best done by declaring the custom interceptor in
its own implementation of <code>WebSocketMessageBrokerConfigurer</code> that is marked with
<code>@Order(Ordered.HIGHEST_PRECEDENCE + 99)</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="websocket-stomp-user-destination"><a class="anchor" href="#websocket-stomp-user-destination"></a>User Destinations</h3>
<div class="paragraph">
<p>An application can send messages that target a specific user, and Spring&#8217;s STOMP support
recognizes destinations prefixed with <code>/user/</code> for this purpose.
For example, a client might subscribe to the <code>/user/queue/position-updates</code> destination.
This destination is handled by the <code>UserDestinationMessageHandler</code> and
transformed into a destination unique to the user session
(such as <code>/queue/position-updates-user123</code>). This provides the convenience of subscribing
to a generically named destination while, at the same time, ensuring no collisions
with other users who subscribe to the same destination so that each user can receive
unique stock position updates.</p>
</div>
<div class="paragraph">
<p>On the sending side, messages can be sent to a destination such as
<code>/user/{username}/queue/position-updates</code>, which in turn is translated
by the <code>UserDestinationMessageHandler</code> into one or more destinations, one for each
session associated with the user. This lets any component within the application
send messages that target a specific user without necessarily knowing anything more
than their name and the generic destination. This is also supported through an
annotation and a messaging template.</p>
</div>
<div class="paragraph">
<p>A message-handling method can send messages to the user associated with
the message being handled through the <code>@SendToUser</code> annotation (also supported on
the class-level to share a common destination), as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
public class PortfolioController {

	@MessageMapping("/trade")
	@SendToUser("/queue/position-updates")
	public TradeResult executeTrade(Trade trade, Principal principal) {
		// ...
		return tradeResult;
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the user has more than one session, by default, all of the sessions subscribed
to the given destination are targeted. However, sometimes, it may be necessary to
target only the session that sent the message being handled. You can do so by
setting the <code>broadcast</code> attribute to false, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
public class MyController {

	@MessageMapping("/action")
	public void handleAction() throws Exception{
		// raise MyBusinessException here
	}

	@MessageExceptionHandler
	@SendToUser(destinations="/queue/errors", broadcast=false)
	public ApplicationError handleException(MyBusinessException exception) {
		// ...
		return appError;
	}
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
While user destinations generally imply an authenticated user, it is not strictly required.
A WebSocket session that is not associated with an authenticated user
can subscribe to a user destination. In such cases, the <code>@SendToUser</code> annotation
behaves exactly the same as with <code>broadcast=false</code> (that is, targeting only the
session that sent the message being handled).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can send a message to user destinations from any application
component by, for example, injecting the <code>SimpMessagingTemplate</code> created by the Java configuration or
the XML namespace. (The bean name is <code>brokerMessagingTemplate</code> if required
for qualification with <code>@Qualifier</code>.) The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Service
public class TradeServiceImpl implements TradeService {

	private final SimpMessagingTemplate messagingTemplate;

	@Autowired
	public TradeServiceImpl(SimpMessagingTemplate messagingTemplate) {
		this.messagingTemplate = messagingTemplate;
	}

	// ...

	public void afterTradeExecuted(Trade trade) {
		this.messagingTemplate.convertAndSendToUser(
				trade.getUserName(), "/queue/position-updates", trade.getResult());
	}
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When you use user destinations with an external message broker, you should check the broker
documentation on how to manage inactive queues, so that, when the user session is
over, all unique user queues are removed. For example, RabbitMQ creates auto-delete
queues when you use destinations such as <code>/exchange/amq.direct/position-updates</code>.
So, in that case, the client could subscribe to <code>/user/exchange/amq.direct/position-updates</code>.
Similarly, ActiveMQ has
<a href="https://activemq.apache.org/delete-inactive-destinations.html">configuration options</a>
for purging inactive destinations.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In a multi-application server scenario, a user destination may remain unresolved because
the user is connected to a different server. In such cases, you can configure a
destination to broadcast unresolved messages so that other servers have a chance to try.
This can be done through the <code>userDestinationBroadcast</code> property of the
<code>MessageBrokerRegistry</code> in Java configuration and the <code>user-destination-broadcast</code> attribute
of the <code>message-broker</code> element in XML.</p>
</div>
</div>
<div class="sect2">
<h3 id="websocket-stomp-ordered-messages"><a class="anchor" href="#websocket-stomp-ordered-messages"></a>Order of Messages</h3>
<div class="paragraph">
<p>Messages from the broker are published to the <code>clientOutboundChannel</code>, from where they are
written to WebSocket sessions. As the channel is backed by a <code>ThreadPoolExecutor</code>, messages
are processed in different threads, and the resulting sequence received by the client may
not match the exact order of publication.</p>
</div>
<div class="paragraph">
<p>If this is an issue, enable the <code>setPreservePublishOrder</code> flag, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebSocketMessageBroker
public class MyConfig implements WebSocketMessageBrokerConfigurer {

	@Override
	protected void configureMessageBroker(MessageBrokerRegistry registry) {
		// ...
		registry.setPreservePublishOrder(true);
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the XML configuration equivalent of the preceding example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:websocket="http://www.springframework.org/schema/websocket"
	xsi:schemaLocation="
		http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/websocket
		https://www.springframework.org/schema/websocket/spring-websocket.xsd"&gt;

	&lt;websocket:message-broker preserve-publish-order="true"&gt;
		&lt;!-- ... --&gt;
	&lt;/websocket:message-broker&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the flag is set, messages within the same client session are published to the
<code>clientOutboundChannel</code> one at a time, so that the order of publication is guaranteed.
Note that this incurs a small performance overhead, so you should enable it only if it is required.</p>
</div>
</div>
<div class="sect2">
<h3 id="websocket-stomp-appplication-context-events"><a class="anchor" href="#websocket-stomp-appplication-context-events"></a>Events</h3>
<div class="paragraph">
<p>Several <code>ApplicationContext</code> events are published and can be
received by implementing Spring&#8217;s <code>ApplicationListener</code> interface:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BrokerAvailabilityEvent</code>: Indicates when the broker becomes available or unavailable.
While the &#8220;simple&#8221; broker becomes available immediately on startup and remains so while
the application is running, the STOMP &#8220;broker relay&#8221; can lose its connection
to the full featured broker (for example, if the broker is restarted). The broker relay
has reconnect logic and re-establishes the &#8220;system&#8221; connection to the broker
when it comes back. As a result, this event is published whenever the state changes from connected
to disconnected and vice-versa. Components that use the <code>SimpMessagingTemplate</code> should
subscribe to this event and avoid sending messages at times when the broker is not
available. In any case, they should be prepared to handle <code>MessageDeliveryException</code>
when sending a message.</p>
</li>
<li>
<p><code>SessionConnectEvent</code>: Published when a new STOMP CONNECT is received to
indicate the start of a new client session. The event contains the message that represents the
connect, including the session ID, user information (if any), and any custom headers the client
sent. This is useful for tracking client sessions. Components subscribed
to this event can wrap the contained message with <code>SimpMessageHeaderAccessor</code> or
<code>StompMessageHeaderAccessor</code>.</p>
</li>
<li>
<p><code>SessionConnectedEvent</code>: Published shortly after a <code>SessionConnectEvent</code> when the
broker has sent a STOMP CONNECTED frame in response to the CONNECT. At this point, the
STOMP session can be considered fully established.</p>
</li>
<li>
<p><code>SessionSubscribeEvent</code>: Published when a new STOMP SUBSCRIBE is received.</p>
</li>
<li>
<p><code>SessionUnsubscribeEvent</code>: Published when a new STOMP UNSUBSCRIBE is received.</p>
</li>
<li>
<p><code>SessionDisconnectEvent</code>: Published when a STOMP session ends. The DISCONNECT may
have been sent from the client or it may be automatically generated when the
WebSocket session is closed. In some cases, this event is published more than once
per session. Components should be idempotent with regard to multiple disconnect events.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When you use a full-featured broker, the STOMP &#8220;broker relay&#8221; automatically reconnects the
&#8220;system&#8221; connection if broker becomes temporarily unavailable. Client connections,
however, are not automatically reconnected. Assuming heartbeats are enabled, the client
typically notices the broker is not responding within 10 seconds. Clients need to
implement their own reconnecting logic.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="websocket-stomp-interceptors"><a class="anchor" href="#websocket-stomp-interceptors"></a>Interception</h3>
<div class="paragraph">
<p><a href="#websocket-stomp-appplication-context-events">Events</a> provide notifications for the lifecycle
of a STOMP connection but not for every client message. Applications can also register a
<code>ChannelInterceptor</code> to intercept any message and in any part of the processing chain.
The following example shows how to intercept inbound messages from clients:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

	@Override
	public void configureClientInboundChannel(ChannelRegistration registration) {
		registration.interceptors(new MyChannelInterceptor());
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A custom <code>ChannelInterceptor</code> can use <code>StompHeaderAccessor</code> or <code>SimpMessageHeaderAccessor</code>
to access information about the message, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyChannelInterceptor implements ChannelInterceptor {

	@Override
	public Message&lt;?&gt; preSend(Message&lt;?&gt; message, MessageChannel channel) {
		StompHeaderAccessor accessor = StompHeaderAccessor.wrap(message);
		StompCommand command = accessor.getStompCommand();
		// ...
		return message;
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Applications can also implement <code>ExecutorChannelInterceptor</code>, which is a sub-interface
of <code>ChannelInterceptor</code> with callbacks in the thread in which the messages are handled.
While a <code>ChannelInterceptor</code> is invoked once for each message sent to a channel, the
<code>ExecutorChannelInterceptor</code> provides hooks in the thread of each <code>MessageHandler</code>
subscribed to messages from the channel.</p>
</div>
<div class="paragraph">
<p>Note that, as with the <code>SessionDisconnectEvent</code> described earlier, a DISCONNECT message
can be from the client or it can also be automatically generated when
the WebSocket session is closed. In some cases, an interceptor may intercept this
message more than once for each session. Components should be idempotent with regard to
multiple disconnect events.</p>
</div>
</div>
<div class="sect2">
<h3 id="websocket-stomp-client"><a class="anchor" href="#websocket-stomp-client"></a>STOMP Client</h3>
<div class="paragraph">
<p>Spring provides a STOMP over WebSocket client and a STOMP over TCP client.</p>
</div>
<div class="paragraph">
<p>To begin, you can create and configure <code>WebSocketStompClient</code>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">WebSocketClient webSocketClient = new StandardWebSocketClient();
WebSocketStompClient stompClient = new WebSocketStompClient(webSocketClient);
stompClient.setMessageConverter(new StringMessageConverter());
stompClient.setTaskScheduler(taskScheduler); // for heartbeats</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, you could replace <code>StandardWebSocketClient</code> with <code>SockJsClient</code>,
since that is also an implementation of <code>WebSocketClient</code>. The <code>SockJsClient</code> can
use WebSocket or HTTP-based transport as a fallback. For more details, see
<a href="#websocket-fallback-sockjs-client"><code>SockJsClient</code></a>.</p>
</div>
<div class="paragraph">
<p>Next, you can establish a connection and provide a handler for the STOMP session,
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String url = "ws://127.0.0.1:8080/endpoint";
StompSessionHandler sessionHandler = new MyStompSessionHandler();
stompClient.connect(url, sessionHandler);</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the session is ready for use, the handler is notified, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyStompSessionHandler extends StompSessionHandlerAdapter {

	@Override
	public void afterConnected(StompSession session, StompHeaders connectedHeaders) {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once the session is established, any payload can be sent and is
serialized with the configured <code>MessageConverter</code>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">session.send("/topic/something", "payload");</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also subscribe to destinations. The <code>subscribe</code> methods require a handler
for messages on the subscription and returns a <code>Subscription</code> handle that you can
use to unsubscribe. For each received message, the handler can specify the target
<code>Object</code> type to which the payload should be deserialized, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">session.subscribe("/topic/something", new StompFrameHandler() {

	@Override
	public Type getPayloadType(StompHeaders headers) {
		return String.class;
	}

	@Override
	public void handleFrame(StompHeaders headers, Object payload) {
		// ...
	}

});</code></pre>
</div>
</div>
<div class="paragraph">
<p>To enable STOMP heartbeat, you can configure <code>WebSocketStompClient</code> with a <code>TaskScheduler</code>
and optionally customize the heartbeat intervals (10 seconds for write inactivity,
which causes a heartbeat to be sent, and 10 seconds for read inactivity, which
closes the connection).</p>
</div>
<div class="paragraph">
<p><code>WebSocketStompClient</code> sends a heartbeat only in case of inactivity, i.e. when no
other messages are sent. This can present a challenge when using an external broker
since messages with a non-broker destination represent activity but aren&#8217;t actually
forwarded to the broker. In that case you can configure a <code>TaskScheduler</code>
when initializing the <a href="#websocket-stomp-handle-broker-relay">External Broker</a> which ensures a
heartbeat is forwarded to the broker also when only messages with a non-broker
destination are sent.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When you use <code>WebSocketStompClient</code> for performance tests to simulate thousands
of clients from the same machine, consider turning off heartbeats, since each
connection schedules its own heartbeat tasks and that is not optimized for
a large number of clients running on the same machine.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The STOMP protocol also supports receipts, where the client must add a <code>receipt</code>
header to which the server responds with a RECEIPT frame after the send or
subscribe are processed. To support this, the <code>StompSession</code> offers
<code>setAutoReceipt(boolean)</code> that causes a <code>receipt</code> header to be
added on every subsequent send or subscribe event.
Alternatively, you can also manually add a receipt header to the <code>StompHeaders</code>.
Both send and subscribe return an instance of <code>Receiptable</code>
that you can use to register for receipt success and failure callbacks.
For this feature, you must configure the client with a <code>TaskScheduler</code>
and the amount of time before a receipt expires (15 seconds by default).</p>
</div>
<div class="paragraph">
<p>Note that <code>StompSessionHandler</code> itself is a <code>StompFrameHandler</code>, which lets
it handle ERROR frames in addition to the <code>handleException</code> callback for
exceptions from the handling of messages and <code>handleTransportError</code> for
transport-level errors including <code>ConnectionLostException</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="websocket-stomp-websocket-scope"><a class="anchor" href="#websocket-stomp-websocket-scope"></a>WebSocket Scope</h3>
<div class="paragraph">
<p>Each WebSocket session has a map of attributes. The map is attached as a header to
inbound client messages and may be accessed from a controller method, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
public class MyController {

	@MessageMapping("/action")
	public void handle(SimpMessageHeaderAccessor headerAccessor) {
		Map&lt;String, Object&gt; attrs = headerAccessor.getSessionAttributes();
		// ...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can declare a Spring-managed bean in the <code>websocket</code> scope.
You can inject WebSocket-scoped beans into controllers and any channel interceptors
registered on the <code>clientInboundChannel</code>. Those are typically singletons and live
longer than any individual WebSocket session. Therefore, you need to use a
scope proxy mode for WebSocket-scoped beans, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
@Scope(scopeName = "websocket", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class MyBean {

	@PostConstruct
	public void init() {
		// Invoked after dependencies injected
	}

	// ...

	@PreDestroy
	public void destroy() {
		// Invoked when the WebSocket session ends
	}
}

@Controller
public class MyController {

	private final MyBean myBean;

	@Autowired
	public MyController(MyBean myBean) {
		this.myBean = myBean;
	}

	@MessageMapping("/action")
	public void handle() {
		// this.myBean from the current WebSocket session
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As with any custom scope, Spring initializes a new <code>MyBean</code> instance the first
time it is accessed from the controller and stores the instance in the WebSocket
session attributes. The same instance is subsequently returned until the session
ends. WebSocket-scoped beans have all Spring lifecycle methods invoked, as
shown in the preceding examples.</p>
</div>
</div>
<div class="sect2">
<h3 id="websocket-stomp-configuration-performance"><a class="anchor" href="#websocket-stomp-configuration-performance"></a>Performance</h3>
<div class="paragraph">
<p>There is no silver bullet when it comes to performance. Many factors
affect it, including the size and volume of messages, whether application
methods perform work that requires blocking, and external factors
(such as network speed and other issues). The goal of this section is to provide
an overview of the available configuration options along with some thoughts
on how to reason about scaling.</p>
</div>
<div class="paragraph">
<p>In a messaging application, messages are passed through channels for asynchronous
executions that are backed by thread pools. Configuring such an application requires
good knowledge of the channels and the flow of messages. Therefore, it is
recommended to review <a href="#websocket-stomp-message-flow">Flow of Messages</a>.</p>
</div>
<div class="paragraph">
<p>The obvious place to start is to configure the thread pools that back the
<code>clientInboundChannel</code> and the <code>clientOutboundChannel</code>. By default, both
are configured at twice the number of available processors.</p>
</div>
<div class="paragraph">
<p>If the handling of messages in annotated methods is mainly CPU-bound, the
number of threads for the <code>clientInboundChannel</code> should remain close to the
number of processors. If the work they do is more IO-bound and requires blocking
or waiting on a database or other external system, the thread pool size
probably needs to be increased.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>ThreadPoolExecutor</code> has three important properties: the core thread pool size,
the max thread pool size, and the capacity for the queue to store
tasks for which there are no available threads.</p>
</div>
<div class="paragraph">
<p>A common point of confusion is that configuring the core pool size (for example, 10)
and max pool size (for example, 20) results in a thread pool with 10 to 20 threads.
In fact, if the capacity is left at its default value of Integer.MAX_VALUE,
the thread pool never increases beyond the core pool size, since
all additional tasks are queued.</p>
</div>
<div class="paragraph">
<p>See the javadoc of <code>ThreadPoolExecutor</code> to learn how these properties work and
understand the various queuing strategies.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>On the <code>clientOutboundChannel</code> side, it is all about sending messages to WebSocket
clients. If clients are on a fast network, the number of threads should
remain close to the number of available processors. If they are slow or on
low bandwidth, they take longer to consume messages and put a burden on the
thread pool. Therefore, increasing the thread pool size becomes necessary.</p>
</div>
<div class="paragraph">
<p>While the workload for the <code>clientInboundChannel</code> is possible to predict&#8201;&#8212;&#8201;after all, it is based on what the application does&#8201;&#8212;&#8201;how to configure the
"clientOutboundChannel" is harder, as it is based on factors beyond
the control of the application. For this reason, two additional
properties relate to the sending of messages: <code>sendTimeLimit</code>
and <code>sendBufferSizeLimit</code>. You can use those methods to configure how long a
send is allowed to take and how much data can be buffered when sending
messages to a client.</p>
</div>
<div class="paragraph">
<p>The general idea is that, at any given time, only a single thread can be used
to send to a client. All additional messages, meanwhile, get buffered, and you
can use these properties to decide how long sending a message is allowed to
take and how much data can be buffered in the meantime. See the javadoc and
documentation of the XML schema for important additional details.</p>
</div>
<div class="paragraph">
<p>The following example shows a possible configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

	@Override
	public void configureWebSocketTransport(WebSocketTransportRegistration registration) {
		registration.setSendTimeLimit(15 * 1000).setSendBufferSizeLimit(512 * 1024);
	}

	// ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the XML configuration equivalent of the preceding example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:websocket="http://www.springframework.org/schema/websocket"
	xsi:schemaLocation="
		http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/websocket
		https://www.springframework.org/schema/websocket/spring-websocket.xsd"&gt;

	&lt;websocket:message-broker&gt;
		&lt;websocket:transport send-timeout="15000" send-buffer-size="524288" /&gt;
		&lt;!-- ... --&gt;
	&lt;/websocket:message-broker&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also use the WebSocket transport configuration shown earlier to configure the
maximum allowed size for incoming STOMP messages. In theory, a WebSocket
message can be almost unlimited in size. In practice, WebSocket servers impose
limits&#8201;&#8212;&#8201;for example, 8K on Tomcat and 64K on Jetty. For this reason, STOMP clients
(such as the JavaScript <a href="https://github.com/JSteunou/webstomp-client">webstomp-client</a>
and others) split larger STOMP messages at 16K boundaries and send them as multiple
WebSocket  messages, which requires the server to buffer and re-assemble.</p>
</div>
<div class="paragraph">
<p>Spring&#8217;s STOMP-over-WebSocket support does this ,so applications can configure the
maximum size for STOMP messages irrespective of WebSocket server-specific message
sizes. Keep in mind that the WebSocket message size is automatically
adjusted, if necessary, to ensure they can carry 16K WebSocket messages at a
minimum.</p>
</div>
<div class="paragraph">
<p>The following example shows one possible configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

	@Override
	public void configureWebSocketTransport(WebSocketTransportRegistration registration) {
		registration.setMessageSizeLimit(128 * 1024);
	}

	// ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the XML configuration equivalent of the preceding example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:websocket="http://www.springframework.org/schema/websocket"
	xsi:schemaLocation="
		http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/websocket
		https://www.springframework.org/schema/websocket/spring-websocket.xsd"&gt;

	&lt;websocket:message-broker&gt;
		&lt;websocket:transport message-size="131072" /&gt;
		&lt;!-- ... --&gt;
	&lt;/websocket:message-broker&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>An important point about scaling involves using multiple application instances.
Currently, you cannot do that with the simple broker.
However, when you use a full-featured broker (such as RabbitMQ), each application
instance connects to the broker, and messages broadcast from one application
instance can be broadcast through the broker to WebSocket clients connected
through any other application instances.</p>
</div>
</div>
<div class="sect2">
<h3 id="websocket-stomp-stats"><a class="anchor" href="#websocket-stomp-stats"></a>Monitoring</h3>
<div class="paragraph">
<p>When you use <code>@EnableWebSocketMessageBroker</code> or <code>&lt;websocket:message-broker&gt;</code>, key
infrastructure components automatically gather statisticss and counters that provide
important insight into the internal state of the application. The configuration
also declares a bean of type <code>WebSocketMessageBrokerStats</code> that gathers all
available information in one place and by default logs it at the <code>INFO</code> level once
every 30 minutes. This bean can be exported to JMX through Spring&#8217;s
<code>MBeanExporter</code> for viewing at runtime (for example, through JDK&#8217;s <code>jconsole</code>).
The following list summarizes the available information:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Client WebSocket Sessions</dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1">Current</dt>
<dd>
<p>Indicates how many client sessions there are
currently, with the count further broken down by WebSocket versus HTTP
streaming and polling SockJS sessions.</p>
</dd>
<dt class="hdlist1">Total</dt>
<dd>
<p>Indicates how many total sessions have been established.</p>
</dd>
<dt class="hdlist1">Abnormally Closed</dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1">Connect Failures</dt>
<dd>
<p>Sessions that got established but were
closed after not having received any messages within 60 seconds. This is
usually an indication of proxy or network issues.</p>
</dd>
<dt class="hdlist1">Send Limit Exceeded</dt>
<dd>
<p>Sessions closed after exceeding the configured send
timeout or the send buffer limits, which can occur with slow clients
(see previous section).</p>
</dd>
<dt class="hdlist1">Transport Errors</dt>
<dd>
<p>Sessions closed after a transport error, such as
failure to read or write to a WebSocket connection or
HTTP request or response.</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1">STOMP Frames</dt>
<dd>
<p>The total number of CONNECT, CONNECTED, and DISCONNECT frames
processed, indicating how many clients connected on the STOMP level. Note that
the DISCONNECT count may be lower when sessions get closed abnormally or when
clients close without sending a DISCONNECT frame.</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1">STOMP Broker Relay</dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1">TCP Connections</dt>
<dd>
<p>Indicates how many TCP connections on behalf of client
WebSocket sessions are established to the broker. This should be equal to the
number of client WebSocket sessions + 1 additional shared &#8220;system&#8221; connection
for sending messages from within the application.</p>
</dd>
<dt class="hdlist1">STOMP Frames</dt>
<dd>
<p>The total number of CONNECT, CONNECTED, and DISCONNECT frames
forwarded to or received from the broker on behalf of clients. Note that a
DISCONNECT frame is sent to the broker regardless of how the client WebSocket
session was closed. Therefore, a lower DISCONNECT frame count is an indication
that the broker is pro-actively closing connections (maybe because of a
heartbeat that did not arrive in time, an invalid input frame, or other issue).</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1">Client Inbound Channel</dt>
<dd>
<p>Statistics from the thread pool that backs the <code>clientInboundChannel</code>
that provide insight into the health of incoming message processing. Tasks queueing
up here is an indication that the application may be too slow to handle messages.
If there I/O bound tasks (for example, slow database queries, HTTP requests to third party
REST API, and so on), consider increasing the thread pool size.</p>
</dd>
<dt class="hdlist1">Client Outbound Channel</dt>
<dd>
<p>Statistics from the thread pool that backs the <code>clientOutboundChannel</code>
that provides insight into the health of broadcasting messages to clients. Tasks
queueing up here is an indication clients are too slow to consume messages.
One way to address this is to increase the thread pool size to accommodate the
expected number of concurrent slow clients. Another option is to reduce the
send timeout and send buffer size limits (see the previous section).</p>
</dd>
<dt class="hdlist1">SockJS Task Scheduler</dt>
<dd>
<p>Statistics from the thread pool of the SockJS task scheduler that
is used to send heartbeats. Note that, when heartbeats are negotiated on the
STOMP level, the SockJS heartbeats are disabled.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="websocket-stomp-testing"><a class="anchor" href="#websocket-stomp-testing"></a>Testing</h3>
<div class="paragraph">
<p>There are two main approaches to testing applications when you use Spring&#8217;s STOMP-over-WebSocket
support. The first is to write server-side tests to verify the functionality
of controllers and their annotated message-handling methods. The second is to write
full end-to-end tests that involve running a client and a server.</p>
</div>
<div class="paragraph">
<p>The two approaches are not mutually exclusive. On the contrary, each has a place
in an overall test strategy. Server-side tests are more focused and easier to write
and maintain. End-to-end integration tests, on the other hand, are more complete and
test much more, but they are also more involved to write and maintain.</p>
</div>
<div class="paragraph">
<p>The simplest form of server-side tests is to write controller unit tests. However,
this is not useful enough, since much of what a controller does depends on its
annotations. Pure unit tests simply cannot test that.</p>
</div>
<div class="paragraph">
<p>Ideally, controllers under test should be invoked as they are at runtime, much like
the approach to testing controllers that handle HTTP requests by using the Spring MVC Test
framework&#8201;&#8212;&#8201;that is, without running a Servlet container but relying on the Spring Framework
to invoke the annotated controllers. As with Spring MVC Test, you have two
possible alternatives here, either use a &#8220;context-based&#8221; or use a &#8220;standalone&#8221; setup:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Load the actual Spring configuration with the help of the
Spring TestContext framework, inject <code>clientInboundChannel</code> as a test field, and
use it to send messages to be handled by controller methods.</p>
</li>
<li>
<p>Manually set up the minimum Spring framework infrastructure required to invoke
controllers (namely the <code>SimpAnnotationMethodMessageHandler</code>) and pass messages for
controllers directly to it.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Both of these setup scenarios are demonstrated in the
<a href="https://github.com/rstoyanchev/spring-websocket-portfolio/tree/master/src/test/java/org/springframework/samples/portfolio/web">tests for the stock portfolio</a>
sample application.</p>
</div>
<div class="paragraph">
<p>The second approach is to create end-to-end integration tests. For that, you need
to run a WebSocket server in embedded mode and connect to it as a WebSocket client
that sends WebSocket messages containing STOMP frames.
The <a href="https://github.com/rstoyanchev/spring-websocket-portfolio/tree/master/src/test/java/org/springframework/samples/portfolio/web">tests for the stock portfolio</a>
sample application also demonstrate this approach by using Tomcat as the embedded
WebSocket server and a simple STOMP client for test purposes.</p>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer flex">
    <div id="spring-links flex">
        <img id="springlogo" src="../../../_/img/spring-logo.svg" alt="Spring">
        <p class="smallest antialiased"> <script>var d = new Date();
        document.write(d.getFullYear());</script> <a href="https://www.vmware.com/">VMware</a>, Inc. or its affiliates. <a href="https://www.vmware.com/help/legal.html">Terms of Use</a>  <a href="https://www.vmware.com/help/privacy.html" rel="noopener noreferrer">Privacy</a>  <a href="https://spring.io/trademarks">Trademark Guidelines</a> <span id="thank-you-mobile"> <a href="https://spring.io/thank-you">Thank you</a></span>  <a href="https://www.vmware.com/help/privacy/california-privacy-rights.html">Your California Privacy Rights</a>  <a class="ot-sdk-show-settings">Cookie Settings</a> <span id="teconsent"></span></p>
        <p class="smallest antialiased">Apache, Apache Tomcat, Apache Kafka, Apache Cassandra&trade;, and Apache Geode&trade; are trademarks or registered trademarks of the Apache Software Foundation in the United States and/or other countries. Java&trade;, Java&trade; SE, Java&trade; EE, and OpenJDK&trade; are trademarks of Oracle and/or its affiliates. Kubernetes is a registered trademark of the Linux Foundation in the United States and other countries. Linux is the registered trademark of Linus Torvalds in the United States and other countries. Windows and Microsoft Azure are registered trademarks of Microsoft Corporation. AWS and Amazon Web Services are trademarks or registered trademarks of Amazon.com Inc. or its affiliates. All other trademarks and copyrights are property of their respective owners and are only mentioned for informative purposes. Other names may be trademarks of their respective owners.</p>
    </div>
    <div id="social-icons" class="flex jc-between">
        <a href="https://www.youtube.com/user/SpringSourceDev" title="Youtube"><svg id="youtube-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 40 40"><circle class="cls-1" cx="20" cy="20" r="20"/><path class="cls-2" d="M30.91,14.53a2.89,2.89,0,0,0-2-2C27.12,12,20,12,20,12s-7.12,0-8.9.47a2.9,2.9,0,0,0-2,2A30.56,30.56,0,0,0,8.63,20a30.44,30.44,0,0,0,.46,5.47,2.89,2.89,0,0,0,2,2C12.9,28,20,28,20,28s7.12,0,8.9-.47a2.87,2.87,0,0,0,2-2A30.56,30.56,0,0,0,31.37,20,28.88,28.88,0,0,0,30.91,14.53ZM17.73,23.41V16.59L23.65,20Z"/></svg></a>
        <a href="https://github.com/spring-projects" title="Github"><svg id="github-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 75.93 75.93"><path class="cls-1" d="M38,0a38,38,0,1,0,38,38A38,38,0,0,0,38,0Z"/></g><path class="cls-2" d="M38,15.59A22.95,22.95,0,0,0,30.71,60.3c1.15.21,1.57-.5,1.57-1.11s0-2,0-3.9c-6.38,1.39-7.73-3.07-7.73-3.07A6.09,6.09,0,0,0,22,48.86c-2.09-1.42.15-1.39.15-1.39a4.81,4.81,0,0,1,3.52,2.36c2,3.5,5.37,2.49,6.67,1.91a4.87,4.87,0,0,1,1.46-3.07c-5.09-.58-10.45-2.55-10.45-11.34a8.84,8.84,0,0,1,2.36-6.15,8.29,8.29,0,0,1,.23-6.07s1.92-.62,6.3,2.35a21.82,21.82,0,0,1,11.49,0c4.38-3,6.3-2.35,6.3-2.35a8.29,8.29,0,0,1,.23,6.07,8.84,8.84,0,0,1,2.36,6.15c0,8.81-5.37,10.75-10.48,11.32a5.46,5.46,0,0,1,1.56,4.25c0,3.07,0,5.54,0,6.29s.42,1.33,1.58,1.1A22.94,22.94,0,0,0,38,15.59Z"/></svg></a>
        <a href="https://twitter.com/springcentral" title="Twitter"><svg id="twitter-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 75.93 75.93"><circle class="cls-1" cx="37.97" cy="37.97" r="37.97"/><path id="Twitter-2" data-name="Twitter" class="cls-2" d="M55.2,22.73a15.43,15.43,0,0,1-4.88,1.91,7.56,7.56,0,0,0-5.61-2.49A7.78,7.78,0,0,0,37,30a7.56,7.56,0,0,0,.2,1.79,21.63,21.63,0,0,1-15.84-8.23,8,8,0,0,0,2.37,10.52,7.66,7.66,0,0,1-3.48-1v.09A7.84,7.84,0,0,0,26.45,41a7.54,7.54,0,0,1-2,.28A7.64,7.64,0,0,1,23,41.09a7.71,7.71,0,0,0,7.18,5.47,15.21,15.21,0,0,1-9.55,3.37,15.78,15.78,0,0,1-1.83-.11,21.41,21.41,0,0,0,11.78,3.54c14.13,0,21.86-12,21.86-22.42,0-.34,0-.68,0-1a15.67,15.67,0,0,0,3.83-4.08,14.9,14.9,0,0,1-4.41,1.24A7.8,7.8,0,0,0,55.2,22.73Z"/></svg></a>
    </div>
</footer>
<script src="../../../_/js/site.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
<script async src="../../../_/js/vendor/tabs.js"></script>
<script src="../../../_/js/vendor/docsearch.min.js"></script>
<script src="../../../_/js/vendor/switchtheme.js"></script>
<!-- fetched from https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js -->
<script>
docsearch({
  apiKey: '6098173f7ca8a2fc7db296538ae8a6cc',
  indexName: 'spring',
  inputSelector: '#search-input',
  algoliaOptions: { hitsPerPage: 10 }
})
</script>
  </body>
</html>
