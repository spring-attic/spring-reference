<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Appendix :: Spring</title>
    <link rel="prev" href="spring-jcl.html">
    <link rel="next" href="../testing.html">
    <meta name="generator" content="Antora 3.0.0-alpha.8">
    <link rel="stylesheet" href="../../../_/css/site.css">

<link href="../../../_/img/favicon.ico" rel='shortcut icon' type='image/vnd.microsoft.icon'>
<link rel="stylesheet" href="../../../_/css/vendor/docsearch.min.css">
<!-- fetched from https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css -->
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://spring.io">
        <img id="springlogo" class="block" src="../../../_/img/spring-logo.svg" alt="Spring">
      </a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Why Spring</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://spring.io/why-spring">Overview</a>
            <a class="navbar-item" href="https://spring.io/microservices">Microservices</a>
            <a class="navbar-item" href="https://spring.io/reactive">Reactive</a>
            <a class="navbar-item" href="https://spring.io/event-driven">Event Driven</a>
            <a class="navbar-item" href="https://spring.io/cloud">Cloud</a>
            <a class="navbar-item" href="https://spring.io/web-applications">Web Applications</a>
            <a class="navbar-item" href="https://spring.io/serverless">Serverless</a>
            <a class="navbar-item" href="https://spring.io/batch">Batch</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Learn</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://spring.io/learn">Overview</a>
            <a class="navbar-item" href="https://spring.io/quickstart">Quickstart</a>
            <a class="navbar-item" href="https://spring.io/guides">Guides</a>
            <a class="navbar-item" href="https://spring.io/blog">Blog</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Projects</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://spring.io/projects">Overview</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-boot">Spring Boot</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-framework">Spring Framework</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-cloud">Spring Cloud</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-cloud-dataflow">Spring Cloud Data Flow</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-data">Spring Data</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-integration">Spring Integration</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-batch">Spring Batch</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-security">Spring Security</a>
            <a class="navbar-item navbar-item-special" href="https://spring.io/projects">View all projects</a>
            <a class="navbar-item" href="https://spring.io/tools">Spring Tools 4</a>
            <a class="navbar-item navbar-item-special-2" href="https://start.spring.io">Spring Initializr <svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><polyline points="15 10.94 15 15 1 15 1 1 5.06 1" fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="2"></polyline><polyline points="8.93 1 15 1 15 7.07" fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="2"></polyline><line x1="15" y1="1" x2="8" y2="8" fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="2"></line></svg></a>
          </div>
        </div>

        <a class="navbar-item" href="https://spring.io/training">Training</a>
        <a class="navbar-item" href="https://spring.io/support">Support</a>
        <div class="navbar-item has-dropdown is-hoverable is-community">
          <a class="navbar-link" href="#">Community</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://spring.io/community">Overview</a>
            <a class="navbar-item" href="https://spring.io/events">Events</a>
            <a class="navbar-item" href="https://spring.io/team">Team</a>
          </div>
        </div>
      </div>
    </div>
    <div id="switch-theme">
      <input type="checkbox" id="switch-theme-checkbox" />
      <label for="switch-theme-checkbox">Dark Theme</label>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="framework" data-version="5.3">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Spring Framework</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../overview.html">Overview</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../core.html">Core</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="beans/index.html">The IoC Container</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/container.html">Container Overview</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/bean.html">Bean Overview</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/dependencies.html">Bean Dependencies</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/scopes.html">Bean Scopes</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/customizing.html">Customizing the Nature of a Bean</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/inheritance.html">Bean Definition Inheritance</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/extension.html">Container Extension Points</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/annotation.html">Annotation-based Container Configuration</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/scanning.html">Classpath Scanning and Managed Components</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/jsr330.html">Using JSR 330 Standard Annotations</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/java.html">Java-based Container configuration</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/env.html">Environment Abstraction</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/loadtimeweaver.html">Registering a LoadTimeWeaver</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/applicationcontext.html">Additional Capabilities of the ApplicationContext</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/beanfactory.html">The BeanFactory</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="resources.html">Resources</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="validation.html">Validation, Data Binding, and Type Conversion</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="aop.html">Aspect Oriented Programming with Spring</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="aop-api.html">Spring AOP APIs</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="null-safety.html">Null-safety</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="databuffer-codec.html">Data Buffers and Codecs</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="spring-jcl.html">Logging</a>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="appendix.html">Appendix</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../testing.html">Testing</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../data-access.html">Data Access</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../web.html">Web Servlet</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../web-reactive.html">Web Reactive</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../integration.html">Integration</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../languages.html">Languages</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../appendix.html">Appendix</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Spring Framework</span>
    <span class="version">5.3</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">Spring Framework</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">5.3</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../security/index.html">Spring Security</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../security/index.html">6</a>
        </li>
        <li class="version">
          <a href="../../../security/5.6/index.html">5.6</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../session/2.6/index.html">Spring Session</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../session/2.6/index.html">2.6</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Spring Framework</a></li>
    <li><a href="../core.html">Core</a></li>
    <li><a href="appendix.html">Appendix</a></li>
  </ul>
</nav>
<div class="search">
  <input id="search-input" type="text" placeholder="Search docs">
</div>
  <div class="edit-this-page"><a href="https://github.com/rwinch/spring-framework/edit/antora-2.x/src/docs/antora/modules/ROOT/pages/core/appendix.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Appendix</h1>
<div class="sect1">
<h2 id="xsd-schemas"><a class="anchor" href="#xsd-schemas"></a>XML Schemas</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This part of the appendix lists XML schemas related to the core container.</p>
</div>
<div class="sect2">
<h3 id="xsd-schemas-util"><a class="anchor" href="#xsd-schemas-util"></a>The <code>util</code> Schema</h3>
<div class="paragraph">
<p>As the name implies, the <code>util</code> tags deal with common, utility configuration
issues, such as configuring collections, referencing constants, and so forth.
To use the tags in the <code>util</code> schema, you need to have the following preamble at the top
of your Spring XML configuration file (the text in the snippet references the
correct schema so that the tags in the <code>util</code> namespace are available to you):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:util="http://www.springframework.org/schema/util"
	xsi:schemaLocation="
		http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd"&gt;

		&lt;!-- bean definitions here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-util-constant"><a class="anchor" href="#xsd-schemas-util-constant"></a>Using <code>&lt;util:constant/&gt;</code></h4>
<div class="paragraph">
<p>Consider the following bean definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="..." class="..."&gt;
	&lt;property name="isolation"&gt;
		&lt;bean id="java.sql.Connection.TRANSACTION_SERIALIZABLE"
				class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" /&gt;
	&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding configuration uses a Spring <code>FactoryBean</code> implementation (the
<code>FieldRetrievingFactoryBean</code>) to set the value of the <code>isolation</code> property on a bean
to the value of the <code>java.sql.Connection.TRANSACTION_SERIALIZABLE</code> constant. This is
all well and good, but it is verbose and (unnecessarily) exposes Spring&#8217;s internal
plumbing to the end user.</p>
</div>
<div class="paragraph">
<p>The following XML Schema-based version is more concise, clearly expresses the
developer&#8217;s intent (&#8220;inject this constant value&#8221;), and it reads better:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="..." class="..."&gt;
	&lt;property name="isolation"&gt;
		&lt;util:constant static-field="java.sql.Connection.TRANSACTION_SERIALIZABLE"/&gt;
	&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-util-frfb"><a class="anchor" href="#xsd-schemas-util-frfb"></a>Setting a Bean Property or Constructor Argument from a Field Value</h5>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/beans/factory/config/FieldRetrievingFactoryBean.html"><code>FieldRetrievingFactoryBean</code></a>
is a <code>FactoryBean</code> that retrieves a <code>static</code> or non-static field value. It is typically
used for retrieving <code>public</code> <code>static</code> <code>final</code> constants, which may then be used to set a
property value or constructor argument for another bean.</p>
</div>
<div class="paragraph">
<p>The following example shows how a <code>static</code> field is exposed, by using the
<a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/beans/factory/config/FieldRetrievingFactoryBean.html#setStaticField(java.lang.String)"><code>staticField</code></a>
property:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="myField"
		class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean"&gt;
	&lt;property name="staticField" value="java.sql.Connection.TRANSACTION_SERIALIZABLE"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is also a convenience usage form where the <code>static</code> field is specified as the bean
name, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="java.sql.Connection.TRANSACTION_SERIALIZABLE"
		class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This does mean that there is no longer any choice in what the bean <code>id</code> is (so any other
bean that refers to it also has to use this longer name), but this form is very
concise to define and very convenient to use as an inner bean since the <code>id</code> does not have
to be specified for the bean reference, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="..." class="..."&gt;
	&lt;property name="isolation"&gt;
		&lt;bean id="java.sql.Connection.TRANSACTION_SERIALIZABLE"
				class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" /&gt;
	&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also access a non-static (instance) field of another bean, as
described in the API documentation for the
<a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/beans/factory/config/FieldRetrievingFactoryBean.html"><code>FieldRetrievingFactoryBean</code></a>
class.</p>
</div>
<div class="paragraph">
<p>Injecting enumeration values into beans as either property or constructor arguments is
easy to do in Spring. You do not actually have to do anything or know anything about
the Spring internals (or even about classes such as the <code>FieldRetrievingFactoryBean</code>).
The following example enumeration shows how easy injecting an enum value is:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package javax.persistence;

public enum PersistenceContextType {

	TRANSACTION,
	EXTENDED
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">package javax.persistence

enum class PersistenceContextType {

	TRANSACTION,
	EXTENDED
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now consider the following setter of type <code>PersistenceContextType</code> and the corresponding bean definition:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package example;

public class Client {

	private PersistenceContextType persistenceContextType;

	public void setPersistenceContextType(PersistenceContextType type) {
		this.persistenceContextType = type;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">package example

class Client {

	lateinit var persistenceContextType: PersistenceContextType
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean class="example.Client"&gt;
	&lt;property name="persistenceContextType" value="TRANSACTION"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-util-property-path"><a class="anchor" href="#xsd-schemas-util-property-path"></a>Using <code>&lt;util:property-path/&gt;</code></h4>
<div class="paragraph">
<p>Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!-- target bean to be referenced by name --&gt;
&lt;bean id="testBean" class="org.springframework.beans.TestBean" scope="prototype"&gt;
	&lt;property name="age" value="10"/&gt;
	&lt;property name="spouse"&gt;
		&lt;bean class="org.springframework.beans.TestBean"&gt;
			&lt;property name="age" value="11"/&gt;
		&lt;/bean&gt;
	&lt;/property&gt;
&lt;/bean&gt;

&lt;!-- results in 10, which is the value of property 'age' of bean 'testBean' --&gt;
&lt;bean id="testBean.age" class="org.springframework.beans.factory.config.PropertyPathFactoryBean"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding configuration uses a Spring <code>FactoryBean</code> implementation (the
<code>PropertyPathFactoryBean</code>) to create a bean (of type <code>int</code>) called <code>testBean.age</code> that
has a value equal to the <code>age</code> property of the <code>testBean</code> bean.</p>
</div>
<div class="paragraph">
<p>Now consider the following example, which adds a <code>&lt;util:property-path/&gt;</code> element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!-- target bean to be referenced by name --&gt;
&lt;bean id="testBean" class="org.springframework.beans.TestBean" scope="prototype"&gt;
	&lt;property name="age" value="10"/&gt;
	&lt;property name="spouse"&gt;
		&lt;bean class="org.springframework.beans.TestBean"&gt;
			&lt;property name="age" value="11"/&gt;
		&lt;/bean&gt;
	&lt;/property&gt;
&lt;/bean&gt;

&lt;!-- results in 10, which is the value of property 'age' of bean 'testBean' --&gt;
&lt;util:property-path id="name" path="testBean.age"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The value of the <code>path</code> attribute of the <code>&lt;property-path/&gt;</code> element follows the form of
<code>beanName.beanProperty</code>. In this case, it picks up the <code>age</code> property of the bean named
<code>testBean</code>. The value of that <code>age</code> property is <code>10</code>.</p>
</div>
<div class="sect4">
<h5 id="xsd-schemas-util-property-path-dependency"><a class="anchor" href="#xsd-schemas-util-property-path-dependency"></a>Using <code>&lt;util:property-path/&gt;</code> to Set a Bean Property or Constructor Argument</h5>
<div class="paragraph">
<p><code>PropertyPathFactoryBean</code> is a <code>FactoryBean</code> that evaluates a property path on a given
target object. The target object can be specified directly or by a bean name. You can then use this
value in another bean definition as a property value or constructor
argument.</p>
</div>
<div class="paragraph">
<p>The following example shows a path being used against another bean, by name:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!-- target bean to be referenced by name --&gt;
&lt;bean id="person" class="org.springframework.beans.TestBean" scope="prototype"&gt;
	&lt;property name="age" value="10"/&gt;
	&lt;property name="spouse"&gt;
		&lt;bean class="org.springframework.beans.TestBean"&gt;
			&lt;property name="age" value="11"/&gt;
		&lt;/bean&gt;
	&lt;/property&gt;
&lt;/bean&gt;

&lt;!-- results in 11, which is the value of property 'spouse.age' of bean 'person' --&gt;
&lt;bean id="theAge"
		class="org.springframework.beans.factory.config.PropertyPathFactoryBean"&gt;
	&lt;property name="targetBeanName" value="person"/&gt;
	&lt;property name="propertyPath" value="spouse.age"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the following example, a path is evaluated against an inner bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!-- results in 12, which is the value of property 'age' of the inner bean --&gt;
&lt;bean id="theAge"
		class="org.springframework.beans.factory.config.PropertyPathFactoryBean"&gt;
	&lt;property name="targetObject"&gt;
		&lt;bean class="org.springframework.beans.TestBean"&gt;
			&lt;property name="age" value="12"/&gt;
		&lt;/bean&gt;
	&lt;/property&gt;
	&lt;property name="propertyPath" value="age"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is also a shortcut form, where the bean name is the property path.
The following example shows the shortcut form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!-- results in 10, which is the value of property 'age' of bean 'person' --&gt;
&lt;bean id="person.age"
		class="org.springframework.beans.factory.config.PropertyPathFactoryBean"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This form does mean that there is no choice in the name of the bean. Any reference to it
also has to use the same <code>id</code>, which is the path. If used as an inner
bean, there is no need to refer to it at all, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="..." class="..."&gt;
	&lt;property name="age"&gt;
		&lt;bean id="person.age"
				class="org.springframework.beans.factory.config.PropertyPathFactoryBean"/&gt;
	&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can specifically set the result type in the actual definition. This is not necessary
for most use cases, but it can sometimes be useful. See the javadoc for more info on
this feature.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-util-properties"><a class="anchor" href="#xsd-schemas-util-properties"></a>Using <code>&lt;util:properties/&gt;</code></h4>
<div class="paragraph">
<p>Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!-- creates a java.util.Properties instance with values loaded from the supplied location --&gt;
&lt;bean id="jdbcConfiguration" class="org.springframework.beans.factory.config.PropertiesFactoryBean"&gt;
	&lt;property name="location" value="classpath:com/foo/jdbc-production.properties"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding configuration uses a Spring <code>FactoryBean</code> implementation (the
<code>PropertiesFactoryBean</code>) to instantiate a <code>java.util.Properties</code> instance with values
loaded from the supplied <a href="../core.html#resources" class="page"><code>Resource</code></a> location).</p>
</div>
<div class="paragraph">
<p>The following example uses a <code>util:properties</code> element to make a more concise representation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!-- creates a java.util.Properties instance with values loaded from the supplied location --&gt;
&lt;util:properties id="jdbcConfiguration" location="classpath:com/foo/jdbc-production.properties"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-util-list"><a class="anchor" href="#xsd-schemas-util-list"></a>Using <code>&lt;util:list/&gt;</code></h4>
<div class="paragraph">
<p>Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!-- creates a java.util.List instance with values loaded from the supplied 'sourceList' --&gt;
&lt;bean id="emails" class="org.springframework.beans.factory.config.ListFactoryBean"&gt;
	&lt;property name="sourceList"&gt;
		&lt;list&gt;
			&lt;value&gt;pechorin@hero.org&lt;/value&gt;
			&lt;value&gt;raskolnikov@slums.org&lt;/value&gt;
			&lt;value&gt;stavrogin@gov.org&lt;/value&gt;
			&lt;value&gt;porfiry@gov.org&lt;/value&gt;
		&lt;/list&gt;
	&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding configuration uses a Spring <code>FactoryBean</code> implementation (the
<code>ListFactoryBean</code>) to create a <code>java.util.List</code> instance and initialize it with values taken
from the supplied <code>sourceList</code>.</p>
</div>
<div class="paragraph">
<p>The following example uses a <code>&lt;util:list/&gt;</code> element to make a more concise representation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!-- creates a java.util.List instance with the supplied values --&gt;
&lt;util:list id="emails"&gt;
	&lt;value&gt;pechorin@hero.org&lt;/value&gt;
	&lt;value&gt;raskolnikov@slums.org&lt;/value&gt;
	&lt;value&gt;stavrogin@gov.org&lt;/value&gt;
	&lt;value&gt;porfiry@gov.org&lt;/value&gt;
&lt;/util:list&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also explicitly control the exact type of <code>List</code> that is instantiated and
populated by using the <code>list-class</code> attribute on the <code>&lt;util:list/&gt;</code> element. For
example, if we really need a <code>java.util.LinkedList</code> to be instantiated, we could use the
following configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;util:list id="emails" list-class="java.util.LinkedList"&gt;
	&lt;value&gt;jackshaftoe@vagabond.org&lt;/value&gt;
	&lt;value&gt;eliza@thinkingmanscrumpet.org&lt;/value&gt;
	&lt;value&gt;vanhoek@pirate.org&lt;/value&gt;
	&lt;value&gt;d'Arcachon@nemesis.org&lt;/value&gt;
&lt;/util:list&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If no <code>list-class</code> attribute is supplied, the container chooses a <code>List</code> implementation.</p>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-util-map"><a class="anchor" href="#xsd-schemas-util-map"></a>Using <code>&lt;util:map/&gt;</code></h4>
<div class="paragraph">
<p>Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!-- creates a java.util.Map instance with values loaded from the supplied 'sourceMap' --&gt;
&lt;bean id="emails" class="org.springframework.beans.factory.config.MapFactoryBean"&gt;
	&lt;property name="sourceMap"&gt;
		&lt;map&gt;
			&lt;entry key="pechorin" value="pechorin@hero.org"/&gt;
			&lt;entry key="raskolnikov" value="raskolnikov@slums.org"/&gt;
			&lt;entry key="stavrogin" value="stavrogin@gov.org"/&gt;
			&lt;entry key="porfiry" value="porfiry@gov.org"/&gt;
		&lt;/map&gt;
	&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding configuration uses a Spring <code>FactoryBean</code> implementation (the
<code>MapFactoryBean</code>) to create a <code>java.util.Map</code> instance initialized with key-value pairs
taken from the supplied <code>'sourceMap'</code>.</p>
</div>
<div class="paragraph">
<p>The following example uses a <code>&lt;util:map/&gt;</code> element to make a more concise representation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!-- creates a java.util.Map instance with the supplied key-value pairs --&gt;
&lt;util:map id="emails"&gt;
	&lt;entry key="pechorin" value="pechorin@hero.org"/&gt;
	&lt;entry key="raskolnikov" value="raskolnikov@slums.org"/&gt;
	&lt;entry key="stavrogin" value="stavrogin@gov.org"/&gt;
	&lt;entry key="porfiry" value="porfiry@gov.org"/&gt;
&lt;/util:map&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also explicitly control the exact type of <code>Map</code> that is instantiated and
populated by using the <code>'map-class'</code> attribute on the <code>&lt;util:map/&gt;</code> element. For
example, if we really need a <code>java.util.TreeMap</code> to be instantiated, we could use the
following configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;util:map id="emails" map-class="java.util.TreeMap"&gt;
	&lt;entry key="pechorin" value="pechorin@hero.org"/&gt;
	&lt;entry key="raskolnikov" value="raskolnikov@slums.org"/&gt;
	&lt;entry key="stavrogin" value="stavrogin@gov.org"/&gt;
	&lt;entry key="porfiry" value="porfiry@gov.org"/&gt;
&lt;/util:map&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If no <code>'map-class'</code> attribute is supplied, the container chooses a <code>Map</code> implementation.</p>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-util-set"><a class="anchor" href="#xsd-schemas-util-set"></a>Using <code>&lt;util:set/&gt;</code></h4>
<div class="paragraph">
<p>Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!-- creates a java.util.Set instance with values loaded from the supplied 'sourceSet' --&gt;
&lt;bean id="emails" class="org.springframework.beans.factory.config.SetFactoryBean"&gt;
	&lt;property name="sourceSet"&gt;
		&lt;set&gt;
			&lt;value&gt;pechorin@hero.org&lt;/value&gt;
			&lt;value&gt;raskolnikov@slums.org&lt;/value&gt;
			&lt;value&gt;stavrogin@gov.org&lt;/value&gt;
			&lt;value&gt;porfiry@gov.org&lt;/value&gt;
		&lt;/set&gt;
	&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding configuration uses a Spring <code>FactoryBean</code> implementation (the
<code>SetFactoryBean</code>) to create a <code>java.util.Set</code> instance initialized with values taken
from the supplied <code>sourceSet</code>.</p>
</div>
<div class="paragraph">
<p>The following example uses a <code>&lt;util:set/&gt;</code> element to make a more concise representation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!-- creates a java.util.Set instance with the supplied values --&gt;
&lt;util:set id="emails"&gt;
	&lt;value&gt;pechorin@hero.org&lt;/value&gt;
	&lt;value&gt;raskolnikov@slums.org&lt;/value&gt;
	&lt;value&gt;stavrogin@gov.org&lt;/value&gt;
	&lt;value&gt;porfiry@gov.org&lt;/value&gt;
&lt;/util:set&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also explicitly control the exact type of <code>Set</code> that is instantiated and
populated by using the <code>set-class</code> attribute on the <code>&lt;util:set/&gt;</code> element. For
example, if we really need a <code>java.util.TreeSet</code> to be instantiated, we could use the
following configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;util:set id="emails" set-class="java.util.TreeSet"&gt;
	&lt;value&gt;pechorin@hero.org&lt;/value&gt;
	&lt;value&gt;raskolnikov@slums.org&lt;/value&gt;
	&lt;value&gt;stavrogin@gov.org&lt;/value&gt;
	&lt;value&gt;porfiry@gov.org&lt;/value&gt;
&lt;/util:set&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If no <code>set-class</code> attribute is supplied, the container chooses a <code>Set</code> implementation.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="xsd-schemas-aop"><a class="anchor" href="#xsd-schemas-aop"></a>The <code>aop</code> Schema</h3>
<div class="paragraph">
<p>The <code>aop</code> tags deal with configuring all things AOP in Spring, including Spring&#8217;s
own proxy-based AOP framework and Spring&#8217;s integration with the AspectJ AOP framework.
These tags are comprehensively covered in the chapter entitled <a href="../core.html#aop" class="page">Aspect Oriented Programming with Spring</a>.</p>
</div>
<div class="paragraph">
<p>In the interest of completeness, to use the tags in the <code>aop</code> schema, you need to have
the following preamble at the top of your Spring XML configuration file (the text in the
snippet references the correct schema so that the tags in the <code>aop</code> namespace
are available to you):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xsi:schemaLocation="
		http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd"&gt;

	&lt;!-- bean definitions here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="xsd-schemas-context"><a class="anchor" href="#xsd-schemas-context"></a>The <code>context</code> Schema</h3>
<div class="paragraph">
<p>The <code>context</code> tags deal with <code>ApplicationContext</code> configuration that relates to plumbing&#8201;&#8212;&#8201;that is, not usually beans that are important to an end-user but rather beans that do
a lot of the &#8220;grunt&#8221; work in Spring, such as <code>BeanfactoryPostProcessors</code>. The following
snippet references the correct schema so that the elements in the <code>context</code> namespace are
available to you:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="
		http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"&gt;

	&lt;!-- bean definitions here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-context-pphc"><a class="anchor" href="#xsd-schemas-context-pphc"></a>Using <code>&lt;property-placeholder/&gt;</code></h4>
<div class="paragraph">
<p>This element activates the replacement of <code>${&#8230;&#8203;}</code> placeholders, which are resolved against a
specified properties file (as a <a href="../core.html#resources" class="page">Spring resource location</a>). This element
is a convenience mechanism that sets up a <a href="../core.html#beans-factory-placeholderconfigurer" class="page"><code>PropertySourcesPlaceholderConfigurer</code></a> for you. If you need more control over the specific
<code>PropertySourcesPlaceholderConfigurer</code> setup, you can explicitly define it as a bean yourself.</p>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-context-ac"><a class="anchor" href="#xsd-schemas-context-ac"></a>Using <code>&lt;annotation-config/&gt;</code></h4>
<div class="paragraph">
<p>This element activates the Spring infrastructure to detect annotations in bean classes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Spring&#8217;s <a href="../core.html#beans-factory-metadata" class="page"><code>@Configuration</code></a> model</p>
</li>
<li>
<p><a href="../core.html#beans-annotation-config" class="page"><code>@Autowired</code>/<code>@Inject</code></a>, <code>@Value</code>, and <code>@Lookup</code></p>
</li>
<li>
<p>JSR-250&#8217;s <code>@Resource</code>, <code>@PostConstruct</code>, and <code>@PreDestroy</code> (if available)</p>
</li>
<li>
<p>JAX-WS&#8217;s <code>@WebServiceRef</code> and EJB 3&#8217;s <code>@EJB</code> (if available)</p>
</li>
<li>
<p>JPA&#8217;s <code>@PersistenceContext</code> and <code>@PersistenceUnit</code> (if available)</p>
</li>
<li>
<p>Spring&#8217;s <a href="../core.html#context-functionality-events-annotation" class="page"><code>@EventListener</code></a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Alternatively, you can choose to explicitly activate the individual <code>BeanPostProcessors</code>
for those annotations.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This element does not activate processing of Spring&#8217;s
<a href="../data-access.html#transaction-declarative-annotations" class="page"><code>@Transactional</code></a> annotation;
you can use the <a href="../data-access.html#tx-decl-explained" class="page"><code>&lt;tx:annotation-driven/&gt;</code></a>
element for that purpose. Similarly, Spring&#8217;s
<a href="../integration.html#cache-annotations" class="page">caching annotations</a> need to be explicitly
<a href="../integration.html#cache-annotation-enable" class="page">enabled</a> as well.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-context-component-scan"><a class="anchor" href="#xsd-schemas-context-component-scan"></a>Using <code>&lt;component-scan/&gt;</code></h4>
<div class="paragraph">
<p>This element is detailed in the section on <a href="../core.html#beans-annotation-config" class="page">annotation-based container configuration</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-context-ltw"><a class="anchor" href="#xsd-schemas-context-ltw"></a>Using <code>&lt;load-time-weaver/&gt;</code></h4>
<div class="paragraph">
<p>This element is detailed in the section on <a href="../core.html#aop-aj-ltw" class="page">load-time weaving with AspectJ in the Spring Framework</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-context-sc"><a class="anchor" href="#xsd-schemas-context-sc"></a>Using <code>&lt;spring-configured/&gt;</code></h4>
<div class="paragraph">
<p>This element is detailed in the section on <a href="../core.html#aop-atconfigurable" class="page">using AspectJ to dependency inject domain objects with Spring</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-context-mbe"><a class="anchor" href="#xsd-schemas-context-mbe"></a>Using <code>&lt;mbean-export/&gt;</code></h4>
<div class="paragraph">
<p>This element is detailed in the section on <a href="../integration.html#jmx-context-mbeanexport" class="page">configuring annotation-based MBean export</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="xsd-schemas-beans"><a class="anchor" href="#xsd-schemas-beans"></a>The Beans Schema</h3>
<div class="paragraph">
<p>Last but not least, we have the elements in the <code>beans</code> schema. These elements
have been in Spring since the very dawn of the framework. Examples of the various elements
in the <code>beans</code> schema are not shown here because they are quite comprehensively covered
in <a href="../core.html#beans-factory-properties-detailed" class="page">dependencies and configuration in detail</a>
(and, indeed, in that entire <a href="../core.html#beans" class="page">chapter</a>).</p>
</div>
<div class="paragraph">
<p>Note that you can add zero or more key-value pairs to <code>&lt;bean/&gt;</code> XML definitions.
What, if anything, is done with this extra metadata is totally up to your own custom
logic (and so is typically only of use if you write your own custom elements as described
in the appendix entitled <a href="#xml-custom">XML Schema Authoring</a>).</p>
</div>
<div class="paragraph">
<p>The following example shows the <code>&lt;meta/&gt;</code> element in the context of a surrounding <code>&lt;bean/&gt;</code>
(note that, without any logic to interpret it, the metadata is effectively useless
as it stands).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="
		http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

	&lt;bean id="foo" class="x.y.Foo"&gt;
		&lt;meta key="cacheName" value="foo"/&gt; <i class="conum" data-value="1"></i><b>(1)</b>
		&lt;property name="name" value="Rick"/&gt;
	&lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This is the example <code>meta</code> element</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the case of the preceding example, you could assume that there is some logic that consumes
the bean definition and sets up some caching infrastructure that uses the supplied metadata.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="xml-custom"><a class="anchor" href="#xml-custom"></a>XML Schema Authoring</h2>
<div class="sectionbody">
<div id="xsd-custom-introduction" class="paragraph">
<p>Since version 2.0, Spring has featured a mechanism for adding schema-based extensions to the
basic Spring XML format for defining and configuring beans. This section covers
how to write your own custom XML bean definition parsers and
integrate such parsers into the Spring IoC container.</p>
</div>
<div class="paragraph">
<p>To facilitate authoring configuration files that use a schema-aware XML editor,
Spring&#8217;s extensible XML configuration mechanism is based on XML Schema. If you are not
familiar with Spring&#8217;s current XML configuration extensions that come with the standard
Spring distribution, you should first read the previous section on <a href="#xsd-schemas">XML Schemas</a>.</p>
</div>
<div class="paragraph">
<p>To create new XML configuration extensions:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="#xsd-custom-schema">Author</a> an XML schema to describe your custom element(s).</p>
</li>
<li>
<p><a href="#xsd-custom-namespacehandler">Code</a> a custom <code>NamespaceHandler</code> implementation.</p>
</li>
<li>
<p><a href="#xsd-custom-parser">Code</a> one or more <code>BeanDefinitionParser</code> implementations
(this is where the real work is done).</p>
</li>
<li>
<p><a href="#xsd-custom-registration">Register</a> your new artifacts with Spring.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>For a unified example, we create an
XML extension (a custom XML element) that lets us configure objects of the type
<code>SimpleDateFormat</code> (from the <code>java.text</code> package). When we are done,
we will be able to define bean definitions of type <code>SimpleDateFormat</code> as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;myns:dateformat id="dateFormat"
	pattern="yyyy-MM-dd HH:mm"
	lenient="true"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>(We include much more detailed
examples follow later in this appendix. The intent of this first simple example is to walk you
through the basic steps of making a custom extension.)</p>
</div>
<div class="sect2">
<h3 id="xsd-custom-schema"><a class="anchor" href="#xsd-custom-schema"></a>Authoring the Schema</h3>
<div class="paragraph">
<p>Creating an XML configuration extension for use with Spring&#8217;s IoC container starts with
authoring an XML Schema to describe the extension. For our example, we use the following schema
to configure <code>SimpleDateFormat</code> objects:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!-- myns.xsd (inside package org/springframework/samples/xml) --&gt;

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsd:schema xmlns="http://www.mycompany.example/schema/myns"
		xmlns:xsd="http://www.w3.org/2001/XMLSchema"
		xmlns:beans="http://www.springframework.org/schema/beans"
		targetNamespace="http://www.mycompany.example/schema/myns"
		elementFormDefault="qualified"
		attributeFormDefault="unqualified"&gt;

	&lt;xsd:import namespace="http://www.springframework.org/schema/beans"/&gt;

	&lt;xsd:element name="dateformat"&gt;
		&lt;xsd:complexType&gt;
			&lt;xsd:complexContent&gt;
				&lt;xsd:extension base="beans:identifiedType"&gt; <i class="conum" data-value="1"></i><b>(1)</b>
					&lt;xsd:attribute name="lenient" type="xsd:boolean"/&gt;
					&lt;xsd:attribute name="pattern" type="xsd:string" use="required"/&gt;
				&lt;/xsd:extension&gt;
			&lt;/xsd:complexContent&gt;
		&lt;/xsd:complexType&gt;
	&lt;/xsd:element&gt;
&lt;/xsd:schema&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The indicated line contains an extension base for all identifiable tags
(meaning they have an <code>id</code> attribute that we can use as the bean identifier in the
container). We can use this attribute because we imported the Spring-provided
<code>beans</code> namespace.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The preceding schema lets us configure <code>SimpleDateFormat</code> objects directly in an
XML application context file by using the <code>&lt;myns:dateformat/&gt;</code> element, as the following
example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;myns:dateformat id="dateFormat"
	pattern="yyyy-MM-dd HH:mm"
	lenient="true"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that, after we have created the infrastructure classes, the preceding snippet of XML is
essentially the same as the following XML snippet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="dateFormat" class="java.text.SimpleDateFormat"&gt;
	&lt;constructor-arg value="yyyy-HH-dd HH:mm"/&gt;
	&lt;property name="lenient" value="true"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second of the two preceding snippets
creates a bean in the container (identified by the name <code>dateFormat</code> of type
<code>SimpleDateFormat</code>) with a couple of properties set.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The schema-based approach to creating configuration format allows for tight integration
with an IDE that has a schema-aware XML editor. By using a properly authored schema, you
can use autocompletion to let a user choose between several configuration options
defined in the enumeration.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="xsd-custom-namespacehandler"><a class="anchor" href="#xsd-custom-namespacehandler"></a>Coding a <code>NamespaceHandler</code></h3>
<div class="paragraph">
<p>In addition to the schema, we need a <code>NamespaceHandler</code> to parse all elements of
this specific namespace that Spring encounters while parsing configuration files. For this example, the
<code>NamespaceHandler</code> should take care of the parsing of the <code>myns:dateformat</code>
element.</p>
</div>
<div class="paragraph">
<p>The <code>NamespaceHandler</code> interface features three methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>init()</code>: Allows for initialization of the <code>NamespaceHandler</code> and is called by
Spring before the handler is used.</p>
</li>
<li>
<p><code>BeanDefinition parse(Element, ParserContext)</code>: Called when Spring encounters a
top-level element (not nested inside a bean definition or a different namespace).
This method can itself register bean definitions, return a bean definition, or both.</p>
</li>
<li>
<p><code>BeanDefinitionHolder decorate(Node, BeanDefinitionHolder, ParserContext)</code>: Called
when Spring encounters an attribute or nested element of a different namespace.
The decoration of one or more bean definitions is used (for example) with the
<a href="../core.html#beans-factory-scopes" class="page">scopes that Spring supports</a>.
We start by highlighting a simple example, without using decoration, after which
we show decoration in a somewhat more advanced example.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Although you can code your own <code>NamespaceHandler</code> for the entire
namespace (and hence provide code that parses each and every element in the namespace),
it is often the case that each top-level XML element in a Spring XML configuration file
results in a single bean definition (as in our case, where a single <code>&lt;myns:dateformat/&gt;</code>
element results in a single <code>SimpleDateFormat</code> bean definition). Spring features a
number of convenience classes that support this scenario. In the following example, we
use the <code>NamespaceHandlerSupport</code> class:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.springframework.samples.xml;

import org.springframework.beans.factory.xml.NamespaceHandlerSupport;

public class MyNamespaceHandler extends NamespaceHandlerSupport {

	public void init() {
		registerBeanDefinitionParser("dateformat", new SimpleDateFormatBeanDefinitionParser());
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">package org.springframework.samples.xml

import org.springframework.beans.factory.xml.NamespaceHandlerSupport

class MyNamespaceHandler : NamespaceHandlerSupport {

	override fun init() {
		registerBeanDefinitionParser("dateformat", SimpleDateFormatBeanDefinitionParser())
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You may notice that there is not actually a whole lot of parsing logic
in this class. Indeed, the <code>NamespaceHandlerSupport</code> class has a built-in notion of
delegation. It supports the registration of any number of <code>BeanDefinitionParser</code>
instances, to which it delegates to when it needs to parse an element in its
namespace. This clean separation of concerns lets a <code>NamespaceHandler</code> handle the
orchestration of the parsing of all of the custom elements in its namespace while
delegating to <code>BeanDefinitionParsers</code> to do the grunt work of the XML parsing. This
means that each <code>BeanDefinitionParser</code> contains only the logic for parsing a single
custom element, as we can see in the next step.</p>
</div>
</div>
<div class="sect2">
<h3 id="xsd-custom-parser"><a class="anchor" href="#xsd-custom-parser"></a>Using <code>BeanDefinitionParser</code></h3>
<div class="paragraph">
<p>A <code>BeanDefinitionParser</code> is used if the <code>NamespaceHandler</code> encounters an XML
element of the type that has been mapped to the specific bean definition parser
(<code>dateformat</code> in this case). In other words, the <code>BeanDefinitionParser</code> is
responsible for parsing one distinct top-level XML element defined in the schema. In
the parser, we' have access to the XML element (and thus to its subelements, too) so that
we can parse our custom XML content, as you can see in the following example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.springframework.samples.xml;

import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser;
import org.springframework.util.StringUtils;
import org.w3c.dom.Element;

import java.text.SimpleDateFormat;

public class SimpleDateFormatBeanDefinitionParser extends AbstractSingleBeanDefinitionParser { <i class="conum" data-value="1"></i><b>(1)</b>

	protected Class getBeanClass(Element element) {
		return SimpleDateFormat.class; <i class="conum" data-value="2"></i><b>(2)</b>
	}

	protected void doParse(Element element, BeanDefinitionBuilder bean) {
		// this will never be null since the schema explicitly requires that a value be supplied
		String pattern = element.getAttribute("pattern");
		bean.addConstructorArgValue(pattern);

		// this however is an optional property
		String lenient = element.getAttribute("lenient");
		if (StringUtils.hasText(lenient)) {
			bean.addPropertyValue("lenient", Boolean.valueOf(lenient));
		}
	}

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We use the Spring-provided <code>AbstractSingleBeanDefinitionParser</code> to handle a lot of
the basic grunt work of creating a single <code>BeanDefinition</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We supply the <code>AbstractSingleBeanDefinitionParser</code> superclass with the type that our
single <code>BeanDefinition</code> represents.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">package org.springframework.samples.xml

import org.springframework.beans.factory.support.BeanDefinitionBuilder
import org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser
import org.springframework.util.StringUtils
import org.w3c.dom.Element

import java.text.SimpleDateFormat

class SimpleDateFormatBeanDefinitionParser : AbstractSingleBeanDefinitionParser() { <i class="conum" data-value="1"></i><b>(1)</b>

	override fun getBeanClass(element: Element): Class&lt;*&gt;? { <i class="conum" data-value="2"></i><b>(2)</b>
		return SimpleDateFormat::class.java
	}

	override fun doParse(element: Element, bean: BeanDefinitionBuilder) {
		// this will never be null since the schema explicitly requires that a value be supplied
		val pattern = element.getAttribute("pattern")
		bean.addConstructorArgValue(pattern)

		// this however is an optional property
		val lenient = element.getAttribute("lenient")
		if (StringUtils.hasText(lenient)) {
			bean.addPropertyValue("lenient", java.lang.Boolean.valueOf(lenient))
		}
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We use the Spring-provided <code>AbstractSingleBeanDefinitionParser</code> to handle a lot of
the basic grunt work of creating a single <code>BeanDefinition</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We supply the <code>AbstractSingleBeanDefinitionParser</code> superclass with the type that our
single <code>BeanDefinition</code> represents.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In this simple case, this is all that we need to do. The creation of our single
<code>BeanDefinition</code> is handled by the <code>AbstractSingleBeanDefinitionParser</code> superclass, as
is the extraction and setting of the bean definition&#8217;s unique identifier.</p>
</div>
</div>
<div class="sect2">
<h3 id="xsd-custom-registration"><a class="anchor" href="#xsd-custom-registration"></a>Registering the Handler and the Schema</h3>
<div class="paragraph">
<p>The coding is finished. All that remains to be done is to make the Spring XML
parsing infrastructure aware of our custom element. We do so by registering our custom
<code>namespaceHandler</code> and custom XSD file in two special-purpose properties files. These
properties files are both placed in a <code>META-INF</code> directory in your application and
can, for example, be distributed alongside your binary classes in a JAR file. The Spring
XML parsing infrastructure automatically picks up your new extension by consuming
these special properties files, the formats of which are detailed in the next two sections.</p>
</div>
<div class="sect3">
<h4 id="xsd-custom-registration-spring-handlers"><a class="anchor" href="#xsd-custom-registration-spring-handlers"></a>Writing <code>META-INF/spring.handlers</code></h4>
<div class="paragraph">
<p>The properties file called <code>spring.handlers</code> contains a mapping of XML Schema URIs to
namespace handler classes. For our example, we need to write the following:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>http\://www.mycompany.example/schema/myns=org.springframework.samples.xml.MyNamespaceHandler</pre>
</div>
</div>
<div class="paragraph">
<p>(The <code>:</code> character is a valid delimiter in the Java properties format, so
<code>:</code> character in the URI needs to be escaped with a backslash.)</p>
</div>
<div class="paragraph">
<p>The first part (the key) of the key-value pair is the URI associated with your custom
namespace extension and needs to exactly match exactly the value of the <code>targetNamespace</code>
attribute, as specified in your custom XSD schema.</p>
</div>
</div>
<div class="sect3">
<h4 id="xsd-custom-registration-spring-schemas"><a class="anchor" href="#xsd-custom-registration-spring-schemas"></a>Writing 'META-INF/spring.schemas'</h4>
<div class="paragraph">
<p>The properties file called <code>spring.schemas</code> contains a mapping of XML Schema locations
(referred to, along with the schema declaration, in XML files that use the schema as part
of the <code>xsi:schemaLocation</code> attribute) to classpath resources. This file is needed
to prevent Spring from absolutely having to use a default <code>EntityResolver</code> that requires
Internet access to retrieve the schema file. If you specify the mapping in this
properties file, Spring searches for the schema (in this case,
<code>myns.xsd</code> in the <code>org.springframework.samples.xml</code> package) on the classpath.
The following snippet shows the line we need to add for our custom schema:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>http\://www.mycompany.example/schema/myns/myns.xsd=org/springframework/samples/xml/myns.xsd</pre>
</div>
</div>
<div class="paragraph">
<p>(Remember that the <code>:</code> character must be escaped.)</p>
</div>
<div class="paragraph">
<p>You are encouraged to deploy your XSD file (or files) right alongside
the <code>NamespaceHandler</code> and <code>BeanDefinitionParser</code> classes on the classpath.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="xsd-custom-using"><a class="anchor" href="#xsd-custom-using"></a>Using a Custom Extension in Your Spring XML Configuration</h3>
<div class="paragraph">
<p>Using a custom extension that you yourself have implemented is no different from using
one of the &#8220;custom&#8221; extensions that Spring provides. The following
example uses the custom <code>&lt;dateformat/&gt;</code> element developed in the previous steps
in a Spring XML configuration file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:myns="http://www.mycompany.example/schema/myns"
	xsi:schemaLocation="
		http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.mycompany.example/schema/myns http://www.mycompany.com/schema/myns/myns.xsd"&gt;

	&lt;!-- as a top-level bean --&gt;
	&lt;myns:dateformat id="defaultDateFormat" pattern="yyyy-MM-dd HH:mm" lenient="true"/&gt; <i class="conum" data-value="1"></i><b>(1)</b>

	&lt;bean id="jobDetailTemplate" abstract="true"&gt;
		&lt;property name="dateFormat"&gt;
			&lt;!-- as an inner bean --&gt;
			&lt;myns:dateformat pattern="HH:mm MM-dd-yyyy"/&gt;
		&lt;/property&gt;
	&lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Our custom bean.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="xsd-custom-meat"><a class="anchor" href="#xsd-custom-meat"></a>More Detailed Examples</h3>
<div class="paragraph">
<p>This section presents some more detailed examples of custom XML extensions.</p>
</div>
<div class="sect3">
<h4 id="xsd-custom-custom-nested"><a class="anchor" href="#xsd-custom-custom-nested"></a>Nesting Custom Elements within Custom Elements</h4>
<div class="paragraph">
<p>The example presented in this section shows how you to write the various artifacts required
to satisfy a target of the following configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:foo="http://www.foo.example/schema/component"
	xsi:schemaLocation="
		http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.foo.example/schema/component http://www.foo.example/schema/component/component.xsd"&gt;

	&lt;foo:component id="bionic-family" name="Bionic-1"&gt;
		&lt;foo:component name="Mother-1"&gt;
			&lt;foo:component name="Karate-1"/&gt;
			&lt;foo:component name="Sport-1"/&gt;
		&lt;/foo:component&gt;
		&lt;foo:component name="Rock-1"/&gt;
	&lt;/foo:component&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding configuration nests custom extensions within each other. The class
that is actually configured by the <code>&lt;foo:component/&gt;</code> element is the <code>Component</code>
class (shown in the next example). Notice how the <code>Component</code> class does not expose a
setter method for the <code>components</code> property. This makes it hard (or rather impossible)
to configure a bean definition for the <code>Component</code> class by using setter injection.
The following listing shows the <code>Component</code> class:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.foo;

import java.util.ArrayList;
import java.util.List;

public class Component {

	private String name;
	private List&lt;Component&gt; components = new ArrayList&lt;Component&gt; ();

	// mmm, there is no setter method for the 'components'
	public void addComponent(Component component) {
		this.components.add(component);
	}

	public List&lt;Component&gt; getComponents() {
		return components;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">package com.foo

import java.util.ArrayList

class Component {

	var name: String? = null
	private val components = ArrayList&lt;Component&gt;()

	// mmm, there is no setter method for the 'components'
	fun addComponent(component: Component) {
		this.components.add(component)
	}

	fun getComponents(): List&lt;Component&gt; {
		return components
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The typical solution to this issue is to create a custom <code>FactoryBean</code> that exposes a
setter property for the <code>components</code> property. The following listing shows such a custom
<code>FactoryBean</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.foo;

import org.springframework.beans.factory.FactoryBean;

import java.util.List;

public class ComponentFactoryBean implements FactoryBean&lt;Component&gt; {

	private Component parent;
	private List&lt;Component&gt; children;

	public void setParent(Component parent) {
		this.parent = parent;
	}

	public void setChildren(List&lt;Component&gt; children) {
		this.children = children;
	}

	public Component getObject() throws Exception {
		if (this.children != null &amp;&amp; this.children.size() &gt; 0) {
			for (Component child : children) {
				this.parent.addComponent(child);
			}
		}
		return this.parent;
	}

	public Class&lt;Component&gt; getObjectType() {
		return Component.class;
	}

	public boolean isSingleton() {
		return true;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">package com.foo

import org.springframework.beans.factory.FactoryBean
import org.springframework.stereotype.Component

class ComponentFactoryBean : FactoryBean&lt;Component&gt; {

	private var parent: Component? = null
	private var children: List&lt;Component&gt;? = null

	fun setParent(parent: Component) {
		this.parent = parent
	}

	fun setChildren(children: List&lt;Component&gt;) {
		this.children = children
	}

	override fun getObject(): Component? {
		if (this.children != null &amp;&amp; this.children!!.isNotEmpty()) {
			for (child in children!!) {
				this.parent!!.addComponent(child)
			}
		}
		return this.parent
	}

	override fun getObjectType(): Class&lt;Component&gt;? {
		return Component::class.java
	}

	override fun isSingleton(): Boolean {
		return true
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This works nicely, but it exposes a lot of Spring plumbing to the end user. What we are
going to do is write a custom extension that hides away all of this Spring plumbing.
If we stick to <a href="#xsd-custom-introduction">the steps described previously</a>, we start off
by creating the XSD schema to define the structure of our custom tag, as the following
listing shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;

&lt;xsd:schema xmlns="http://www.foo.example/schema/component"
		xmlns:xsd="http://www.w3.org/2001/XMLSchema"
		targetNamespace="http://www.foo.example/schema/component"
		elementFormDefault="qualified"
		attributeFormDefault="unqualified"&gt;

	&lt;xsd:element name="component"&gt;
		&lt;xsd:complexType&gt;
			&lt;xsd:choice minOccurs="0" maxOccurs="unbounded"&gt;
				&lt;xsd:element ref="component"/&gt;
			&lt;/xsd:choice&gt;
			&lt;xsd:attribute name="id" type="xsd:ID"/&gt;
			&lt;xsd:attribute name="name" use="required" type="xsd:string"/&gt;
		&lt;/xsd:complexType&gt;
	&lt;/xsd:element&gt;

&lt;/xsd:schema&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Again following <a href="#xsd-custom-introduction">the process described earlier</a>,
we then create a custom <code>NamespaceHandler</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.foo;

import org.springframework.beans.factory.xml.NamespaceHandlerSupport;

public class ComponentNamespaceHandler extends NamespaceHandlerSupport {

	public void init() {
		registerBeanDefinitionParser("component", new ComponentBeanDefinitionParser());
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">package com.foo

import org.springframework.beans.factory.xml.NamespaceHandlerSupport

class ComponentNamespaceHandler : NamespaceHandlerSupport() {

	override fun init() {
		registerBeanDefinitionParser("component", ComponentBeanDefinitionParser())
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next up is the custom <code>BeanDefinitionParser</code>. Remember that we are creating
a <code>BeanDefinition</code> that describes a <code>ComponentFactoryBean</code>. The following
listing shows our custom <code>BeanDefinitionParser</code> implementation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.foo;

import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.ManagedList;
import org.springframework.beans.factory.xml.AbstractBeanDefinitionParser;
import org.springframework.beans.factory.xml.ParserContext;
import org.springframework.util.xml.DomUtils;
import org.w3c.dom.Element;

import java.util.List;

public class ComponentBeanDefinitionParser extends AbstractBeanDefinitionParser {

	protected AbstractBeanDefinition parseInternal(Element element, ParserContext parserContext) {
		return parseComponentElement(element);
	}

	private static AbstractBeanDefinition parseComponentElement(Element element) {
		BeanDefinitionBuilder factory = BeanDefinitionBuilder.rootBeanDefinition(ComponentFactoryBean.class);
		factory.addPropertyValue("parent", parseComponent(element));

		List&lt;Element&gt; childElements = DomUtils.getChildElementsByTagName(element, "component");
		if (childElements != null &amp;&amp; childElements.size() &gt; 0) {
			parseChildComponents(childElements, factory);
		}

		return factory.getBeanDefinition();
	}

	private static BeanDefinition parseComponent(Element element) {
		BeanDefinitionBuilder component = BeanDefinitionBuilder.rootBeanDefinition(Component.class);
		component.addPropertyValue("name", element.getAttribute("name"));
		return component.getBeanDefinition();
	}

	private static void parseChildComponents(List&lt;Element&gt; childElements, BeanDefinitionBuilder factory) {
		ManagedList&lt;BeanDefinition&gt; children = new ManagedList&lt;BeanDefinition&gt;(childElements.size());
		for (Element element : childElements) {
			children.add(parseComponentElement(element));
		}
		factory.addPropertyValue("children", children);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">package com.foo

import org.springframework.beans.factory.config.BeanDefinition
import org.springframework.beans.factory.support.AbstractBeanDefinition
import org.springframework.beans.factory.support.BeanDefinitionBuilder
import org.springframework.beans.factory.support.ManagedList
import org.springframework.beans.factory.xml.AbstractBeanDefinitionParser
import org.springframework.beans.factory.xml.ParserContext
import org.springframework.util.xml.DomUtils
import org.w3c.dom.Element

import java.util.List

class ComponentBeanDefinitionParser : AbstractBeanDefinitionParser() {

	override fun parseInternal(element: Element, parserContext: ParserContext): AbstractBeanDefinition? {
		return parseComponentElement(element)
	}

	private fun parseComponentElement(element: Element): AbstractBeanDefinition {
		val factory = BeanDefinitionBuilder.rootBeanDefinition(ComponentFactoryBean::class.java)
		factory.addPropertyValue("parent", parseComponent(element))

		val childElements = DomUtils.getChildElementsByTagName(element, "component")
		if (childElements != null &amp;&amp; childElements.size &gt; 0) {
			parseChildComponents(childElements, factory)
		}

		return factory.getBeanDefinition()
	}

	private fun parseComponent(element: Element): BeanDefinition {
		val component = BeanDefinitionBuilder.rootBeanDefinition(Component::class.java)
		component.addPropertyValue("name", element.getAttribute("name"))
		return component.beanDefinition
	}

	private fun parseChildComponents(childElements: List&lt;Element&gt;, factory: BeanDefinitionBuilder) {
		val children = ManagedList&lt;BeanDefinition&gt;(childElements.size)
		for (element in childElements) {
			children.add(parseComponentElement(element))
		}
		factory.addPropertyValue("children", children)
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, the various artifacts need to be registered with the Spring XML infrastructure,
by modifying the <code>META-INF/spring.handlers</code> and <code>META-INF/spring.schemas</code> files, as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># in 'META-INF/spring.handlers'
http\://www.foo.example/schema/component=com.foo.ComponentNamespaceHandler</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># in 'META-INF/spring.schemas'
http\://www.foo.example/schema/component/component.xsd=com/foo/component.xsd</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="xsd-custom-custom-just-attributes"><a class="anchor" href="#xsd-custom-custom-just-attributes"></a>Custom Attributes on &#8220;Normal&#8221; Elements</h4>
<div class="paragraph">
<p>Writing your own custom parser and the associated artifacts is not hard. However,
it is sometimes not the right thing to do. Consider a scenario where you need to
add metadata to already existing bean definitions. In this case, you certainly
do not want to have to write your own entire custom extension. Rather, you merely
want to add an additional attribute to the existing bean definition element.</p>
</div>
<div class="paragraph">
<p>By way of another example, suppose that you define a bean definition for a
service object that (unknown to it) accesses a clustered
<a href="https://jcp.org/en/jsr/detail?id=107">JCache</a>, and you want to ensure that the
named JCache instance is eagerly started within the surrounding cluster.
The following listing shows such a definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="checkingAccountService" class="com.foo.DefaultCheckingAccountService"
		jcache:cache-name="checking.account"&gt;
	&lt;!-- other dependencies here... --&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can then create another <code>BeanDefinition</code> when the
<code>'jcache:cache-name'</code> attribute is parsed. This <code>BeanDefinition</code> then initializes
the named JCache for us. We can also modify the existing <code>BeanDefinition</code> for the
<code>'checkingAccountService'</code> so that it has a dependency on this new
JCache-initializing <code>BeanDefinition</code>. The following listing shows our <code>JCacheInitializer</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.foo;

public class JCacheInitializer {

	private String name;

	public JCacheInitializer(String name) {
		this.name = name;
	}

	public void initialize() {
		// lots of JCache API calls to initialize the named cache...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">package com.foo

class JCacheInitializer(private val name: String) {

	fun initialize() {
		// lots of JCache API calls to initialize the named cache...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we can move onto the custom extension. First, we need to author
the XSD schema that describes the custom attribute, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;

&lt;xsd:schema xmlns="http://www.foo.example/schema/jcache"
		xmlns:xsd="http://www.w3.org/2001/XMLSchema"
		targetNamespace="http://www.foo.example/schema/jcache"
		elementFormDefault="qualified"&gt;

	&lt;xsd:attribute name="cache-name" type="xsd:string"/&gt;

&lt;/xsd:schema&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, we need to create the associated <code>NamespaceHandler</code>, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.foo;

import org.springframework.beans.factory.xml.NamespaceHandlerSupport;

public class JCacheNamespaceHandler extends NamespaceHandlerSupport {

	public void init() {
		super.registerBeanDefinitionDecoratorForAttribute("cache-name",
			new JCacheInitializingBeanDefinitionDecorator());
	}

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">package com.foo

import org.springframework.beans.factory.xml.NamespaceHandlerSupport

class JCacheNamespaceHandler : NamespaceHandlerSupport() {

	override fun init() {
		super.registerBeanDefinitionDecoratorForAttribute("cache-name",
				JCacheInitializingBeanDefinitionDecorator())
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, we need to create the parser. Note that, in this case, because we are going to parse
an XML attribute, we write a <code>BeanDefinitionDecorator</code> rather than a <code>BeanDefinitionParser</code>.
The following listing shows our <code>BeanDefinitionDecorator</code> implementation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.foo;

import org.springframework.beans.factory.config.BeanDefinitionHolder;
import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.BeanDefinitionDecorator;
import org.springframework.beans.factory.xml.ParserContext;
import org.w3c.dom.Attr;
import org.w3c.dom.Node;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class JCacheInitializingBeanDefinitionDecorator implements BeanDefinitionDecorator {

	private static final String[] EMPTY_STRING_ARRAY = new String[0];

	public BeanDefinitionHolder decorate(Node source, BeanDefinitionHolder holder,
			ParserContext ctx) {
		String initializerBeanName = registerJCacheInitializer(source, ctx);
		createDependencyOnJCacheInitializer(holder, initializerBeanName);
		return holder;
	}

	private void createDependencyOnJCacheInitializer(BeanDefinitionHolder holder,
			String initializerBeanName) {
		AbstractBeanDefinition definition = ((AbstractBeanDefinition) holder.getBeanDefinition());
		String[] dependsOn = definition.getDependsOn();
		if (dependsOn == null) {
			dependsOn = new String[]{initializerBeanName};
		} else {
			List dependencies = new ArrayList(Arrays.asList(dependsOn));
			dependencies.add(initializerBeanName);
			dependsOn = (String[]) dependencies.toArray(EMPTY_STRING_ARRAY);
		}
		definition.setDependsOn(dependsOn);
	}

	private String registerJCacheInitializer(Node source, ParserContext ctx) {
		String cacheName = ((Attr) source).getValue();
		String beanName = cacheName + "-initializer";
		if (!ctx.getRegistry().containsBeanDefinition(beanName)) {
			BeanDefinitionBuilder initializer = BeanDefinitionBuilder.rootBeanDefinition(JCacheInitializer.class);
			initializer.addConstructorArg(cacheName);
			ctx.getRegistry().registerBeanDefinition(beanName, initializer.getBeanDefinition());
		}
		return beanName;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">package com.foo

import org.springframework.beans.factory.config.BeanDefinitionHolder
import org.springframework.beans.factory.support.AbstractBeanDefinition
import org.springframework.beans.factory.support.BeanDefinitionBuilder
import org.springframework.beans.factory.xml.BeanDefinitionDecorator
import org.springframework.beans.factory.xml.ParserContext
import org.w3c.dom.Attr
import org.w3c.dom.Node

import java.util.ArrayList

class JCacheInitializingBeanDefinitionDecorator : BeanDefinitionDecorator {

	override fun decorate(source: Node, holder: BeanDefinitionHolder,
						ctx: ParserContext): BeanDefinitionHolder {
		val initializerBeanName = registerJCacheInitializer(source, ctx)
		createDependencyOnJCacheInitializer(holder, initializerBeanName)
		return holder
	}

	private fun createDependencyOnJCacheInitializer(holder: BeanDefinitionHolder,
													initializerBeanName: String) {
		val definition = holder.beanDefinition as AbstractBeanDefinition
		var dependsOn = definition.dependsOn
		dependsOn = if (dependsOn == null) {
			arrayOf(initializerBeanName)
		} else {
			val dependencies = ArrayList(listOf(*dependsOn))
			dependencies.add(initializerBeanName)
			dependencies.toTypedArray()
		}
		definition.setDependsOn(*dependsOn)
	}

	private fun registerJCacheInitializer(source: Node, ctx: ParserContext): String {
		val cacheName = (source as Attr).value
		val beanName = "$cacheName-initializer"
		if (!ctx.registry.containsBeanDefinition(beanName)) {
			val initializer = BeanDefinitionBuilder.rootBeanDefinition(JCacheInitializer::class.java)
			initializer.addConstructorArg(cacheName)
			ctx.registry.registerBeanDefinition(beanName, initializer.getBeanDefinition())
		}
		return beanName
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, we need to register the various artifacts with the Spring XML infrastructure
by modifying the <code>META-INF/spring.handlers</code> and <code>META-INF/spring.schemas</code> files, as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># in 'META-INF/spring.handlers'
http\://www.foo.example/schema/jcache=com.foo.JCacheNamespaceHandler</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># in 'META-INF/spring.schemas'
http\://www.foo.example/schema/jcache/jcache.xsd=com/foo/jcache.xsd</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="application-startup-steps"><a class="anchor" href="#application-startup-steps"></a>Application Startup Steps</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This part of the appendix lists the existing <code>StartupSteps</code> that the core container is instrumented with.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The name and detailed information about each startup step is not part of the public contract and
is subject to change; this is considered as an implementation detail of the core container and will follow
its behavior changes.
</td>
</tr>
</table>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Application startup steps defined in the core container</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Tags</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.beans.instantiate</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Instantiation of a bean and its dependencies.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>beanName</code> the name of the bean, <code>beanType</code> the type required at the injection point.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.beans.smart-initialize</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Initialization of <code>SmartInitializingSingleton</code> beans.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>beanName</code> the name of the bean.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.context.annotated-bean-reader.create</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Creation of the <code>AnnotatedBeanDefinitionReader</code>.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.context.base-packages.scan</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Scanning of base packages.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>packages</code> array of base packages for scanning.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.context.beans.post-process</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Beans post-processing phase.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.context.bean-factory.post-process</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Invocation of the <code>BeanFactoryPostProcessor</code> beans.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>postProcessor</code> the current post-processor.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.context.beandef-registry.post-process</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Invocation of the <code>BeanDefinitionRegistryPostProcessor</code> beans.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>postProcessor</code> the current post-processor.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.context.component-classes.register</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Registration of component classes through <code>AnnotationConfigApplicationContext#register</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>classes</code> array of given classes for registration.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.context.config-classes.enhance</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enhancement of configuration classes with CGLIB proxies.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>classCount</code> count of enhanced classes.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.context.config-classes.parse</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Configuration classes parsing phase with the <code>ConfigurationClassPostProcessor</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>classCount</code> count of processed classes.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.context.refresh</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Application context refresh phase.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="spring-jcl.html">Logging</a></span>
  <span class="next"><a href="../testing.html">Testing</a></span>
</nav>
</article>
  </div>
</main>
</div>
<footer class="footer flex">
    <div id="spring-links flex">
        <img id="springlogo" src="../../../_/img/spring-logo.svg" alt="Spring">
        <p class="smallest antialiased"> <script>var d = new Date();
        document.write(d.getFullYear());</script> <a href="https://www.vmware.com/">VMware</a>, Inc. or its affiliates. <a href="https://www.vmware.com/help/legal.html">Terms of Use</a>  <a href="https://www.vmware.com/help/privacy.html" rel="noopener noreferrer">Privacy</a>  <a href="https://spring.io/trademarks">Trademark Guidelines</a> <span id="thank-you-mobile"> <a href="https://spring.io/thank-you">Thank you</a></span>  <a href="https://www.vmware.com/help/privacy/california-privacy-rights.html">Your California Privacy Rights</a>  <a class="ot-sdk-show-settings">Cookie Settings</a> <span id="teconsent"></span></p>
        <p class="smallest antialiased">Apache, Apache Tomcat, Apache Kafka, Apache Cassandra&trade;, and Apache Geode&trade; are trademarks or registered trademarks of the Apache Software Foundation in the United States and/or other countries. Java&trade;, Java&trade; SE, Java&trade; EE, and OpenJDK&trade; are trademarks of Oracle and/or its affiliates. Kubernetes is a registered trademark of the Linux Foundation in the United States and other countries. Linux is the registered trademark of Linus Torvalds in the United States and other countries. Windows and Microsoft Azure are registered trademarks of Microsoft Corporation. AWS and Amazon Web Services are trademarks or registered trademarks of Amazon.com Inc. or its affiliates. All other trademarks and copyrights are property of their respective owners and are only mentioned for informative purposes. Other names may be trademarks of their respective owners.</p>
    </div>
    <div id="social-icons" class="flex jc-between">
        <a href="https://www.youtube.com/user/SpringSourceDev" title="Youtube"><svg id="youtube-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 40 40"><circle class="cls-1" cx="20" cy="20" r="20"/><path class="cls-2" d="M30.91,14.53a2.89,2.89,0,0,0-2-2C27.12,12,20,12,20,12s-7.12,0-8.9.47a2.9,2.9,0,0,0-2,2A30.56,30.56,0,0,0,8.63,20a30.44,30.44,0,0,0,.46,5.47,2.89,2.89,0,0,0,2,2C12.9,28,20,28,20,28s7.12,0,8.9-.47a2.87,2.87,0,0,0,2-2A30.56,30.56,0,0,0,31.37,20,28.88,28.88,0,0,0,30.91,14.53ZM17.73,23.41V16.59L23.65,20Z"/></svg></a>
        <a href="https://github.com/spring-projects" title="Github"><svg id="github-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 75.93 75.93"><path class="cls-1" d="M38,0a38,38,0,1,0,38,38A38,38,0,0,0,38,0Z"/></g><path class="cls-2" d="M38,15.59A22.95,22.95,0,0,0,30.71,60.3c1.15.21,1.57-.5,1.57-1.11s0-2,0-3.9c-6.38,1.39-7.73-3.07-7.73-3.07A6.09,6.09,0,0,0,22,48.86c-2.09-1.42.15-1.39.15-1.39a4.81,4.81,0,0,1,3.52,2.36c2,3.5,5.37,2.49,6.67,1.91a4.87,4.87,0,0,1,1.46-3.07c-5.09-.58-10.45-2.55-10.45-11.34a8.84,8.84,0,0,1,2.36-6.15,8.29,8.29,0,0,1,.23-6.07s1.92-.62,6.3,2.35a21.82,21.82,0,0,1,11.49,0c4.38-3,6.3-2.35,6.3-2.35a8.29,8.29,0,0,1,.23,6.07,8.84,8.84,0,0,1,2.36,6.15c0,8.81-5.37,10.75-10.48,11.32a5.46,5.46,0,0,1,1.56,4.25c0,3.07,0,5.54,0,6.29s.42,1.33,1.58,1.1A22.94,22.94,0,0,0,38,15.59Z"/></svg></a>
        <a href="https://twitter.com/springcentral" title="Twitter"><svg id="twitter-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 75.93 75.93"><circle class="cls-1" cx="37.97" cy="37.97" r="37.97"/><path id="Twitter-2" data-name="Twitter" class="cls-2" d="M55.2,22.73a15.43,15.43,0,0,1-4.88,1.91,7.56,7.56,0,0,0-5.61-2.49A7.78,7.78,0,0,0,37,30a7.56,7.56,0,0,0,.2,1.79,21.63,21.63,0,0,1-15.84-8.23,8,8,0,0,0,2.37,10.52,7.66,7.66,0,0,1-3.48-1v.09A7.84,7.84,0,0,0,26.45,41a7.54,7.54,0,0,1-2,.28A7.64,7.64,0,0,1,23,41.09a7.71,7.71,0,0,0,7.18,5.47,15.21,15.21,0,0,1-9.55,3.37,15.78,15.78,0,0,1-1.83-.11,21.41,21.41,0,0,0,11.78,3.54c14.13,0,21.86-12,21.86-22.42,0-.34,0-.68,0-1a15.67,15.67,0,0,0,3.83-4.08,14.9,14.9,0,0,1-4.41,1.24A7.8,7.8,0,0,0,55.2,22.73Z"/></svg></a>
    </div>
</footer>
<script src="../../../_/js/site.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
<script async src="../../../_/js/vendor/tabs.js"></script>
<script src="../../../_/js/vendor/docsearch.min.js"></script>
<script src="../../../_/js/vendor/switchtheme.js"></script>
<!-- fetched from https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js -->
<script>
docsearch({
  apiKey: '6098173f7ca8a2fc7db296538ae8a6cc',
  indexName: 'spring',
  inputSelector: '#search-input',
  algoliaOptions: { hitsPerPage: 10 }
})
</script>
  </body>
</html>
