<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Servlet Applications :: Spring</title>
    <meta name="generator" content="Antora 3.0.0-alpha.8">
    <link rel="stylesheet" href="../../_/css/site.css">

<link href="../../_/img/favicon.ico" rel='shortcut icon' type='image/vnd.microsoft.icon'>
<link rel="stylesheet" href="../../_/css/vendor/docsearch.min.css">
<!-- fetched from https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css -->
    <script>var uiRootPath = '../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://spring.io">
        <img id="springlogo" class="block" src="../../_/img/spring-logo.svg" alt="Spring">
      </a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Why Spring</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://spring.io/why-spring">Overview</a>
            <a class="navbar-item" href="https://spring.io/microservices">Microservices</a>
            <a class="navbar-item" href="https://spring.io/reactive">Reactive</a>
            <a class="navbar-item" href="https://spring.io/event-driven">Event Driven</a>
            <a class="navbar-item" href="https://spring.io/cloud">Cloud</a>
            <a class="navbar-item" href="https://spring.io/web-applications">Web Applications</a>
            <a class="navbar-item" href="https://spring.io/serverless">Serverless</a>
            <a class="navbar-item" href="https://spring.io/batch">Batch</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Learn</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://spring.io/learn">Overview</a>
            <a class="navbar-item" href="https://spring.io/quickstart">Quickstart</a>
            <a class="navbar-item" href="https://spring.io/guides">Guides</a>
            <a class="navbar-item" href="https://spring.io/blog">Blog</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Projects</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://spring.io/projects">Overview</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-boot">Spring Boot</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-framework">Spring Framework</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-cloud">Spring Cloud</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-cloud-dataflow">Spring Cloud Data Flow</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-data">Spring Data</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-integration">Spring Integration</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-batch">Spring Batch</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-security">Spring Security</a>
            <a class="navbar-item navbar-item-special" href="https://spring.io/projects">View all projects</a>
            <a class="navbar-item" href="https://spring.io/tools">Spring Tools 4</a>
            <a class="navbar-item navbar-item-special-2" href="https://start.spring.io">Spring Initializr <svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><polyline points="15 10.94 15 15 1 15 1 1 5.06 1" fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="2"></polyline><polyline points="8.93 1 15 1 15 7.07" fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="2"></polyline><line x1="15" y1="1" x2="8" y2="8" fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="2"></line></svg></a>
          </div>
        </div>

        <a class="navbar-item" href="https://spring.io/training">Training</a>
        <a class="navbar-item" href="https://spring.io/support">Support</a>
        <div class="navbar-item has-dropdown is-hoverable is-community">
          <a class="navbar-link" href="#">Community</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://spring.io/community">Overview</a>
            <a class="navbar-item" href="https://spring.io/events">Events</a>
            <a class="navbar-item" href="https://spring.io/team">Team</a>
          </div>
        </div>
      </div>
    </div>
    <div id="switch-theme">
      <input type="checkbox" id="switch-theme-checkbox" />
      <label for="switch-theme-checkbox">Dark Theme</label>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="" data-version="5.5">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Spring Security</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../prerequisites.html">Prerequisites</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../community.html">Community</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../whats-new.html">What&#8217;s New</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../getting-spring-security.html">Getting Spring Security</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Features</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../features/authentication/supported.html">Authentication</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../features/authentication/password-storage.html">Password Storage</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Protection Against Exploits</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../features/exploits/csrf.html">CSRF</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../features/exploits/headers.html">HTTP Headers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../features/exploits/http.html">HTTP Requests</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../modules.html">Project Modules and Dependencies</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../samples.html">Samples</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Servlet Applications</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="getting-started.html">Getting Started</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="architecture.html">The Big Picture</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="authentication/index.html">Authentication</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="authentication/architecture.html">Authentication Architecture</a>
  </li>
  <li class="nav-item" data-depth="3">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="authentication/passwords/index.html">Username/Password</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="4">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Reading Username/Password</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="authentication/passwords/form.html">Form</a>
  </li>
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="authentication/passwords/basic.html">Form</a>
  </li>
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="authentication/passwords/digest.html">Digest</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="4">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Password Storage</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="authentication/passwords/in-memory.html">In Memory</a>
  </li>
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="authentication/passwords/jdbc.html">JDBC</a>
  </li>
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="authentication/passwords/user-details.html">UserDetails</a>
  </li>
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="authentication/passwords/user-details-service.html">UserDetailsService</a>
  </li>
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="authentication/passwords/password-encoder.html">PasswordEncoder</a>
  </li>
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="authentication/passwords/dao-authentication-provider.html">DaoAuthenticationProvider</a>
  </li>
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="authentication/passwords/ldap.html">LDAP</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="authentication/session-management.html">Session Management</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="authentication/rememberme.html">Remember Me</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="authentication/openid.html">OpenID Support</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="authentication/anonymous.html">Anonymous</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="authentication/preauth.html">Pre-Authentication</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="authentication/jaas.html">JAAS</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="authentication/cas.html">CAS</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="authentication/x509.html">X509</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="authentication/runas.html">Run-As</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="authentication/logout.html">Logout</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="authentication/events.html">Authentication Events</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="authorization/index.html">Authorization</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="authorization/architecture.html">Authorization Architecture</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="authorization/authorize-requests.html">Authorize HTTP Requests</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="authorization/expression-based.html">Expression-Based Access Control</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="authorization/secure-objects.html">Secure Object Implementations</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="authorization/method-security.html">Method Security</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="authorization/acls.html">Domain Object Security (ACLs)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">OAuth2</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="oauth2/oauth2-login.html">OAuth2 Log In</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="oauth2/oauth2-client.html">OAuth2 Client</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="oauth2/oauth2-resourceserver.html">OAuth2 Resource Server</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="saml2/index.html">SAML 2</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="exploits/index.html">Protection Against Exploits</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="exploits/csrf.html">CSRF</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="exploits/headers.html">HTTP Headers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="exploits/http.html">HTTP Requests</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="exploits/firewall.html">Firewall</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Integrations</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="integrations/servlet-api.html">Servlet APIs</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="integrations/data.html">Spring Data</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="integrations/concurrency.html">Java&#8217;s Concurrency APIs</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="integrations/jackson.html">Jackson</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="integrations/localization.html">Localization</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="integrations/mvc.html">Spring MVC</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="integrations/websocket.html">WebSocket</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="integrations/cors.html">Spring CORS Support</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="integrations/jsp-taglibs.html">JSP Taglib</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Configuration</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="java-configuration/index.html">Java Configuration</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="kotlin-configuration/index.html">Kotlin Configuration</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="namespace/index.html">Security Namespace Configuration</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Testing</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="test/method.html">Testing Method Security</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="test/mockmvc.html">Spring MVC Test Integration</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="cryptography.html">Cryptography</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Appendix</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="appendix/proxy-server.html">Proxy Server Configuration</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="appendix/database-schema.html">Security Database Schema</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="appendix/namespace.html">The Security Namespace</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="appendix/faq.html">Spring Security FAQ</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Reactive Applications</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reactive/webflux.html">WebFlux Security</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Project Against Exploits</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../reactive/exploits/csrf.html">CSRF</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../reactive/exploits/headers.html">Headers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../reactive/exploits/http.html">HTTP Requests</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">OAuth2</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../reactive/oauth2/login.html">OAuth 2.0 Login</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../reactive/oauth2/access-token.html">OAuth2 Client</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../reactive/oauth2/resource-server.html">OAuth 2.0 Resource Server</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../reactive/registered-oauth2-authorized-client.html">@RegisteredOAuth2AuthorizedClient</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reactive/x509.html">X.509</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reactive/webclient.html">WebClient</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reactive/method.html">EnableReactiveMethodSecurity</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reactive/cors.html">CORS</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reactive/test.html">Testing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reactive/rsocket.html">RSocket</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Spring Security</span>
    <span class="version">5.5</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../../index.html">Spring Security</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../index.html">5.6</a>
        </li>
        <li class="version is-current">
          <a href="../index.html">5.5</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../session/index.html">Spring Session</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../session/index.html">2.6</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Spring Security</a></li>
    <li><a href="index.html">Servlet Applications</a></li>
  </ul>
</nav>
<div class="search">
  <input id="search-input" type="text" placeholder="Search docs">
</div>

<div class="page-versions">
  <button class="version-menu-toggle" title="Show other versions of page">5.5</button>
  <div class="version-menu">
    <a class="version" href="../../servlet/index.html">5.6</a>
    <a class="version is-current" href="index.html">5.5</a>
  </div>
</div>
  <div class="edit-this-page"><a href="https://github.com/rwinch/spring-security/edit/antora/5.5.x/docs/modules/ROOT/pages/servlet/index.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<div class="admonitionblock important">
  <table>
    <tbody><tr>
      <td class="icon">
        <i class="fa icon-important" title="Important"></i>
      </td>
      <td class="content">
        <div class="paragraph">
          <p>There is a newer version available. Please update to <a href="../../servlet/index.html">Spring Security 5.6</a>!</p>
        </div>
      </td>
    </tr></tbody>
  </table>
</div>
<h1 id="page-title" class="page">Servlet Applications</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security integrates with the Servlet Container by using a standard Servlet <code>Filter</code>. This means it works with any application that runs in a Servlet Container. More concretely, you do not need to use Spring in your Servlet-based application to take advantage of Spring Security.</p>
</div>
<div class="paragraph">
<p>Unresolved include directive in modules/ROOT/pages/servlet/index.adoc - include::hello/index.adoc[]</p>
</div>
<div class="paragraph">
<p>Unresolved include directive in modules/ROOT/pages/servlet/index.adoc - include::architecture/index.adoc[]</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-authentication"><a class="anchor" href="#servlet-authentication"></a>Authentication</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security provides comprehensive support for <a href="#authentication">[authentication]</a>.
This section discusses:</p>
</div>
<div id="servlet-authentication-architecture" class="paragraph">
<p><strong>Architecture Components</strong></p>
</div>
<div class="paragraph">
<p>This section describes the main architectural components of Spring Security&#8217;s used in Servlet authentication.
If you need concrete flows that explain how these pieces fit together, look at the <a href="#servlet-authentication-mechanisms">Authentication Mechanism</a> specific sections.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#servlet-authentication-securitycontextholder">[servlet-authentication-securitycontextholder]</a> - The <code>SecurityContextHolder</code> is where Spring Security stores the details of who is <a href="#authentication">authenticated</a>.</p>
</li>
<li>
<p><a href="#servlet-authentication-securitycontext">[servlet-authentication-securitycontext]</a> - is obtained from the <code>SecurityContextHolder</code> and contains the <code>Authentication</code> of the currently authenticated user.</p>
</li>
<li>
<p><a href="#servlet-authentication-authentication">[servlet-authentication-authentication]</a> - Can be the input to <code>AuthenticationManager</code> to provide the credentials a user has provided to authenticate or the current user from the <code>SecurityContext</code>.</p>
</li>
<li>
<p><a href="#servlet-authentication-granted-authority">[servlet-authentication-granted-authority]</a> - An authority that is granted to the principal on the <code>Authentication</code> (i.e. roles, scopes, etc.)</p>
</li>
<li>
<p><a href="#servlet-authentication-authenticationmanager">[servlet-authentication-authenticationmanager]</a> -  the API that defines how Spring Security&#8217;s Filters perform  <a href="#authentication">authentication</a>.</p>
</li>
<li>
<p><a href="#servlet-authentication-providermanager">[servlet-authentication-providermanager]</a> -  the most common implementation of <code>AuthenticationManager</code>.</p>
</li>
<li>
<p><a href="#servlet-authentication-authenticationprovider">[servlet-authentication-authenticationprovider]</a> - used by <code>ProviderManager</code> to perform a specific type of authentication.</p>
</li>
<li>
<p><a href="#servlet-authentication-authenticationentrypoint">[servlet-authentication-authenticationentrypoint]</a> - used for requesting credentials from a client (i.e. redirecting to a log in page, sending a <code>WWW-Authenticate</code> response, etc.)</p>
</li>
<li>
<p><a href="#servlet-authentication-abstractprocessingfilter">[servlet-authentication-abstractprocessingfilter]</a> - a base <code>Filter</code> used for authentication.
This also gives a good idea of the high level flow of authentication and how pieces work together.</p>
</li>
</ul>
</div>
<div id="servlet-authentication-mechanisms" class="paragraph">
<p><strong>Authentication Mechanisms</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#servlet-authentication-unpwd">Username and Password</a> - how to authenticate with a username/password</p>
</li>
<li>
<p><a href="#oauth2login">OAuth 2.0 Login</a> - OAuth 2.0 Log In with OpenID Connect and non-standard OAuth 2.0 Login (i.e. GitHub)</p>
</li>
<li>
<p><a href="#servlet-saml2">SAML 2.0 Login</a> - SAML 2.0 Log In</p>
</li>
<li>
<p><a href="#servlet-cas">Central Authentication Server (CAS)</a> - Central Authentication Server (CAS) Support</p>
</li>
<li>
<p><a href="#servlet-rememberme">Remember Me</a> - How to remember a user past session expiration</p>
</li>
<li>
<p><a href="#servlet-jaas">JAAS Authentication</a> - Authenticate with JAAS</p>
</li>
<li>
<p><a href="#servlet-openid">OpenID</a> - OpenID Authentication (not to be confused with OpenID Connect)</p>
</li>
<li>
<p><a href="#servlet-preauth">[servlet-preauth]</a> - Authenticate with an external mechanism such as <a href="https://www.siteminder.com/">SiteMinder</a> or Java EE security but still use Spring Security for authorization and protection against common exploits.</p>
</li>
<li>
<p><a href="#servlet-x509">X509 Authentication</a> - X509 Authentication</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-authorization"><a class="anchor" href="#servlet-authorization"></a>Authorization</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The advanced authorization capabilities within Spring Security represent one of the most compelling reasons for its popularity.
Irrespective of how you choose to authenticate - whether using a Spring Security-provided mechanism and provider, or integrating with a container or other non-Spring Security authentication authority - you will find the authorization services can be used within your application in a consistent and simple way.</p>
</div>
<div class="paragraph">
<p>In this part we&#8217;ll explore the different <code>AbstractSecurityInterceptor</code> implementations, which were introduced in Part I.
We then move on to explore how to fine-tune authorization through use of domain access control lists.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_oauth2"><a class="anchor" href="#_oauth2"></a>OAuth2</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="oauth2login"><a class="anchor" href="#oauth2login"></a>OAuth 2.0 Login</h3>
<div class="paragraph">
<p>The OAuth 2.0 Login feature provides an application with the capability to have users log in to the application by using their existing account at an OAuth 2.0 Provider (e.g. GitHub) or OpenID Connect 1.0 Provider (such as Google).
OAuth 2.0 Login implements the use cases: "Login with Google" or "Login with GitHub".</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
OAuth 2.0 Login is implemented by using the <strong>Authorization Code Grant</strong>, as specified in the <a href="https://tools.ietf.org/html/rfc6749#section-4.1">OAuth 2.0 Authorization Framework</a> and <a href="https://openid.net/specs/openid-connect-core-1_0.html#CodeFlowAuth">OpenID Connect Core 1.0</a>.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="oauth2login-sample-boot"><a class="anchor" href="#oauth2login-sample-boot"></a>Spring Boot 2.x Sample</h4>
<div class="paragraph">
<p>Spring Boot 2.x brings full auto-configuration capabilities for OAuth 2.0 Login.</p>
</div>
<div class="paragraph">
<p>This section shows how to configure the {gh-samples-url}/servlet/spring-boot/java/oauth2/login[<strong>OAuth 2.0 Login sample</strong>] using <em>Google</em> as the <em>Authentication Provider</em> and covers the following topics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2login-sample-initial-setup">Initial setup</a></p>
</li>
<li>
<p><a href="#oauth2login-sample-redirect-uri">Setting the redirect URI</a></p>
</li>
<li>
<p><a href="#oauth2login-sample-application-config">Configure application.yml</a></p>
</li>
<li>
<p><a href="#oauth2login-sample-boot-application">Boot up the application</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="oauth2login-sample-initial-setup"><a class="anchor" href="#oauth2login-sample-initial-setup"></a>Initial setup</h5>
<div class="paragraph">
<p>To use Google&#8217;s OAuth 2.0 authentication system for login, you must set up a project in the Google API Console to obtain OAuth 2.0 credentials.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<a href="https://developers.google.com/identity/protocols/OpenIDConnect">Google&#8217;s OAuth 2.0 implementation</a> for authentication conforms to the  <a href="https://openid.net/connect/">OpenID Connect 1.0</a> specification and is <a href="https://openid.net/certification/">OpenID Certified</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Follow the instructions on the <a href="https://developers.google.com/identity/protocols/OpenIDConnect">OpenID Connect</a> page, starting in the section, "Setting up OAuth 2.0".</p>
</div>
<div class="paragraph">
<p>After completing the "Obtain OAuth 2.0 credentials" instructions, you should have a new OAuth Client with credentials consisting of a Client ID and a Client Secret.</p>
</div>
</div>
<div class="sect4">
<h5 id="oauth2login-sample-redirect-uri"><a class="anchor" href="#oauth2login-sample-redirect-uri"></a>Setting the redirect URI</h5>
<div class="paragraph">
<p>The redirect URI is the path in the application that the end-user&#8217;s user-agent is redirected back to after they have authenticated with Google and have granted access to the OAuth Client <em>(<a href="#oauth2login-sample-initial-setup">created in the previous step</a>)</em> on the Consent page.</p>
</div>
<div class="paragraph">
<p>In the "Set a redirect URI" sub-section, ensure that the <strong>Authorized redirect URIs</strong> field is set to <code><a href="http://localhost:8080/login/oauth2/code/google" class="bare">http://localhost:8080/login/oauth2/code/google</a></code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The default redirect URI template is <code>{baseUrl}/login/oauth2/code/{registrationId}</code>.
The <strong><em>registrationId</em></strong> is a unique identifier for the <a href="#oauth2Client-client-registration">ClientRegistration</a>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If the OAuth Client is running behind a proxy server, it is recommended to check <a href="#http-proxy-server">Proxy Server Configuration</a> to ensure the application is correctly configured.
Also, see the supported <a href="#oauth2Client-auth-code-redirect-uri"><code>URI</code> template variables</a> for <code>redirect-uri</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="oauth2login-sample-application-config"><a class="anchor" href="#oauth2login-sample-application-config"></a>Configure application.yml</h5>
<div class="paragraph">
<p>Now that you have a new OAuth Client with Google, you need to configure the application to use the OAuth Client for the <em>authentication flow</em>.
To do so:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Go to <code>application.yml</code> and set the following configuration:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:	<i class="conum" data-value="1"></i><b>(1)</b>
          google:	<i class="conum" data-value="2"></i><b>(2)</b>
            client-id: google-client-id
            client-secret: google-client-secret</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 1. OAuth Client properties</div>
<div class="content">
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>spring.security.oauth2.client.registration</code> is the base property prefix for OAuth Client properties.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Following the base property prefix is the ID for the <a href="#oauth2Client-client-registration">ClientRegistration</a>, such as google.</td>
</tr>
</table>
</div>
</div>
</div>
</li>
<li>
<p>Replace the values in the <code>client-id</code> and <code>client-secret</code> property with the OAuth 2.0 credentials you created earlier.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="oauth2login-sample-boot-application"><a class="anchor" href="#oauth2login-sample-boot-application"></a>Boot up the application</h5>
<div class="paragraph">
<p>Launch the Spring Boot 2.x sample and go to <code><a href="http://localhost:8080" class="bare">http://localhost:8080</a></code>.
You are then redirected to the default <em>auto-generated</em> login page, which displays a link for Google.</p>
</div>
<div class="paragraph">
<p>Click on the Google link, and you are then redirected to Google for authentication.</p>
</div>
<div class="paragraph">
<p>After authenticating with your Google account credentials, the next page presented to you is the Consent screen.
The Consent screen asks you to either allow or deny access to the OAuth Client you created earlier.
Click <strong>Allow</strong> to authorize the OAuth Client to access your email address and basic profile information.</p>
</div>
<div class="paragraph">
<p>At this point, the OAuth Client retrieves your email address and basic profile information from the <a href="https://openid.net/specs/openid-connect-core-1_0.html#UserInfo">UserInfo Endpoint</a> and establishes an authenticated session.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2login-boot-property-mappings"><a class="anchor" href="#oauth2login-boot-property-mappings"></a>Spring Boot 2.x Property Mappings</h4>
<div class="paragraph">
<p>The following table outlines the mapping of the Spring Boot 2.x OAuth Client properties to the <a href="#oauth2Client-client-registration">ClientRegistration</a> properties.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Spring Boot 2.x</th>
<th class="tableblock halign-left valign-top">ClientRegistration</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.registration.<em>[registrationId]</em></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>registrationId</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.registration.<em>[registrationId]</em>.client-id</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>clientId</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.registration.<em>[registrationId]</em>.client-secret</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>clientSecret</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.registration.<em>[registrationId]</em>.client-authentication-method</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>clientAuthenticationMethod</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.registration.<em>[registrationId]</em>.authorization-grant-type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>authorizationGrantType</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.registration.<em>[registrationId]</em>.redirect-uri</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>redirectUri</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.registration.<em>[registrationId]</em>.scope</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scopes</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.registration.<em>[registrationId]</em>.client-name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>clientName</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.provider.<em>[providerId]</em>.authorization-uri</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>providerDetails.authorizationUri</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.provider.<em>[providerId]</em>.token-uri</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>providerDetails.tokenUri</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.provider.<em>[providerId]</em>.jwk-set-uri</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>providerDetails.jwkSetUri</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.provider.<em>[providerId]</em>.issuer-uri</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>providerDetails.issuerUri</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.provider.<em>[providerId]</em>.user-info-uri</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>providerDetails.userInfoEndpoint.uri</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.provider.<em>[providerId]</em>.user-info-authentication-method</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>providerDetails.userInfoEndpoint.authenticationMethod</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.provider.<em>[providerId]</em>.user-name-attribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>providerDetails.userInfoEndpoint.userNameAttributeName</code></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
A <code>ClientRegistration</code> can be initially configured using discovery of an OpenID Connect Provider&#8217;s <a href="https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig">Configuration endpoint</a> or an Authorization Server&#8217;s <a href="https://tools.ietf.org/html/rfc8414#section-3">Metadata endpoint</a>, by specifying the <code>spring.security.oauth2.client.provider.<em>[providerId]</em>.issuer-uri</code> property.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="oauth2login-common-oauth2-provider"><a class="anchor" href="#oauth2login-common-oauth2-provider"></a>CommonOAuth2Provider</h4>
<div class="paragraph">
<p><code>CommonOAuth2Provider</code> pre-defines a set of default client properties for a number of well known providers: Google, GitHub, Facebook, and Okta.</p>
</div>
<div class="paragraph">
<p>For example, the <code>authorization-uri</code>, <code>token-uri</code>, and <code>user-info-uri</code> do not change often for a Provider.
Therefore, it makes sense to provide default values in order to reduce the required configuration.</p>
</div>
<div class="paragraph">
<p>As demonstrated previously, when we <a href="#oauth2login-sample-application-config">configured a Google client</a>, only the <code>client-id</code> and <code>client-secret</code> properties are required.</p>
</div>
<div class="paragraph">
<p>The following listing shows an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          google:
            client-id: google-client-id
            client-secret: google-client-secret</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The auto-defaulting of client properties works seamlessly here because the <code>registrationId</code> (<code>google</code>) matches the <code>GOOGLE</code> <code>enum</code> (case-insensitive) in <code>CommonOAuth2Provider</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For cases where you may want to specify a different <code>registrationId</code>, such as <code>google-login</code>, you can still leverage auto-defaulting of client properties by configuring the <code>provider</code> property.</p>
</div>
<div class="paragraph">
<p>The following listing shows an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          google-login:	<i class="conum" data-value="1"></i><b>(1)</b>
            provider: google	<i class="conum" data-value="2"></i><b>(2)</b>
            client-id: google-client-id
            client-secret: google-client-secret</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>registrationId</code> is set to <code>google-login</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>provider</code> property is set to <code>google</code>, which will leverage the auto-defaulting of client properties set in <code>CommonOAuth2Provider.GOOGLE.getBuilder()</code>.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="oauth2login-custom-provider-properties"><a class="anchor" href="#oauth2login-custom-provider-properties"></a>Configuring Custom Provider Properties</h4>
<div class="paragraph">
<p>There are some OAuth 2.0 Providers that support multi-tenancy, which results in different protocol endpoints for each tenant (or sub-domain).</p>
</div>
<div class="paragraph">
<p>For example, an OAuth Client registered with Okta is assigned to a specific sub-domain and have their own protocol endpoints.</p>
</div>
<div class="paragraph">
<p>For these cases, Spring Boot 2.x provides the following base property for configuring custom provider properties: <code>spring.security.oauth2.client.provider.<em>[providerId]</em></code>.</p>
</div>
<div class="paragraph">
<p>The following listing shows an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-secret: okta-client-secret
        provider:
          okta:	<i class="conum" data-value="1"></i><b>(1)</b>
            authorization-uri: https://your-subdomain.oktapreview.com/oauth2/v1/authorize
            token-uri: https://your-subdomain.oktapreview.com/oauth2/v1/token
            user-info-uri: https://your-subdomain.oktapreview.com/oauth2/v1/userinfo
            user-name-attribute: sub
            jwk-set-uri: https://your-subdomain.oktapreview.com/oauth2/v1/keys</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The base property (<code>spring.security.oauth2.client.provider.okta</code>) allows for custom configuration of protocol endpoint locations.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="oauth2login-override-boot-autoconfig"><a class="anchor" href="#oauth2login-override-boot-autoconfig"></a>Overriding Spring Boot 2.x Auto-configuration</h4>
<div class="paragraph">
<p>The Spring Boot 2.x auto-configuration class for OAuth Client support is <code>OAuth2ClientAutoConfiguration</code>.</p>
</div>
<div class="paragraph">
<p>It performs the following tasks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Registers a <code>ClientRegistrationRepository</code> <code>@Bean</code> composed of <code>ClientRegistration</code>(s) from the configured OAuth Client properties.</p>
</li>
<li>
<p>Provides a <code>WebSecurityConfigurerAdapter</code> <code>@Configuration</code> and enables OAuth 2.0 Login through <code>httpSecurity.oauth2Login()</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you need to override the auto-configuration based on your specific requirements, you may do so in the following ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2login-register-clientregistrationrepository-bean">Register a ClientRegistrationRepository @Bean</a></p>
</li>
<li>
<p><a href="#oauth2login-provide-websecurityconfigureradapter">Provide a WebSecurityConfigurerAdapter</a></p>
</li>
<li>
<p><a href="#oauth2login-completely-override-autoconfiguration">Completely Override the Auto-configuration</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="oauth2login-register-clientregistrationrepository-bean"><a class="anchor" href="#oauth2login-register-clientregistrationrepository-bean"></a>Register a ClientRegistrationRepository @Bean</h5>
<div class="paragraph">
<p>The following example shows how to register a <code>ClientRegistrationRepository</code> <code>@Bean</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class OAuth2LoginConfig {

	@Bean
	public ClientRegistrationRepository clientRegistrationRepository() {
		return new InMemoryClientRegistrationRepository(this.googleClientRegistration());
	}

	private ClientRegistration googleClientRegistration() {
		return ClientRegistration.withRegistrationId("google")
			.clientId("google-client-id")
			.clientSecret("google-client-secret")
			.clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
			.authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
			.redirectUri("{baseUrl}/login/oauth2/code/{registrationId}")
			.scope("openid", "profile", "email", "address", "phone")
			.authorizationUri("https://accounts.google.com/o/oauth2/v2/auth")
			.tokenUri("https://www.googleapis.com/oauth2/v4/token")
			.userInfoUri("https://www.googleapis.com/oauth2/v3/userinfo")
			.userNameAttributeName(IdTokenClaimNames.SUB)
			.jwkSetUri("https://www.googleapis.com/oauth2/v3/certs")
			.clientName("Google")
			.build();
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
class OAuth2LoginConfig {
    @Bean
    fun clientRegistrationRepository(): ClientRegistrationRepository {
        return InMemoryClientRegistrationRepository(googleClientRegistration())
    }

    private fun googleClientRegistration(): ClientRegistration {
        return ClientRegistration.withRegistrationId("google")
                .clientId("google-client-id")
                .clientSecret("google-client-secret")
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .redirectUri("{baseUrl}/login/oauth2/code/{registrationId}")
                .scope("openid", "profile", "email", "address", "phone")
                .authorizationUri("https://accounts.google.com/o/oauth2/v2/auth")
                .tokenUri("https://www.googleapis.com/oauth2/v4/token")
                .userInfoUri("https://www.googleapis.com/oauth2/v3/userinfo")
                .userNameAttributeName(IdTokenClaimNames.SUB)
                .jwkSetUri("https://www.googleapis.com/oauth2/v3/certs")
                .clientName("Google")
                .build()
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2login-provide-websecurityconfigureradapter"><a class="anchor" href="#oauth2login-provide-websecurityconfigureradapter"></a>Provide a WebSecurityConfigurerAdapter</h5>
<div class="paragraph">
<p>The following example shows how to provide a <code>WebSecurityConfigurerAdapter</code> with <code>@EnableWebSecurity</code> and enable OAuth 2.0 login through <code>httpSecurity.oauth2Login()</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 2. OAuth2 Login Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.authorizeRequests(authorize -&gt; authorize
				.anyRequest().authenticated()
			)
			.oauth2Login(withDefaults());
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class OAuth2LoginSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
            oauth2Login { }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2login-completely-override-autoconfiguration"><a class="anchor" href="#oauth2login-completely-override-autoconfiguration"></a>Completely Override the Auto-configuration</h5>
<div class="paragraph">
<p>The following example shows how to completely override the auto-configuration by registering a <code>ClientRegistrationRepository</code> <code>@Bean</code> and providing a <code>WebSecurityConfigurerAdapter</code>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 3. Overriding the auto-configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class OAuth2LoginConfig {

	@EnableWebSecurity
	public static class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

		@Override
		protected void configure(HttpSecurity http) throws Exception {
			http
				.authorizeRequests(authorize -&gt; authorize
					.anyRequest().authenticated()
				)
				.oauth2Login(withDefaults());
		}
	}

	@Bean
	public ClientRegistrationRepository clientRegistrationRepository() {
		return new InMemoryClientRegistrationRepository(this.googleClientRegistration());
	}

	private ClientRegistration googleClientRegistration() {
		return ClientRegistration.withRegistrationId("google")
			.clientId("google-client-id")
			.clientSecret("google-client-secret")
			.clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
			.authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
			.redirectUri("{baseUrl}/login/oauth2/code/{registrationId}")
			.scope("openid", "profile", "email", "address", "phone")
			.authorizationUri("https://accounts.google.com/o/oauth2/v2/auth")
			.tokenUri("https://www.googleapis.com/oauth2/v4/token")
			.userInfoUri("https://www.googleapis.com/oauth2/v3/userinfo")
			.userNameAttributeName(IdTokenClaimNames.SUB)
			.jwkSetUri("https://www.googleapis.com/oauth2/v3/certs")
			.clientName("Google")
			.build();
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
class OAuth2LoginConfig {

    @EnableWebSecurity
    class OAuth2LoginSecurityConfig: WebSecurityConfigurerAdapter() {

        override fun configure(http: HttpSecurity) {
            http {
                authorizeRequests {
                    authorize(anyRequest, authenticated)
                }
                oauth2Login { }
            }
        }
    }

    @Bean
    fun clientRegistrationRepository(): ClientRegistrationRepository {
        return InMemoryClientRegistrationRepository(googleClientRegistration())
    }

    private fun googleClientRegistration(): ClientRegistration {
        return ClientRegistration.withRegistrationId("google")
                .clientId("google-client-id")
                .clientSecret("google-client-secret")
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .redirectUri("{baseUrl}/login/oauth2/code/{registrationId}")
                .scope("openid", "profile", "email", "address", "phone")
                .authorizationUri("https://accounts.google.com/o/oauth2/v2/auth")
                .tokenUri("https://www.googleapis.com/oauth2/v4/token")
                .userInfoUri("https://www.googleapis.com/oauth2/v3/userinfo")
                .userNameAttributeName(IdTokenClaimNames.SUB)
                .jwkSetUri("https://www.googleapis.com/oauth2/v3/certs")
                .clientName("Google")
                .build()
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2login-javaconfig-wo-boot"><a class="anchor" href="#oauth2login-javaconfig-wo-boot"></a>Java Configuration without Spring Boot 2.x</h4>
<div class="paragraph">
<p>If you are not able to use Spring Boot 2.x and would like to configure one of the pre-defined providers in <code>CommonOAuth2Provider</code> (for example, Google), apply the following configuration:</p>
</div>
<div class="exampleblock">
<div class="title">Example 4. OAuth2 Login Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class OAuth2LoginConfig {

	@EnableWebSecurity
	public static class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

		@Override
		protected void configure(HttpSecurity http) throws Exception {
			http
				.authorizeRequests(authorize -&gt; authorize
					.anyRequest().authenticated()
				)
				.oauth2Login(withDefaults());
		}
	}

	@Bean
	public ClientRegistrationRepository clientRegistrationRepository() {
		return new InMemoryClientRegistrationRepository(this.googleClientRegistration());
	}

	@Bean
	public OAuth2AuthorizedClientService authorizedClientService(
			ClientRegistrationRepository clientRegistrationRepository) {
		return new InMemoryOAuth2AuthorizedClientService(clientRegistrationRepository);
	}

	@Bean
	public OAuth2AuthorizedClientRepository authorizedClientRepository(
			OAuth2AuthorizedClientService authorizedClientService) {
		return new AuthenticatedPrincipalOAuth2AuthorizedClientRepository(authorizedClientService);
	}

	private ClientRegistration googleClientRegistration() {
		return CommonOAuth2Provider.GOOGLE.getBuilder("google")
			.clientId("google-client-id")
			.clientSecret("google-client-secret")
			.build();
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http auto-config="true"&gt;
	&lt;intercept-url pattern="/**" access="authenticated"/&gt;
	&lt;oauth2-login authorized-client-repository-ref="authorizedClientRepository"/&gt;
&lt;/http&gt;

&lt;client-registrations&gt;
	&lt;client-registration registration-id="google"
						 client-id="google-client-id"
						 client-secret="google-client-secret"
						 provider-id="google"/&gt;
&lt;/client-registrations&gt;

&lt;b:bean id="authorizedClientService"
		class="org.springframework.security.oauth2.client.InMemoryOAuth2AuthorizedClientService"
		autowire="constructor"/&gt;

&lt;b:bean id="authorizedClientRepository"
		class="org.springframework.security.oauth2.client.web.AuthenticatedPrincipalOAuth2AuthorizedClientRepository"&gt;
	&lt;b:constructor-arg ref="authorizedClientService"/&gt;
&lt;/b:bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2login-advanced"><a class="anchor" href="#oauth2login-advanced"></a>Advanced Configuration</h4>
<div class="paragraph">
<p><code>HttpSecurity.oauth2Login()</code> provides a number of configuration options for customizing OAuth 2.0 Login.
The main configuration options are grouped into their protocol endpoint counterparts.</p>
</div>
<div class="paragraph">
<p>For example, <code>oauth2Login().authorizationEndpoint()</code> allows configuring the <em>Authorization Endpoint</em>, whereas <code>oauth2Login().tokenEndpoint()</code> allows configuring the <em>Token Endpoint</em>.</p>
</div>
<div class="paragraph">
<p>The following code shows an example:</p>
</div>
<div class="exampleblock">
<div class="title">Example 5. Advanced OAuth2 Login Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.oauth2Login(oauth2 -&gt; oauth2
			    .authorizationEndpoint(authorization -&gt; authorization
			            ...
			    )
			    .redirectionEndpoint(redirection -&gt; redirection
			            ...
			    )
			    .tokenEndpoint(token -&gt; token
			            ...
			    )
			    .userInfoEndpoint(userInfo -&gt; userInfo
			            ...
			    )
			);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class OAuth2LoginSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Login {
                authorizationEndpoint {
                    ...
                }
                redirectionEndpoint {
                    ...
                }
                tokenEndpoint {
                    ...
                }
                userInfoEndpoint {
                    ...
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The main goal of the <code>oauth2Login()</code> DSL was to closely align with the naming, as defined in the specifications.</p>
</div>
<div class="paragraph">
<p>The OAuth 2.0 Authorization Framework defines the <a href="https://tools.ietf.org/html/rfc6749#section-3">Protocol Endpoints</a> as follows:</p>
</div>
<div class="paragraph">
<p>The authorization process utilizes two authorization server endpoints (HTTP resources):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Authorization Endpoint: Used by the client to obtain authorization from the resource owner via user-agent redirection.</p>
</li>
<li>
<p>Token Endpoint: Used by the client to exchange an authorization grant for an access token, typically with client authentication.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As well as one client endpoint:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Redirection Endpoint: Used by the authorization server to return responses containing authorization credentials to the client via the resource owner user-agent.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The OpenID Connect Core 1.0 specification defines the <a href="https://openid.net/specs/openid-connect-core-1_0.html#UserInfo">UserInfo Endpoint</a> as follows:</p>
</div>
<div class="paragraph">
<p>The UserInfo Endpoint is an OAuth 2.0 Protected Resource that returns claims about the authenticated end-user.
To obtain the requested claims about the end-user, the client makes a request to the UserInfo Endpoint by using an access token obtained through OpenID Connect Authentication.
These claims are normally represented by a JSON object that contains a collection of name-value pairs for the claims.</p>
</div>
<div class="paragraph">
<p>The following code shows the complete configuration options available for the <code>oauth2Login()</code> DSL:</p>
</div>
<div class="exampleblock">
<div class="title">Example 6. OAuth2 Login Configuration Options</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.oauth2Login(oauth2 -&gt; oauth2
			    .clientRegistrationRepository(this.clientRegistrationRepository())
			    .authorizedClientRepository(this.authorizedClientRepository())
			    .authorizedClientService(this.authorizedClientService())
			    .loginPage("/login")
			    .authorizationEndpoint(authorization -&gt; authorization
			        .baseUri(this.authorizationRequestBaseUri())
			        .authorizationRequestRepository(this.authorizationRequestRepository())
			        .authorizationRequestResolver(this.authorizationRequestResolver())
			    )
			    .redirectionEndpoint(redirection -&gt; redirection
			        .baseUri(this.authorizationResponseBaseUri())
			    )
			    .tokenEndpoint(token -&gt; token
			        .accessTokenResponseClient(this.accessTokenResponseClient())
			    )
			    .userInfoEndpoint(userInfo -&gt; userInfo
			        .userAuthoritiesMapper(this.userAuthoritiesMapper())
			        .userService(this.oauth2UserService())
			        .oidcUserService(this.oidcUserService())
			    )
			);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class OAuth2LoginSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Login {
                clientRegistrationRepository = clientRegistrationRepository()
                authorizedClientRepository = authorizedClientRepository()
                authorizedClientService = authorizedClientService()
                loginPage = "/login"
                authorizationEndpoint {
                    baseUri = authorizationRequestBaseUri()
                    authorizationRequestRepository = authorizationRequestRepository()
                    authorizationRequestResolver = authorizationRequestResolver()
                }
                redirectionEndpoint {
                    baseUri = authorizationResponseBaseUri()
                }
                tokenEndpoint {
                    accessTokenResponseClient = accessTokenResponseClient()
                }
                userInfoEndpoint {
                    userAuthoritiesMapper = userAuthoritiesMapper()
                    userService = oauth2UserService()
                    oidcUserService = oidcUserService()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In addition to the <code>oauth2Login()</code> DSL, XML configuration is also supported.</p>
</div>
<div class="paragraph">
<p>The following code shows the complete configuration options available in the <a href="#nsa-oauth2-login">security namespace</a>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 7. OAuth2 Login XML Configuration Options</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;oauth2-login client-registration-repository-ref="clientRegistrationRepository"
				  authorized-client-repository-ref="authorizedClientRepository"
				  authorized-client-service-ref="authorizedClientService"
				  authorization-request-repository-ref="authorizationRequestRepository"
				  authorization-request-resolver-ref="authorizationRequestResolver"
				  access-token-response-client-ref="accessTokenResponseClient"
				  user-authorities-mapper-ref="userAuthoritiesMapper"
				  user-service-ref="oauth2UserService"
				  oidc-user-service-ref="oidcUserService"
				  login-processing-url="/login/oauth2/code/*"
				  login-page="/login"
				  authentication-success-handler-ref="authenticationSuccessHandler"
				  authentication-failure-handler-ref="authenticationFailureHandler"
				  jwt-decoder-factory-ref="jwtDecoderFactory"/&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following sections go into more detail on each of the configuration options available:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2login-advanced-login-page">OAuth 2.0 Login Page</a></p>
</li>
<li>
<p><a href="#oauth2login-advanced-redirection-endpoint">Redirection Endpoint</a></p>
</li>
<li>
<p><a href="#oauth2login-advanced-userinfo-endpoint">UserInfo Endpoint</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="oauth2login-advanced-login-page"><a class="anchor" href="#oauth2login-advanced-login-page"></a>OAuth 2.0 Login Page</h5>
<div class="paragraph">
<p>By default, the OAuth 2.0 Login Page is auto-generated by the <code>DefaultLoginPageGeneratingFilter</code>.
The default login page shows each configured OAuth Client with its <code>ClientRegistration.clientName</code> as a link, which is capable of initiating the Authorization Request (or OAuth 2.0 Login).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In order for <code>DefaultLoginPageGeneratingFilter</code> to show links for configured OAuth Clients, the registered <code>ClientRegistrationRepository</code> needs to also implement <code>Iterable&lt;ClientRegistration&gt;</code>.
See <code>InMemoryClientRegistrationRepository</code> for reference.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The link&#8217;s destination for each OAuth Client defaults to the following:</p>
</div>
<div class="paragraph">
<p><code>OAuth2AuthorizationRequestRedirectFilter.DEFAULT_AUTHORIZATION_REQUEST_BASE_URI + "/{registrationId}"</code></p>
</div>
<div class="paragraph">
<p>The following line shows an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;a href="/oauth2/authorization/google"&gt;Google&lt;/a&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>To override the default login page, configure <code>oauth2Login().loginPage()</code> and (optionally) <code>oauth2Login().authorizationEndpoint().baseUri()</code>.</p>
</div>
<div class="paragraph">
<p>The following listing shows an example:</p>
</div>
<div class="exampleblock">
<div class="title">Example 8. OAuth2 Login Page Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.oauth2Login(oauth2 -&gt; oauth2
			    .loginPage("/login/oauth2")
			    ...
			    .authorizationEndpoint(authorization -&gt; authorization
			        .baseUri("/login/oauth2/authorization")
			        ...
			    )
			);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class OAuth2LoginSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Login {
                loginPage = "/login/oauth2"
                authorizationEndpoint {
                    baseUri = "/login/oauth2/authorization"
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;oauth2-login login-page="/login/oauth2"
				  ...
    /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
You need to provide a <code>@Controller</code> with a <code>@RequestMapping("/login/oauth2")</code> that is capable of rendering the custom login page.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>As noted earlier, configuring <code>oauth2Login().authorizationEndpoint().baseUri()</code> is optional.
However, if you choose to customize it, ensure the link to each OAuth Client matches the <code>authorizationEndpoint().baseUri()</code>.</p>
</div>
<div class="paragraph">
<p>The following line shows an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;a href="/login/oauth2/authorization/google"&gt;Google&lt;/a&gt;</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="oauth2login-advanced-redirection-endpoint"><a class="anchor" href="#oauth2login-advanced-redirection-endpoint"></a>Redirection Endpoint</h5>
<div class="paragraph">
<p>The Redirection Endpoint is used by the Authorization Server for returning the Authorization Response (which contains the authorization credentials) to the client via the Resource Owner user-agent.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
OAuth 2.0 Login leverages the Authorization Code Grant.
Therefore, the authorization credential is the authorization code.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The default Authorization Response <code>baseUri</code> (redirection endpoint) is <code><strong>/login/oauth2/code/</strong>*</code>, which is defined in <code>OAuth2LoginAuthenticationFilter.DEFAULT_FILTER_PROCESSES_URI</code>.</p>
</div>
<div class="paragraph">
<p>If you would like to customize the Authorization Response <code>baseUri</code>, configure it as shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="title">Example 9. Redirection Endpoint Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.oauth2Login(oauth2 -&gt; oauth2
			    .redirectionEndpoint(redirection -&gt; redirection
			        .baseUri("/login/oauth2/callback/*")
			        ...
			    )
			);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class OAuth2LoginSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Login {
                redirectionEndpoint {
                    baseUri = "/login/oauth2/callback/*"
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;oauth2-login login-processing-url="/login/oauth2/callback/*"
				  ...
    /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You also need to ensure the <code>ClientRegistration.redirectUri</code> matches the custom Authorization Response <code>baseUri</code>.</p>
</div>
<div class="paragraph">
<p>The following listing shows an example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">return CommonOAuth2Provider.GOOGLE.getBuilder("google")
	.clientId("google-client-id")
	.clientSecret("google-client-secret")
	.redirectUri("{baseUrl}/login/oauth2/callback/{registrationId}")
	.build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">return CommonOAuth2Provider.GOOGLE.getBuilder("google")
    .clientId("google-client-id")
    .clientSecret("google-client-secret")
    .redirectUri("{baseUrl}/login/oauth2/callback/{registrationId}")
    .build()</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="oauth2login-advanced-userinfo-endpoint"><a class="anchor" href="#oauth2login-advanced-userinfo-endpoint"></a>UserInfo Endpoint</h5>
<div class="paragraph">
<p>The UserInfo Endpoint includes a number of configuration options, as described in the following sub-sections:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2login-advanced-map-authorities">Mapping User Authorities</a></p>
</li>
<li>
<p><a href="#oauth2login-advanced-oauth2-user-service">OAuth 2.0 UserService</a></p>
</li>
<li>
<p><a href="#oauth2login-advanced-oidc-user-service">OpenID Connect 1.0 UserService</a></p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="oauth2login-advanced-map-authorities"><a class="anchor" href="#oauth2login-advanced-map-authorities"></a>Mapping User Authorities</h6>
<div class="paragraph">
<p>After the user successfully authenticates with the OAuth 2.0 Provider, the <code>OAuth2User.getAuthorities()</code> (or <code>OidcUser.getAuthorities()</code>) may be mapped to a new set of <code>GrantedAuthority</code> instances, which will be supplied to <code>OAuth2AuthenticationToken</code> when completing the authentication.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>OAuth2AuthenticationToken.getAuthorities()</code> is used for authorizing requests, such as in <code>hasRole('USER')</code> or <code>hasRole('ADMIN')</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There are a couple of options to choose from when mapping user authorities:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2login-advanced-map-authorities-grantedauthoritiesmapper">Using a GrantedAuthoritiesMapper</a></p>
</li>
<li>
<p><a href="#oauth2login-advanced-map-authorities-oauth2userservice">Delegation-based strategy with OAuth2UserService</a></p>
</li>
</ul>
</div>
<div class="sect6">
<h7 id="oauth2login-advanced-map-authorities-grantedauthoritiesmapper"><a class="anchor" href="#oauth2login-advanced-map-authorities-grantedauthoritiesmapper"></a>Using a GrantedAuthoritiesMapper</h7>
<div class="paragraph">
<p>Provide an implementation of <code>GrantedAuthoritiesMapper</code> and configure it as shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="title">Example 10. Granted Authorities Mapper Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.oauth2Login(oauth2 -&gt; oauth2
			    .userInfoEndpoint(userInfo -&gt; userInfo
			        .userAuthoritiesMapper(this.userAuthoritiesMapper())
			        ...
			    )
			);
	}

	private GrantedAuthoritiesMapper userAuthoritiesMapper() {
		return (authorities) -&gt; {
			Set&lt;GrantedAuthority&gt; mappedAuthorities = new HashSet&lt;&gt;();

			authorities.forEach(authority -&gt; {
				if (OidcUserAuthority.class.isInstance(authority)) {
					OidcUserAuthority oidcUserAuthority = (OidcUserAuthority)authority;

					OidcIdToken idToken = oidcUserAuthority.getIdToken();
					OidcUserInfo userInfo = oidcUserAuthority.getUserInfo();

					// Map the claims found in idToken and/or userInfo
					// to one or more GrantedAuthority's and add it to mappedAuthorities

				} else if (OAuth2UserAuthority.class.isInstance(authority)) {
					OAuth2UserAuthority oauth2UserAuthority = (OAuth2UserAuthority)authority;

					Map&lt;String, Object&gt; userAttributes = oauth2UserAuthority.getAttributes();

					// Map the attributes found in userAttributes
					// to one or more GrantedAuthority's and add it to mappedAuthorities

				}
			});

			return mappedAuthorities;
		};
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class OAuth2LoginSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Login {
                userInfoEndpoint {
                    userAuthoritiesMapper = userAuthoritiesMapper()
                }
            }
        }
    }

    private fun userAuthoritiesMapper(): GrantedAuthoritiesMapper = GrantedAuthoritiesMapper { authorities: Collection&lt;GrantedAuthority&gt; -&gt;
        val mappedAuthorities = emptySet&lt;GrantedAuthority&gt;()

        authorities.forEach { authority -&gt;
            if (authority is OidcUserAuthority) {
                val idToken = authority.idToken
                val userInfo = authority.userInfo
                // Map the claims found in idToken and/or userInfo
                // to one or more GrantedAuthority's and add it to mappedAuthorities
            } else if (authority is OAuth2UserAuthority) {
                val userAttributes = authority.attributes
                // Map the attributes found in userAttributes
                // to one or more GrantedAuthority's and add it to mappedAuthorities
            }
        }

        mappedAuthorities
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;oauth2-login user-authorities-mapper-ref="userAuthoritiesMapper"
				  ...
    /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you may register a <code>GrantedAuthoritiesMapper</code> <code>@Bean</code> to have it automatically applied to the configuration, as shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="title">Example 11. Granted Authorities Mapper Bean Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
		    .oauth2Login(withDefaults());
	}

	@Bean
	public GrantedAuthoritiesMapper userAuthoritiesMapper() {
		...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class OAuth2LoginSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Login { }
        }
    }

    @Bean
    fun userAuthoritiesMapper(): GrantedAuthoritiesMapper {
        ...
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect6">
<h7 id="oauth2login-advanced-map-authorities-oauth2userservice"><a class="anchor" href="#oauth2login-advanced-map-authorities-oauth2userservice"></a>Delegation-based strategy with OAuth2UserService</h7>
<div class="paragraph">
<p>This strategy is advanced compared to using a <code>GrantedAuthoritiesMapper</code>, however, it&#8217;s also more flexible as it gives you access to the <code>OAuth2UserRequest</code> and <code>OAuth2User</code> (when using an OAuth 2.0 UserService) or <code>OidcUserRequest</code> and <code>OidcUser</code> (when using an OpenID Connect 1.0 UserService).</p>
</div>
<div class="paragraph">
<p>The <code>OAuth2UserRequest</code> (and <code>OidcUserRequest</code>) provides you access to the associated <code>OAuth2AccessToken</code>, which is very useful in the cases where the <em>delegator</em> needs to fetch authority information from a protected resource before it can map the custom authorities for the user.</p>
</div>
<div class="paragraph">
<p>The following example shows how to implement and configure a delegation-based strategy using an OpenID Connect 1.0 UserService:</p>
</div>
<div class="exampleblock">
<div class="title">Example 12. OAuth2UserService Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.oauth2Login(oauth2 -&gt; oauth2
			    .userInfoEndpoint(userInfo -&gt; userInfo
			        .oidcUserService(this.oidcUserService())
			        ...
			    )
			);
	}

	private OAuth2UserService&lt;OidcUserRequest, OidcUser&gt; oidcUserService() {
		final OidcUserService delegate = new OidcUserService();

		return (userRequest) -&gt; {
			// Delegate to the default implementation for loading a user
			OidcUser oidcUser = delegate.loadUser(userRequest);

			OAuth2AccessToken accessToken = userRequest.getAccessToken();
			Set&lt;GrantedAuthority&gt; mappedAuthorities = new HashSet&lt;&gt;();

			// TODO
			// 1) Fetch the authority information from the protected resource using accessToken
			// 2) Map the authority information to one or more GrantedAuthority's and add it to mappedAuthorities

			// 3) Create a copy of oidcUser but use the mappedAuthorities instead
			oidcUser = new DefaultOidcUser(mappedAuthorities, oidcUser.getIdToken(), oidcUser.getUserInfo());

			return oidcUser;
		};
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class OAuth2LoginSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Login {
                userInfoEndpoint {
                    oidcUserService = oidcUserService()
                }
            }
        }
    }

    @Bean
    fun oidcUserService(): OAuth2UserService&lt;OidcUserRequest, OidcUser&gt; {
        val delegate = OidcUserService()

        return OAuth2UserService { userRequest -&gt;
            // Delegate to the default implementation for loading a user
            var oidcUser = delegate.loadUser(userRequest)

            val accessToken = userRequest.accessToken
            val mappedAuthorities = HashSet&lt;GrantedAuthority&gt;()

            // TODO
            // 1) Fetch the authority information from the protected resource using accessToken
            // 2) Map the authority information to one or more GrantedAuthority's and add it to mappedAuthorities
            // 3) Create a copy of oidcUser but use the mappedAuthorities instead
            oidcUser = DefaultOidcUser(mappedAuthorities, oidcUser.idToken, oidcUser.userInfo)

            oidcUser
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;oauth2-login oidc-user-service-ref="oidcUserService"
				  ...
    /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="oauth2login-advanced-oauth2-user-service"><a class="anchor" href="#oauth2login-advanced-oauth2-user-service"></a>OAuth 2.0 UserService</h6>
<div class="paragraph">
<p><code>DefaultOAuth2UserService</code> is an implementation of an <code>OAuth2UserService</code> that supports standard OAuth 2.0 Provider&#8217;s.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>OAuth2UserService</code> obtains the user attributes of the end-user (the resource owner) from the UserInfo Endpoint (by using the access token granted to the client during the authorization flow) and returns an <code>AuthenticatedPrincipal</code> in the form of an <code>OAuth2User</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>DefaultOAuth2UserService</code> uses a <code>RestOperations</code> when requesting the user attributes at the UserInfo Endpoint.</p>
</div>
<div class="paragraph">
<p>If you need to customize the pre-processing of the UserInfo Request, you can provide <code>DefaultOAuth2UserService.setRequestEntityConverter()</code> with a custom <code>Converter&lt;OAuth2UserRequest, RequestEntity&lt;?&gt;&gt;</code>.
The default implementation <code>OAuth2UserRequestEntityConverter</code> builds a <code>RequestEntity</code> representation of a UserInfo Request that sets the <code>OAuth2AccessToken</code> in the <code>Authorization</code> header by default.</p>
</div>
<div class="paragraph">
<p>On the other end, if you need to customize the post-handling of the UserInfo Response, you will need to provide <code>DefaultOAuth2UserService.setRestOperations()</code> with a custom configured <code>RestOperations</code>.
The default <code>RestOperations</code> is configured as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RestTemplate restTemplate = new RestTemplate();
restTemplate.setErrorHandler(new OAuth2ErrorResponseErrorHandler());</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>OAuth2ErrorResponseErrorHandler</code> is a <code>ResponseErrorHandler</code> that can handle an OAuth 2.0 Error (400 Bad Request).
It uses an <code>OAuth2ErrorHttpMessageConverter</code> for converting the OAuth 2.0 Error parameters to an <code>OAuth2Error</code>.</p>
</div>
<div class="paragraph">
<p>Whether you customize <code>DefaultOAuth2UserService</code> or provide your own implementation of <code>OAuth2UserService</code>, you&#8217;ll need to configure it as shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.oauth2Login(oauth2 -&gt; oauth2
			    .userInfoEndpoint(userInfo -&gt; userInfo
			        .userService(this.oauth2UserService())
			        ...
			    )
			);
	}

	private OAuth2UserService&lt;OAuth2UserRequest, OAuth2User&gt; oauth2UserService() {
		...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class OAuth2LoginSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Login {
                userInfoEndpoint {
                    userService = oauth2UserService()
                    // ...
                }
            }
        }
    }

    private fun oauth2UserService(): OAuth2UserService&lt;OAuth2UserRequest, OAuth2User&gt; {
        // ...
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="oauth2login-advanced-oidc-user-service"><a class="anchor" href="#oauth2login-advanced-oidc-user-service"></a>OpenID Connect 1.0 UserService</h6>
<div class="paragraph">
<p><code>OidcUserService</code> is an implementation of an <code>OAuth2UserService</code> that supports OpenID Connect 1.0 Provider&#8217;s.</p>
</div>
<div class="paragraph">
<p>The <code>OidcUserService</code> leverages the <code>DefaultOAuth2UserService</code> when requesting the user attributes at the UserInfo Endpoint.</p>
</div>
<div class="paragraph">
<p>If you need to customize the pre-processing of the UserInfo Request and/or the post-handling of the UserInfo Response, you will need to provide <code>OidcUserService.setOauth2UserService()</code> with a custom configured <code>DefaultOAuth2UserService</code>.</p>
</div>
<div class="paragraph">
<p>Whether you customize <code>OidcUserService</code> or provide your own implementation of <code>OAuth2UserService</code> for OpenID Connect 1.0 Provider&#8217;s, you&#8217;ll need to configure it as shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.oauth2Login(oauth2 -&gt; oauth2
				.userInfoEndpoint(userInfo -&gt; userInfo
				    .oidcUserService(this.oidcUserService())
				    ...
			    )
			);
	}

	private OAuth2UserService&lt;OidcUserRequest, OidcUser&gt; oidcUserService() {
		...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class OAuth2LoginSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Login {
                userInfoEndpoint {
                    oidcUserService = oidcUserService()
                    // ...
                }
            }
        }
    }

    private fun oidcUserService(): OAuth2UserService&lt;OidcUserRequest, OidcUser&gt; {
        // ...
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2login-advanced-idtoken-verify"><a class="anchor" href="#oauth2login-advanced-idtoken-verify"></a>ID Token Signature Verification</h5>
<div class="paragraph">
<p>OpenID Connect 1.0 Authentication introduces the <a href="https://openid.net/specs/openid-connect-core-1_0.html#IDToken">ID Token</a>, which is a security token that contains Claims about the Authentication of an End-User by an Authorization Server when used by a Client.</p>
</div>
<div class="paragraph">
<p>The ID Token is represented as a <a href="https://tools.ietf.org/html/rfc7519">JSON Web Token</a> (JWT) and MUST be signed using <a href="https://tools.ietf.org/html/rfc7515">JSON Web Signature</a> (JWS).</p>
</div>
<div class="paragraph">
<p>The <code>OidcIdTokenDecoderFactory</code> provides a <code>JwtDecoder</code> used for <code>OidcIdToken</code> signature verification. The default algorithm is <code>RS256</code> but may be different when assigned during client registration.
For these cases, a resolver may be configured to return the expected JWS algorithm assigned for a specific client.</p>
</div>
<div class="paragraph">
<p>The JWS algorithm resolver is a <code>Function</code> that accepts a <code>ClientRegistration</code> and returns the expected <code>JwsAlgorithm</code> for the client, eg. <code>SignatureAlgorithm.RS256</code> or <code>MacAlgorithm.HS256</code></p>
</div>
<div class="paragraph">
<p>The following code shows how to configure the <code>OidcIdTokenDecoderFactory</code> <code>@Bean</code> to default to <code>MacAlgorithm.HS256</code> for all <code>ClientRegistration</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public JwtDecoderFactory&lt;ClientRegistration&gt; idTokenDecoderFactory() {
	OidcIdTokenDecoderFactory idTokenDecoderFactory = new OidcIdTokenDecoderFactory();
	idTokenDecoderFactory.setJwsAlgorithmResolver(clientRegistration -&gt; MacAlgorithm.HS256);
	return idTokenDecoderFactory;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun idTokenDecoderFactory(): JwtDecoderFactory&lt;ClientRegistration?&gt; {
    val idTokenDecoderFactory = OidcIdTokenDecoderFactory()
    idTokenDecoderFactory.setJwsAlgorithmResolver { MacAlgorithm.HS256 }
    return idTokenDecoderFactory
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For MAC based algorithms such as <code>HS256</code>, <code>HS384</code> or <code>HS512</code>, the <code>client-secret</code> corresponding to the <code>client-id</code> is used as the symmetric key for signature verification.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If more than one <code>ClientRegistration</code> is configured for OpenID Connect 1.0 Authentication, the JWS algorithm resolver may evaluate the provided <code>ClientRegistration</code> to determine which algorithm to return.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="oauth2login-advanced-oidc-logout"><a class="anchor" href="#oauth2login-advanced-oidc-logout"></a>OpenID Connect 1.0 Logout</h5>
<div class="paragraph">
<p>OpenID Connect Session Management 1.0 allows the ability to log out the End-User at the Provider using the Client.
One of the strategies available is <a href="https://openid.net/specs/openid-connect-session-1_0.html#RPLogout">RP-Initiated Logout</a>.</p>
</div>
<div class="paragraph">
<p>If the OpenID Provider supports both Session Management and <a href="https://openid.net/specs/openid-connect-discovery-1_0.html">Discovery</a>, the client may obtain the <code>end_session_endpoint</code> <code>URL</code> from the OpenID Provider&#8217;s <a href="https://openid.net/specs/openid-connect-session-1_0.html#OPMetadata">Discovery Metadata</a>.
This can be achieved by configuring the <code>ClientRegistration</code> with the <code>issuer-uri</code>, as in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-secret: okta-client-secret
            ...
        provider:
          okta:
            issuer-uri: https://dev-1234.oktapreview.com</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;and the <code>OidcClientInitiatedLogoutSuccessHandler</code>, which implements RP-Initiated Logout, may be configured as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

	@Autowired
	private ClientRegistrationRepository clientRegistrationRepository;

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.authorizeRequests(authorize -&gt; authorize
				.anyRequest().authenticated()
			)
			.oauth2Login(withDefaults())
			.logout(logout -&gt; logout
				.logoutSuccessHandler(oidcLogoutSuccessHandler())
			);
	}

	private LogoutSuccessHandler oidcLogoutSuccessHandler() {
		OidcClientInitiatedLogoutSuccessHandler oidcLogoutSuccessHandler =
				new OidcClientInitiatedLogoutSuccessHandler(this.clientRegistrationRepository);

		// Sets the location that the End-User's User Agent will be redirected to
		// after the logout has been performed at the Provider
		oidcLogoutSuccessHandler.setPostLogoutRedirectUri("{baseUrl}");

		return oidcLogoutSuccessHandler;
	}
}

NOTE: `OidcClientInitiatedLogoutSuccessHandler` supports the `{baseUrl}` placeholder.
If used, the application's base URL, like `https://app.example.org`, will replace it at request time.</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class OAuth2LoginSecurityConfig : WebSecurityConfigurerAdapter() {
    @Autowired
    private lateinit var clientRegistrationRepository: ClientRegistrationRepository

    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
            oauth2Login { }
            logout {
                logoutSuccessHandler = oidcLogoutSuccessHandler()
            }
        }
    }

    private fun oidcLogoutSuccessHandler(): LogoutSuccessHandler {
        val oidcLogoutSuccessHandler = OidcClientInitiatedLogoutSuccessHandler(clientRegistrationRepository)

        // Sets the location that the End-User's User Agent will be redirected to
        // after the logout has been performed at the Provider
        oidcLogoutSuccessHandler.setPostLogoutRedirectUri("{baseUrl}")
        return oidcLogoutSuccessHandler
    }
}

NOTE: `OidcClientInitiatedLogoutSuccessHandler` supports the `{baseUrl}` placeholder.
If used, the application's base URL, like `https://app.example.org`, will replace it at request time.</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="oauth2client"><a class="anchor" href="#oauth2client"></a>OAuth 2.0 Client</h3>
<div class="paragraph">
<p>The OAuth 2.0 Client features provide support for the Client role as defined in the <a href="https://tools.ietf.org/html/rfc6749#section-1.1">OAuth 2.0 Authorization Framework</a>.</p>
</div>
<div class="paragraph">
<p>At a high-level, the core features available are:</p>
</div>
<div class="ulist">
<div class="title">Authorization Grant support</div>
<ul>
<li>
<p><a href="https://tools.ietf.org/html/rfc6749#section-1.3.1">Authorization Code</a></p>
</li>
<li>
<p><a href="https://tools.ietf.org/html/rfc6749#section-6">Refresh Token</a></p>
</li>
<li>
<p><a href="https://tools.ietf.org/html/rfc6749#section-1.3.4">Client Credentials</a></p>
</li>
<li>
<p><a href="https://tools.ietf.org/html/rfc6749#section-1.3.3">Resource Owner Password Credentials</a></p>
</li>
<li>
<p><a href="https://datatracker.ietf.org/doc/html/rfc7523#section-2.1">JWT Bearer</a></p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Client Authentication support</div>
<ul>
<li>
<p><a href="https://datatracker.ietf.org/doc/html/rfc7523#section-2.2">JWT Bearer</a></p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">HTTP Client support</div>
<ul>
<li>
<p><a href="#oauth2Client-webclient-servlet"><code>WebClient</code> integration for Servlet Environments</a> (for requesting protected resources)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>HttpSecurity.oauth2Client()</code> DSL provides a number of configuration options for customizing the core components used by OAuth 2.0 Client.
In addition, <code>HttpSecurity.oauth2Client().authorizationCodeGrant()</code> enables the customization of the Authorization Code grant.</p>
</div>
<div class="paragraph">
<p>The following code shows the complete configuration options provided by the <code>HttpSecurity.oauth2Client()</code> DSL:</p>
</div>
<div class="exampleblock">
<div class="title">Example 13. OAuth2 Client Configuration Options</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class OAuth2ClientSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.oauth2Client(oauth2 -&gt; oauth2
				.clientRegistrationRepository(this.clientRegistrationRepository())
				.authorizedClientRepository(this.authorizedClientRepository())
				.authorizedClientService(this.authorizedClientService())
				.authorizationCodeGrant(codeGrant -&gt; codeGrant
					.authorizationRequestRepository(this.authorizationRequestRepository())
					.authorizationRequestResolver(this.authorizationRequestResolver())
					.accessTokenResponseClient(this.accessTokenResponseClient())
				)
			);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class OAuth2ClientSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Client {
                clientRegistrationRepository = clientRegistrationRepository()
                authorizedClientRepository = authorizedClientRepository()
                authorizedClientService = authorizedClientService()
                authorizationCodeGrant {
                    authorizationRequestRepository = authorizationRequestRepository()
                    authorizationRequestResolver = authorizationRequestResolver()
                    accessTokenResponseClient = accessTokenResponseClient()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In addition to the <code>HttpSecurity.oauth2Client()</code> DSL, XML configuration is also supported.</p>
</div>
<div class="paragraph">
<p>The following code shows the complete configuration options available in the <a href="#nsa-oauth2-client">security namespace</a>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 14. OAuth2 Client XML Configuration Options</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;oauth2-client client-registration-repository-ref="clientRegistrationRepository"
				   authorized-client-repository-ref="authorizedClientRepository"
				   authorized-client-service-ref="authorizedClientService"&gt;
		&lt;authorization-code-grant
				authorization-request-repository-ref="authorizationRequestRepository"
				authorization-request-resolver-ref="authorizationRequestResolver"
				access-token-response-client-ref="accessTokenResponseClient"/&gt;
	&lt;/oauth2-client&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>OAuth2AuthorizedClientManager</code> is responsible for managing the authorization (or re-authorization) of an OAuth 2.0 Client, in collaboration with one or more <code>OAuth2AuthorizedClientProvider</code>(s).</p>
</div>
<div class="paragraph">
<p>The following code shows an example of how to register an <code>OAuth2AuthorizedClientManager</code> <code>@Bean</code> and associate it with an <code>OAuth2AuthorizedClientProvider</code> composite that provides support for the <code>authorization_code</code>, <code>refresh_token</code>, <code>client_credentials</code> and <code>password</code> authorization grant types:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public OAuth2AuthorizedClientManager authorizedClientManager(
		ClientRegistrationRepository clientRegistrationRepository,
		OAuth2AuthorizedClientRepository authorizedClientRepository) {

	OAuth2AuthorizedClientProvider authorizedClientProvider =
			OAuth2AuthorizedClientProviderBuilder.builder()
					.authorizationCode()
					.refreshToken()
					.clientCredentials()
					.password()
					.build();

	DefaultOAuth2AuthorizedClientManager authorizedClientManager =
			new DefaultOAuth2AuthorizedClientManager(
					clientRegistrationRepository, authorizedClientRepository);
	authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

	return authorizedClientManager;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authorizedClientManager(
        clientRegistrationRepository: ClientRegistrationRepository,
        authorizedClientRepository: OAuth2AuthorizedClientRepository): OAuth2AuthorizedClientManager {
    val authorizedClientProvider: OAuth2AuthorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
            .authorizationCode()
            .refreshToken()
            .clientCredentials()
            .password()
            .build()
    val authorizedClientManager = DefaultOAuth2AuthorizedClientManager(
            clientRegistrationRepository, authorizedClientRepository)
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)
    return authorizedClientManager
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following sections will go into more detail on the core components used by OAuth 2.0 Client and the configuration options available:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2Client-core-interface-class">Core Interfaces / Classes</a></p>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2Client-client-registration">ClientRegistration</a></p>
</li>
<li>
<p><a href="#oauth2Client-client-registration-repo">ClientRegistrationRepository</a></p>
</li>
<li>
<p><a href="#oauth2Client-authorized-client">OAuth2AuthorizedClient</a></p>
</li>
<li>
<p><a href="#oauth2Client-authorized-repo-service">OAuth2AuthorizedClientRepository / OAuth2AuthorizedClientService</a></p>
</li>
<li>
<p><a href="#oauth2Client-authorized-manager-provider">OAuth2AuthorizedClientManager / OAuth2AuthorizedClientProvider</a></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="#oauth2Client-auth-grant-support">Authorization Grant Support</a></p>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2Client-auth-code-grant">Authorization Code</a></p>
</li>
<li>
<p><a href="#oauth2Client-refresh-token-grant">Refresh Token</a></p>
</li>
<li>
<p><a href="#oauth2Client-client-creds-grant">Client Credentials</a></p>
</li>
<li>
<p><a href="#oauth2Client-password-grant">Resource Owner Password Credentials</a></p>
</li>
<li>
<p><a href="#oauth2Client-jwt-bearer-grant">JWT Bearer</a></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="#oauth2Client-client-auth-support">Client Authentication Support</a></p>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2Client-jwt-bearer-auth">JWT Bearer</a></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="#oauth2Client-additional-features">Additional Features</a></p>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2Client-registered-authorized-client">Resolving an Authorized Client</a></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="#oauth2Client-webclient-servlet">WebClient integration for Servlet Environments</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="oauth2Client-core-interface-class"><a class="anchor" href="#oauth2Client-core-interface-class"></a>Core Interfaces / Classes</h4>
<div class="sect4">
<h5 id="oauth2Client-client-registration"><a class="anchor" href="#oauth2Client-client-registration"></a>ClientRegistration</h5>
<div class="paragraph">
<p><code>ClientRegistration</code> is a representation of a client registered with an OAuth 2.0 or OpenID Connect 1.0 Provider.</p>
</div>
<div class="paragraph">
<p>A client registration holds information, such as client id, client secret, authorization grant type, redirect URI, scope(s), authorization URI, token URI, and other details.</p>
</div>
<div class="paragraph">
<p><code>ClientRegistration</code> and its properties are defined as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public final class ClientRegistration {
	private String registrationId;	<i class="conum" data-value="1"></i><b>(1)</b>
	private String clientId;	<i class="conum" data-value="2"></i><b>(2)</b>
	private String clientSecret;	<i class="conum" data-value="3"></i><b>(3)</b>
	private ClientAuthenticationMethod clientAuthenticationMethod;	<i class="conum" data-value="4"></i><b>(4)</b>
	private AuthorizationGrantType authorizationGrantType;	<i class="conum" data-value="5"></i><b>(5)</b>
	private String redirectUri;	<i class="conum" data-value="6"></i><b>(6)</b>
	private Set&lt;String&gt; scopes;	<i class="conum" data-value="7"></i><b>(7)</b>
	private ProviderDetails providerDetails;
	private String clientName;	<i class="conum" data-value="8"></i><b>(8)</b>

	public class ProviderDetails {
		private String authorizationUri;	<i class="conum" data-value="9"></i><b>(9)</b>
		private String tokenUri;	<i class="conum" data-value="10"></i><b>(10)</b>
		private UserInfoEndpoint userInfoEndpoint;
		private String jwkSetUri;	<i class="conum" data-value="11"></i><b>(11)</b>
		private String issuerUri;	<i class="conum" data-value="12"></i><b>(12)</b>
        private Map&lt;String, Object&gt; configurationMetadata;  <i class="conum" data-value="13"></i><b>(13)</b>

		public class UserInfoEndpoint {
			private String uri;	<i class="conum" data-value="14"></i><b>(14)</b>
            private AuthenticationMethod authenticationMethod;  <i class="conum" data-value="15"></i><b>(15)</b>
			private String userNameAttributeName;	<i class="conum" data-value="16"></i><b>(16)</b>

		}
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>registrationId</code>: The ID that uniquely identifies the <code>ClientRegistration</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>clientId</code>: The client identifier.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>clientSecret</code>: The client secret.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>clientAuthenticationMethod</code>: The method used to authenticate the Client with the Provider.
The supported values are <strong>client_secret_basic</strong>, <strong>client_secret_post</strong>, <strong>private_key_jwt</strong>, <strong>client_secret_jwt</strong> and <strong>none</strong> <a href="https://tools.ietf.org/html/rfc6749#section-2.1">(public clients)</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td><code>authorizationGrantType</code>: The OAuth 2.0 Authorization Framework defines four <a href="https://tools.ietf.org/html/rfc6749#section-1.3">Authorization Grant</a> types.
The supported values are <code>authorization_code</code>, <code>client_credentials</code>, <code>password</code>, as well as, extension grant type <code>urn:ietf:params:oauth:grant-type:jwt-bearer</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td><code>redirectUri</code>: The client&#8217;s registered redirect URI that the <em>Authorization Server</em> redirects the end-user&#8217;s user-agent
to after the end-user has authenticated and authorized access to the client.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td><code>scopes</code>: The scope(s) requested by the client during the Authorization Request flow, such as openid, email, or profile.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td><code>clientName</code>: A descriptive name used for the client.
The name may be used in certain scenarios, such as when displaying the name of the client in the auto-generated login page.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td><code>authorizationUri</code>: The Authorization Endpoint URI for the Authorization Server.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td><code>tokenUri</code>: The Token Endpoint URI for the Authorization Server.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td><code>jwkSetUri</code>: The URI used to retrieve the <a href="https://tools.ietf.org/html/rfc7517">JSON Web Key (JWK)</a> Set from the Authorization Server,
which contains the cryptographic key(s) used to verify the <a href="https://tools.ietf.org/html/rfc7515">JSON Web Signature (JWS)</a> of the ID Token and optionally the UserInfo Response.</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td><code>issuerUri</code>: Returns the issuer identifier uri for the OpenID Connect 1.0 provider or the OAuth 2.0 Authorization Server.</td>
</tr>
<tr>
<td><i class="conum" data-value="13"></i><b>13</b></td>
<td><code>configurationMetadata</code>: The <a href="https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig">OpenID Provider Configuration Information</a>.
This information will only be available if the Spring Boot 2.x property <code>spring.security.oauth2.client.provider.[providerId].issuerUri</code> is configured.</td>
</tr>
<tr>
<td><i class="conum" data-value="14"></i><b>14</b></td>
<td><code>(userInfoEndpoint)uri</code>: The UserInfo Endpoint URI used to access the claims/attributes of the authenticated end-user.</td>
</tr>
<tr>
<td><i class="conum" data-value="15"></i><b>15</b></td>
<td><code>(userInfoEndpoint)authenticationMethod</code>: The authentication method used when sending the access token to the UserInfo Endpoint.
The supported values are <strong>header</strong>, <strong>form</strong> and <strong>query</strong>.</td>
</tr>
<tr>
<td><i class="conum" data-value="16"></i><b>16</b></td>
<td><code>userNameAttributeName</code>: The name of the attribute returned in the UserInfo Response that references the Name or Identifier of the end-user.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A <code>ClientRegistration</code> can be initially configured using discovery of an OpenID Connect Provider&#8217;s <a href="https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig">Configuration endpoint</a> or an Authorization Server&#8217;s <a href="https://tools.ietf.org/html/rfc8414#section-3">Metadata endpoint</a>.</p>
</div>
<div class="paragraph">
<p><code>ClientRegistrations</code> provides convenience methods for configuring a <code>ClientRegistration</code> in this way, as can be seen in the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ClientRegistration clientRegistration =
    ClientRegistrations.fromIssuerLocation("https://idp.example.com/issuer").build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val clientRegistration = ClientRegistrations.fromIssuerLocation("https://idp.example.com/issuer").build()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The above code will query in series <code><a href="https://idp.example.com/issuer/.well-known/openid-configuration" class="bare">https://idp.example.com/issuer/.well-known/openid-configuration</a></code>, and then <code><a href="https://idp.example.com/.well-known/openid-configuration/issuer" class="bare">https://idp.example.com/.well-known/openid-configuration/issuer</a></code>, and finally <code><a href="https://idp.example.com/.well-known/oauth-authorization-server/issuer" class="bare">https://idp.example.com/.well-known/oauth-authorization-server/issuer</a></code>, stopping at the first to return a 200 response.</p>
</div>
<div class="paragraph">
<p>As an alternative, you can use <code>ClientRegistrations.fromOidcIssuerLocation()</code> to only query the OpenID Connect Provider&#8217;s Configuration endpoint.</p>
</div>
</div>
<div class="sect4">
<h5 id="oauth2Client-client-registration-repo"><a class="anchor" href="#oauth2Client-client-registration-repo"></a>ClientRegistrationRepository</h5>
<div class="paragraph">
<p>The <code>ClientRegistrationRepository</code> serves as a repository for OAuth 2.0 / OpenID Connect 1.0 <code>ClientRegistration</code>(s).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Client registration information is ultimately stored and owned by the associated Authorization Server.
This repository provides the ability to retrieve a sub-set of the primary client registration information, which is stored with the Authorization Server.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Boot 2.x auto-configuration binds each of the properties under <code>spring.security.oauth2.client.registration.<em>[registrationId]</em></code> to an instance of <code>ClientRegistration</code> and then composes each of the <code>ClientRegistration</code> instance(s) within a <code>ClientRegistrationRepository</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The default implementation of <code>ClientRegistrationRepository</code> is <code>InMemoryClientRegistrationRepository</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The auto-configuration also registers the <code>ClientRegistrationRepository</code> as a <code>@Bean</code> in the <code>ApplicationContext</code> so that it is available for dependency-injection, if needed by the application.</p>
</div>
<div class="paragraph">
<p>The following listing shows an example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
public class OAuth2ClientController {

	@Autowired
	private ClientRegistrationRepository clientRegistrationRepository;

	@GetMapping("/")
	public String index() {
		ClientRegistration oktaRegistration =
			this.clientRegistrationRepository.findByRegistrationId("okta");

		...

		return "index";
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Controller
class OAuth2ClientController {

    @Autowired
    private lateinit var clientRegistrationRepository: ClientRegistrationRepository

    @GetMapping("/")
    fun index(): String {
        val oktaRegistration =
                this.clientRegistrationRepository.findByRegistrationId("okta")

        //...

        return "index";
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2Client-authorized-client"><a class="anchor" href="#oauth2Client-authorized-client"></a>OAuth2AuthorizedClient</h5>
<div class="paragraph">
<p><code>OAuth2AuthorizedClient</code> is a representation of an Authorized Client.
A client is considered to be authorized when the end-user (Resource Owner) has granted authorization to the client to access its protected resources.</p>
</div>
<div class="paragraph">
<p><code>OAuth2AuthorizedClient</code> serves the purpose of associating an <code>OAuth2AccessToken</code> (and optional <code>OAuth2RefreshToken</code>) to a <code>ClientRegistration</code> (client) and resource owner, who is the <code>Principal</code> end-user that granted the authorization.</p>
</div>
</div>
<div class="sect4">
<h5 id="oauth2Client-authorized-repo-service"><a class="anchor" href="#oauth2Client-authorized-repo-service"></a>OAuth2AuthorizedClientRepository / OAuth2AuthorizedClientService</h5>
<div class="paragraph">
<p><code>OAuth2AuthorizedClientRepository</code> is responsible for persisting <code>OAuth2AuthorizedClient</code>(s) between web requests.
Whereas, the primary role of <code>OAuth2AuthorizedClientService</code> is to manage <code>OAuth2AuthorizedClient</code>(s) at the application-level.</p>
</div>
<div class="paragraph">
<p>From a developer perspective, the <code>OAuth2AuthorizedClientRepository</code> or <code>OAuth2AuthorizedClientService</code> provides the capability to lookup an <code>OAuth2AccessToken</code> associated with a client so that it may be used to initiate a protected resource request.</p>
</div>
<div class="paragraph">
<p>The following listing shows an example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
public class OAuth2ClientController {

    @Autowired
    private OAuth2AuthorizedClientService authorizedClientService;

    @GetMapping("/")
    public String index(Authentication authentication) {
        OAuth2AuthorizedClient authorizedClient =
            this.authorizedClientService.loadAuthorizedClient("okta", authentication.getName());

        OAuth2AccessToken accessToken = authorizedClient.getAccessToken();

        ...

        return "index";
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Controller
class OAuth2ClientController {

    @Autowired
    private lateinit var authorizedClientService: OAuth2AuthorizedClientService

    @GetMapping("/")
    fun index(authentication: Authentication): String {
        val authorizedClient: OAuth2AuthorizedClient =
            this.authorizedClientService.loadAuthorizedClient("okta", authentication.getName());
        val accessToken = authorizedClient.accessToken

        ...

        return "index";
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Boot 2.x auto-configuration registers an <code>OAuth2AuthorizedClientRepository</code> and/or <code>OAuth2AuthorizedClientService</code> <code>@Bean</code> in the <code>ApplicationContext</code>.
However, the application may choose to override and register a custom <code>OAuth2AuthorizedClientRepository</code> or <code>OAuth2AuthorizedClientService</code> <code>@Bean</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The default implementation of <code>OAuth2AuthorizedClientService</code> is <code>InMemoryOAuth2AuthorizedClientService</code>, which stores <code>OAuth2AuthorizedClient</code>(s) in-memory.</p>
</div>
<div class="paragraph">
<p>Alternatively, the JDBC implementation <code>JdbcOAuth2AuthorizedClientService</code> may be configured for persisting <code>OAuth2AuthorizedClient</code>(s) in a database.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>JdbcOAuth2AuthorizedClientService</code> depends on the table definition described in <a href="#dbschema-oauth2-client">OAuth 2.0 Client Schema</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="oauth2Client-authorized-manager-provider"><a class="anchor" href="#oauth2Client-authorized-manager-provider"></a>OAuth2AuthorizedClientManager / OAuth2AuthorizedClientProvider</h5>
<div class="paragraph">
<p>The <code>OAuth2AuthorizedClientManager</code> is responsible for the overall management of <code>OAuth2AuthorizedClient</code>(s).</p>
</div>
<div class="paragraph">
<p>The primary responsibilities include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Authorizing (or re-authorizing) an OAuth 2.0 Client, using an <code>OAuth2AuthorizedClientProvider</code>.</p>
</li>
<li>
<p>Delegating the persistence of an <code>OAuth2AuthorizedClient</code>, typically using an <code>OAuth2AuthorizedClientService</code> or <code>OAuth2AuthorizedClientRepository</code>.</p>
</li>
<li>
<p>Delegating to an <code>OAuth2AuthorizationSuccessHandler</code> when an OAuth 2.0 Client has been successfully authorized (or re-authorized).</p>
</li>
<li>
<p>Delegating to an <code>OAuth2AuthorizationFailureHandler</code> when an OAuth 2.0 Client fails to authorize (or re-authorize).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>An <code>OAuth2AuthorizedClientProvider</code> implements a strategy for authorizing (or re-authorizing) an OAuth 2.0 Client.
Implementations will typically implement an authorization grant type, eg. <code>authorization_code</code>, <code>client_credentials</code>, etc.</p>
</div>
<div class="paragraph">
<p>The default implementation of <code>OAuth2AuthorizedClientManager</code> is <code>DefaultOAuth2AuthorizedClientManager</code>, which is associated with an <code>OAuth2AuthorizedClientProvider</code> that may support multiple authorization grant types using a delegation-based composite.
The <code>OAuth2AuthorizedClientProviderBuilder</code> may be used to configure and build the delegation-based composite.</p>
</div>
<div class="paragraph">
<p>The following code shows an example of how to configure and build an <code>OAuth2AuthorizedClientProvider</code> composite that provides support for the <code>authorization_code</code>, <code>refresh_token</code>, <code>client_credentials</code> and <code>password</code> authorization grant types:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public OAuth2AuthorizedClientManager authorizedClientManager(
		ClientRegistrationRepository clientRegistrationRepository,
		OAuth2AuthorizedClientRepository authorizedClientRepository) {

	OAuth2AuthorizedClientProvider authorizedClientProvider =
			OAuth2AuthorizedClientProviderBuilder.builder()
					.authorizationCode()
					.refreshToken()
					.clientCredentials()
					.password()
					.build();

	DefaultOAuth2AuthorizedClientManager authorizedClientManager =
			new DefaultOAuth2AuthorizedClientManager(
					clientRegistrationRepository, authorizedClientRepository);
	authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

	return authorizedClientManager;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authorizedClientManager(
        clientRegistrationRepository: ClientRegistrationRepository,
        authorizedClientRepository: OAuth2AuthorizedClientRepository): OAuth2AuthorizedClientManager {
    val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
            .authorizationCode()
            .refreshToken()
            .clientCredentials()
            .password()
            .build()
    val authorizedClientManager = DefaultOAuth2AuthorizedClientManager(
            clientRegistrationRepository, authorizedClientRepository)
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)
    return authorizedClientManager
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When an authorization attempt succeeds, the <code>DefaultOAuth2AuthorizedClientManager</code> will delegate to the <code>OAuth2AuthorizationSuccessHandler</code>, which (by default) will save the <code>OAuth2AuthorizedClient</code> via the <code>OAuth2AuthorizedClientRepository</code>.
In the case of a re-authorization failure, eg. a refresh token is no longer valid, the previously saved <code>OAuth2AuthorizedClient</code> will be removed from the <code>OAuth2AuthorizedClientRepository</code> via the <code>RemoveAuthorizedClientOAuth2AuthorizationFailureHandler</code>.
The default behaviour may be customized via <code>setAuthorizationSuccessHandler(OAuth2AuthorizationSuccessHandler)</code> and <code>setAuthorizationFailureHandler(OAuth2AuthorizationFailureHandler)</code>.</p>
</div>
<div class="paragraph">
<p>The <code>DefaultOAuth2AuthorizedClientManager</code> is also associated with a <code>contextAttributesMapper</code> of type <code>Function&lt;OAuth2AuthorizeRequest, Map&lt;String, Object&gt;&gt;</code>, which is responsible for mapping attribute(s) from the <code>OAuth2AuthorizeRequest</code> to a <code>Map</code> of attributes to be associated to the <code>OAuth2AuthorizationContext</code>.
This can be useful when you need to supply an <code>OAuth2AuthorizedClientProvider</code> with required (supported) attribute(s), eg. the <code>PasswordOAuth2AuthorizedClientProvider</code> requires the resource owner&#8217;s <code>username</code> and <code>password</code> to be available in <code>OAuth2AuthorizationContext.getAttributes()</code>.</p>
</div>
<div class="paragraph">
<p>The following code shows an example of the <code>contextAttributesMapper</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public OAuth2AuthorizedClientManager authorizedClientManager(
		ClientRegistrationRepository clientRegistrationRepository,
		OAuth2AuthorizedClientRepository authorizedClientRepository) {

	OAuth2AuthorizedClientProvider authorizedClientProvider =
			OAuth2AuthorizedClientProviderBuilder.builder()
					.password()
					.refreshToken()
					.build();

	DefaultOAuth2AuthorizedClientManager authorizedClientManager =
			new DefaultOAuth2AuthorizedClientManager(
					clientRegistrationRepository, authorizedClientRepository);
	authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

	// Assuming the `username` and `password` are supplied as `HttpServletRequest` parameters,
	// map the `HttpServletRequest` parameters to `OAuth2AuthorizationContext.getAttributes()`
	authorizedClientManager.setContextAttributesMapper(contextAttributesMapper());

	return authorizedClientManager;
}

private Function&lt;OAuth2AuthorizeRequest, Map&lt;String, Object&gt;&gt; contextAttributesMapper() {
	return authorizeRequest -&gt; {
		Map&lt;String, Object&gt; contextAttributes = Collections.emptyMap();
		HttpServletRequest servletRequest = authorizeRequest.getAttribute(HttpServletRequest.class.getName());
		String username = servletRequest.getParameter(OAuth2ParameterNames.USERNAME);
		String password = servletRequest.getParameter(OAuth2ParameterNames.PASSWORD);
		if (StringUtils.hasText(username) &amp;&amp; StringUtils.hasText(password)) {
			contextAttributes = new HashMap&lt;&gt;();

			// `PasswordOAuth2AuthorizedClientProvider` requires both attributes
			contextAttributes.put(OAuth2AuthorizationContext.USERNAME_ATTRIBUTE_NAME, username);
			contextAttributes.put(OAuth2AuthorizationContext.PASSWORD_ATTRIBUTE_NAME, password);
		}
		return contextAttributes;
	};
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authorizedClientManager(
        clientRegistrationRepository: ClientRegistrationRepository,
        authorizedClientRepository: OAuth2AuthorizedClientRepository): OAuth2AuthorizedClientManager {
    val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
            .password()
            .refreshToken()
            .build()
    val authorizedClientManager = DefaultOAuth2AuthorizedClientManager(
            clientRegistrationRepository, authorizedClientRepository)
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)

    // Assuming the `username` and `password` are supplied as `HttpServletRequest` parameters,
    // map the `HttpServletRequest` parameters to `OAuth2AuthorizationContext.getAttributes()`
    authorizedClientManager.setContextAttributesMapper(contextAttributesMapper())
    return authorizedClientManager
}

private fun contextAttributesMapper(): Function&lt;OAuth2AuthorizeRequest, MutableMap&lt;String, Any&gt;&gt; {
    return Function { authorizeRequest -&gt;
        var contextAttributes: MutableMap&lt;String, Any&gt; = mutableMapOf()
        val servletRequest: HttpServletRequest = authorizeRequest.getAttribute(HttpServletRequest::class.java.name)
        val username: String = servletRequest.getParameter(OAuth2ParameterNames.USERNAME)
        val password: String = servletRequest.getParameter(OAuth2ParameterNames.PASSWORD)
        if (StringUtils.hasText(username) &amp;&amp; StringUtils.hasText(password)) {
            contextAttributes = hashMapOf()

            // `PasswordOAuth2AuthorizedClientProvider` requires both attributes
            contextAttributes[OAuth2AuthorizationContext.USERNAME_ATTRIBUTE_NAME] = username
            contextAttributes[OAuth2AuthorizationContext.PASSWORD_ATTRIBUTE_NAME] = password
        }
        contextAttributes
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>DefaultOAuth2AuthorizedClientManager</code> is designed to be used <strong><em>within</em></strong> the context of a <code>HttpServletRequest</code>.
When operating <strong><em>outside</em></strong> of a <code>HttpServletRequest</code> context, use <code>AuthorizedClientServiceOAuth2AuthorizedClientManager</code> instead.</p>
</div>
<div class="paragraph">
<p>A <em>service application</em> is a common use case for when to use an <code>AuthorizedClientServiceOAuth2AuthorizedClientManager</code>.
Service applications often run in the background, without any user interaction, and typically run under a system-level account instead of a user account.
An OAuth 2.0 Client configured with the <code>client_credentials</code> grant type can be considered a type of service application.</p>
</div>
<div class="paragraph">
<p>The following code shows an example of how to configure an <code>AuthorizedClientServiceOAuth2AuthorizedClientManager</code> that provides support for the <code>client_credentials</code> grant type:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public OAuth2AuthorizedClientManager authorizedClientManager(
		ClientRegistrationRepository clientRegistrationRepository,
		OAuth2AuthorizedClientService authorizedClientService) {

	OAuth2AuthorizedClientProvider authorizedClientProvider =
			OAuth2AuthorizedClientProviderBuilder.builder()
					.clientCredentials()
					.build();

	AuthorizedClientServiceOAuth2AuthorizedClientManager authorizedClientManager =
			new AuthorizedClientServiceOAuth2AuthorizedClientManager(
					clientRegistrationRepository, authorizedClientService);
	authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

	return authorizedClientManager;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authorizedClientManager(
        clientRegistrationRepository: ClientRegistrationRepository,
        authorizedClientService: OAuth2AuthorizedClientService): OAuth2AuthorizedClientManager {
    val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
            .clientCredentials()
            .build()
    val authorizedClientManager = AuthorizedClientServiceOAuth2AuthorizedClientManager(
            clientRegistrationRepository, authorizedClientService)
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)
    return authorizedClientManager
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2Client-auth-grant-support"><a class="anchor" href="#oauth2Client-auth-grant-support"></a>Authorization Grant Support</h4>
<div class="sect4">
<h5 id="oauth2Client-auth-code-grant"><a class="anchor" href="#oauth2Client-auth-code-grant"></a>Authorization Code</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please refer to the OAuth 2.0 Authorization Framework for further details on the <a href="https://tools.ietf.org/html/rfc6749#section-1.3.1">Authorization Code</a> grant.
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="_obtaining_authorization"><a class="anchor" href="#_obtaining_authorization"></a>Obtaining Authorization</h6>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please refer to the <a href="https://tools.ietf.org/html/rfc6749#section-4.1.1">Authorization Request/Response</a> protocol flow for the Authorization Code grant.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_initiating_the_authorization_request"><a class="anchor" href="#_initiating_the_authorization_request"></a>Initiating the Authorization Request</h6>
<div class="paragraph">
<p>The <code>OAuth2AuthorizationRequestRedirectFilter</code> uses an <code>OAuth2AuthorizationRequestResolver</code> to resolve an <code>OAuth2AuthorizationRequest</code> and initiate the Authorization Code grant flow by redirecting the end-user&#8217;s user-agent to the Authorization Server&#8217;s Authorization Endpoint.</p>
</div>
<div class="paragraph">
<p>The primary role of the <code>OAuth2AuthorizationRequestResolver</code> is to resolve an <code>OAuth2AuthorizationRequest</code> from the provided web request.
The default implementation <code>DefaultOAuth2AuthorizationRequestResolver</code> matches on the (default) path <code>/oauth2/authorization/{registrationId}</code> extracting the <code>registrationId</code> and using it to build the <code>OAuth2AuthorizationRequest</code> for the associated <code>ClientRegistration</code>.</p>
</div>
<div class="paragraph">
<p>Given the following Spring Boot 2.x properties for an OAuth 2.0 Client registration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-secret: okta-client-secret
            authorization-grant-type: authorization_code
            redirect-uri: "{baseUrl}/authorized/okta"
            scope: read, write
        provider:
          okta:
            authorization-uri: https://dev-1234.oktapreview.com/oauth2/v1/authorize
            token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token</code></pre>
</div>
</div>
<div class="paragraph">
<p>A request with the base path <code>/oauth2/authorization/okta</code> will initiate the Authorization Request redirect by the <code>OAuth2AuthorizationRequestRedirectFilter</code> and ultimately start the Authorization Code grant flow.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>AuthorizationCodeOAuth2AuthorizedClientProvider</code> is an implementation of <code>OAuth2AuthorizedClientProvider</code> for the Authorization Code grant,
which also initiates the Authorization Request redirect by the <code>OAuth2AuthorizationRequestRedirectFilter</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the OAuth 2.0 Client is a <a href="https://tools.ietf.org/html/rfc6749#section-2.1">Public Client</a>, then configure the OAuth 2.0 Client registration as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-authentication-method: none
            authorization-grant-type: authorization_code
            redirect-uri: "{baseUrl}/authorized/okta"
            ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Public Clients are supported using <a href="https://tools.ietf.org/html/rfc7636">Proof Key for Code Exchange</a> (PKCE).
If the client is running in an untrusted environment (eg. native application or web browser-based application) and therefore incapable of maintaining the confidentiality of it&#8217;s credentials, PKCE will automatically be used when the following conditions are true:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>client-secret</code> is omitted (or empty)</p>
</li>
<li>
<p><code>client-authentication-method</code> is set to "none" (<code>ClientAuthenticationMethod.NONE</code>)</p>
</li>
</ol>
</div>
<div id="oauth2Client-auth-code-redirect-uri" class="paragraph">
<p>The <code>DefaultOAuth2AuthorizationRequestResolver</code> also supports <code>URI</code> template variables for the <code>redirect-uri</code> using <code>UriComponentsBuilder</code>.</p>
</div>
<div class="paragraph">
<p>The following configuration uses all the supported <code>URI</code> template variables:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            ...
            redirect-uri: "{baseScheme}://{baseHost}{basePort}{basePath}/authorized/{registrationId}"
            ...</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>{baseUrl}</code> resolves to <code>{baseScheme}://{baseHost}{basePort}{basePath}</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Configuring the <code>redirect-uri</code> with <code>URI</code> template variables is especially useful when the OAuth 2.0 Client is running behind a <a href="#http-proxy-server">Proxy Server</a>.
This ensures that the <code>X-Forwarded-*</code> headers are used when expanding the <code>redirect-uri</code>.</p>
</div>
</div>
<div class="sect5">
<h6 id="_customizing_the_authorization_request"><a class="anchor" href="#_customizing_the_authorization_request"></a>Customizing the Authorization Request</h6>
<div class="paragraph">
<p>One of the primary use cases an <code>OAuth2AuthorizationRequestResolver</code> can realize is the ability to customize the Authorization Request with additional parameters above the standard parameters defined in the OAuth 2.0 Authorization Framework.</p>
</div>
<div class="paragraph">
<p>For example, OpenID Connect defines additional OAuth 2.0 request parameters for the <a href="https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest">Authorization Code Flow</a> extending from the standard parameters defined in the <a href="https://tools.ietf.org/html/rfc6749#section-4.1.1">OAuth 2.0 Authorization Framework</a>.
One of those extended parameters is the <code>prompt</code> parameter.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
OPTIONAL. Space delimited, case sensitive list of ASCII string values that specifies whether the Authorization Server prompts the End-User for reauthentication and consent. The defined values are: none, login, consent, select_account
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows how to configure the <code>DefaultOAuth2AuthorizationRequestResolver</code> with a <code>Consumer&lt;OAuth2AuthorizationRequest.Builder&gt;</code> that customizes the Authorization Request for <code>oauth2Login()</code>, by including the request parameter <code>prompt=consent</code>.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

	@Autowired
	private ClientRegistrationRepository clientRegistrationRepository;

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.authorizeRequests(authorize -&gt; authorize
				.anyRequest().authenticated()
			)
			.oauth2Login(oauth2 -&gt; oauth2
				.authorizationEndpoint(authorization -&gt; authorization
					.authorizationRequestResolver(
						authorizationRequestResolver(this.clientRegistrationRepository)
					)
				)
			);
	}

	private OAuth2AuthorizationRequestResolver authorizationRequestResolver(
			ClientRegistrationRepository clientRegistrationRepository) {

		DefaultOAuth2AuthorizationRequestResolver authorizationRequestResolver =
				new DefaultOAuth2AuthorizationRequestResolver(
						clientRegistrationRepository, "/oauth2/authorization");
		authorizationRequestResolver.setAuthorizationRequestCustomizer(
				authorizationRequestCustomizer());

		return  authorizationRequestResolver;
	}

	private Consumer&lt;OAuth2AuthorizationRequest.Builder&gt; authorizationRequestCustomizer() {
		return customizer -&gt; customizer
					.additionalParameters(params -&gt; params.put("prompt", "consent"));
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    @Autowired
    private lateinit var customClientRegistrationRepository: ClientRegistrationRepository

    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
            oauth2Login {
                authorizationEndpoint {
                    authorizationRequestResolver = authorizationRequestResolver(customClientRegistrationRepository)
                }
            }
        }
    }

    private fun authorizationRequestResolver(
            clientRegistrationRepository: ClientRegistrationRepository?): OAuth2AuthorizationRequestResolver? {
        val authorizationRequestResolver = DefaultOAuth2AuthorizationRequestResolver(
                clientRegistrationRepository, "/oauth2/authorization")
        authorizationRequestResolver.setAuthorizationRequestCustomizer(
                authorizationRequestCustomizer())
        return authorizationRequestResolver
    }

    private fun authorizationRequestCustomizer(): Consumer&lt;OAuth2AuthorizationRequest.Builder&gt; {
        return Consumer { customizer -&gt;
            customizer
                    .additionalParameters { params -&gt; params["prompt"] = "consent" }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For the simple use case, where the additional request parameter is always the same for a specific provider, it may be added directly in the <code>authorization-uri</code> property.</p>
</div>
<div class="paragraph">
<p>For example, if the value for the request parameter <code>prompt</code> is always <code>consent</code> for the provider <code>okta</code>, than simply configure as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        provider:
          okta:
            authorization-uri: https://dev-1234.oktapreview.com/oauth2/v1/authorize?prompt=consent</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding example shows the common use case of adding a custom parameter on top of the standard parameters.
Alternatively, if your requirements are more advanced, you can take full control in building the Authorization Request URI by simply overriding the <code>OAuth2AuthorizationRequest.authorizationRequestUri</code> property.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>OAuth2AuthorizationRequest.Builder.build()</code> constructs the <code>OAuth2AuthorizationRequest.authorizationRequestUri</code>, which represents the Authorization Request URI including all query parameters using the <code>application/x-www-form-urlencoded</code> format.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows a variation of <code>authorizationRequestCustomizer()</code> from the preceding example, and instead overrides the <code>OAuth2AuthorizationRequest.authorizationRequestUri</code> property.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">private Consumer&lt;OAuth2AuthorizationRequest.Builder&gt; authorizationRequestCustomizer() {
	return customizer -&gt; customizer
				.authorizationRequestUri(uriBuilder -&gt; uriBuilder
					.queryParam("prompt", "consent").build());
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">private fun authorizationRequestCustomizer(): Consumer&lt;OAuth2AuthorizationRequest.Builder&gt; {
    return Consumer { customizer: OAuth2AuthorizationRequest.Builder -&gt;
        customizer
                .authorizationRequestUri { uriBuilder: UriBuilder -&gt;
                    uriBuilder
                            .queryParam("prompt", "consent").build()
                }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_storing_the_authorization_request"><a class="anchor" href="#_storing_the_authorization_request"></a>Storing the Authorization Request</h6>
<div class="paragraph">
<p>The <code>AuthorizationRequestRepository</code> is responsible for the persistence of the <code>OAuth2AuthorizationRequest</code> from the time the Authorization Request is initiated to the time the Authorization Response is received (the callback).</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The <code>OAuth2AuthorizationRequest</code> is used to correlate and validate the Authorization Response.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The default implementation of <code>AuthorizationRequestRepository</code> is <code>HttpSessionOAuth2AuthorizationRequestRepository</code>, which stores the <code>OAuth2AuthorizationRequest</code> in the <code>HttpSession</code>.</p>
</div>
<div class="paragraph">
<p>If you have a custom implementation of <code>AuthorizationRequestRepository</code>, you may configure it as shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="title">Example 15. AuthorizationRequestRepository Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class OAuth2ClientSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.oauth2Client(oauth2 -&gt; oauth2
				.authorizationCodeGrant(codeGrant -&gt; codeGrant
					.authorizationRequestRepository(this.authorizationRequestRepository())
					...
				)
			);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class OAuth2ClientSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Client {
                authorizationCodeGrant {
                    authorizationRequestRepository = authorizationRequestRepository()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;oauth2-client&gt;
		&lt;authorization-code-grant authorization-request-repository-ref="authorizationRequestRepository"/&gt;
	&lt;/oauth2-client&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_requesting_an_access_token"><a class="anchor" href="#_requesting_an_access_token"></a>Requesting an Access Token</h6>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please refer to the <a href="https://tools.ietf.org/html/rfc6749#section-4.1.3">Access Token Request/Response</a> protocol flow for the Authorization Code grant.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The default implementation of <code>OAuth2AccessTokenResponseClient</code> for the Authorization Code grant is <code>DefaultAuthorizationCodeTokenResponseClient</code>, which uses a <code>RestOperations</code> for exchanging an authorization code for an access token at the Authorization Servers Token Endpoint.</p>
</div>
<div class="paragraph">
<p>The <code>DefaultAuthorizationCodeTokenResponseClient</code> is quite flexible as it allows you to customize the pre-processing of the Token Request and/or post-handling of the Token Response.</p>
</div>
</div>
<div class="sect5">
<h6 id="_customizing_the_access_token_request"><a class="anchor" href="#_customizing_the_access_token_request"></a>Customizing the Access Token Request</h6>
<div class="paragraph">
<p>If you need to customize the pre-processing of the Token Request, you can provide <code>DefaultAuthorizationCodeTokenResponseClient.setRequestEntityConverter()</code> with a custom <code>Converter&lt;OAuth2AuthorizationCodeGrantRequest, RequestEntity&lt;?&gt;&gt;</code>.
The default implementation <code>OAuth2AuthorizationCodeGrantRequestEntityConverter</code> builds a <code>RequestEntity</code> representation of a standard <a href="https://tools.ietf.org/html/rfc6749#section-4.1.3">OAuth 2.0 Access Token Request</a>.
However, providing a custom <code>Converter</code>, would allow you to extend the standard Token Request and add custom parameter(s).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The custom <code>Converter</code> must return a valid <code>RequestEntity</code> representation of an OAuth 2.0 Access Token Request that is understood by the intended OAuth 2.0 Provider.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_customizing_the_access_token_response"><a class="anchor" href="#_customizing_the_access_token_response"></a>Customizing the Access Token Response</h6>
<div class="paragraph">
<p>On the other end, if you need to customize the post-handling of the Token Response, you will need to provide <code>DefaultAuthorizationCodeTokenResponseClient.setRestOperations()</code> with a custom configured <code>RestOperations</code>.
The default <code>RestOperations</code> is configured as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RestTemplate restTemplate = new RestTemplate(Arrays.asList(
		new FormHttpMessageConverter(),
		new OAuth2AccessTokenResponseHttpMessageConverter()));

restTemplate.setErrorHandler(new OAuth2ErrorResponseErrorHandler());</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val restTemplate = RestTemplate(listOf(
        FormHttpMessageConverter(),
        OAuth2AccessTokenResponseHttpMessageConverter()))

restTemplate.errorHandler = OAuth2ErrorResponseErrorHandler()</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Spring MVC <code>FormHttpMessageConverter</code> is required as it&#8217;s used when sending the OAuth 2.0 Access Token Request.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>OAuth2AccessTokenResponseHttpMessageConverter</code> is a <code>HttpMessageConverter</code> for an OAuth 2.0 Access Token Response.
You can provide <code>OAuth2AccessTokenResponseHttpMessageConverter.setTokenResponseConverter()</code> with a custom <code>Converter&lt;Map&lt;String, String&gt;, OAuth2AccessTokenResponse&gt;</code> that is used for converting the OAuth 2.0 Access Token Response parameters to an <code>OAuth2AccessTokenResponse</code>.</p>
</div>
<div class="paragraph">
<p><code>OAuth2ErrorResponseErrorHandler</code> is a <code>ResponseErrorHandler</code> that can handle an OAuth 2.0 Error, eg. 400 Bad Request.
It uses an <code>OAuth2ErrorHttpMessageConverter</code> for converting the OAuth 2.0 Error parameters to an <code>OAuth2Error</code>.</p>
</div>
<div class="paragraph">
<p>Whether you customize <code>DefaultAuthorizationCodeTokenResponseClient</code> or provide your own implementation of <code>OAuth2AccessTokenResponseClient</code>, you&#8217;ll need to configure it as shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="title">Example 16. Access Token Response Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class OAuth2ClientSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.oauth2Client(oauth2 -&gt; oauth2
				.authorizationCodeGrant(codeGrant -&gt; codeGrant
					.accessTokenResponseClient(this.accessTokenResponseClient())
					...
				)
			);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class OAuth2ClientSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Client {
                authorizationCodeGrant {
                    accessTokenResponseClient = accessTokenResponseClient()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;oauth2-client&gt;
		&lt;authorization-code-grant access-token-response-client-ref="accessTokenResponseClient"/&gt;
	&lt;/oauth2-client&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2Client-refresh-token-grant"><a class="anchor" href="#oauth2Client-refresh-token-grant"></a>Refresh Token</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please refer to the OAuth 2.0 Authorization Framework for further details on the <a href="https://tools.ietf.org/html/rfc6749#section-1.5">Refresh Token</a>.
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="_refreshing_an_access_token"><a class="anchor" href="#_refreshing_an_access_token"></a>Refreshing an Access Token</h6>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please refer to the <a href="https://tools.ietf.org/html/rfc6749#section-6">Access Token Request/Response</a> protocol flow for the Refresh Token grant.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The default implementation of <code>OAuth2AccessTokenResponseClient</code> for the Refresh Token grant is <code>DefaultRefreshTokenTokenResponseClient</code>, which uses a <code>RestOperations</code> when refreshing an access token at the Authorization Servers Token Endpoint.</p>
</div>
<div class="paragraph">
<p>The <code>DefaultRefreshTokenTokenResponseClient</code> is quite flexible as it allows you to customize the pre-processing of the Token Request and/or post-handling of the Token Response.</p>
</div>
</div>
<div class="sect5">
<h6 id="_customizing_the_access_token_request_2"><a class="anchor" href="#_customizing_the_access_token_request_2"></a>Customizing the Access Token Request</h6>
<div class="paragraph">
<p>If you need to customize the pre-processing of the Token Request, you can provide <code>DefaultRefreshTokenTokenResponseClient.setRequestEntityConverter()</code> with a custom <code>Converter&lt;OAuth2RefreshTokenGrantRequest, RequestEntity&lt;?&gt;&gt;</code>.
The default implementation <code>OAuth2RefreshTokenGrantRequestEntityConverter</code> builds a <code>RequestEntity</code> representation of a standard <a href="https://tools.ietf.org/html/rfc6749#section-6">OAuth 2.0 Access Token Request</a>.
However, providing a custom <code>Converter</code>, would allow you to extend the standard Token Request and add custom parameter(s).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The custom <code>Converter</code> must return a valid <code>RequestEntity</code> representation of an OAuth 2.0 Access Token Request that is understood by the intended OAuth 2.0 Provider.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_customizing_the_access_token_response_2"><a class="anchor" href="#_customizing_the_access_token_response_2"></a>Customizing the Access Token Response</h6>
<div class="paragraph">
<p>On the other end, if you need to customize the post-handling of the Token Response, you will need to provide <code>DefaultRefreshTokenTokenResponseClient.setRestOperations()</code> with a custom configured <code>RestOperations</code>.
The default <code>RestOperations</code> is configured as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RestTemplate restTemplate = new RestTemplate(Arrays.asList(
		new FormHttpMessageConverter(),
		new OAuth2AccessTokenResponseHttpMessageConverter()));

restTemplate.setErrorHandler(new OAuth2ErrorResponseErrorHandler());</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val restTemplate = RestTemplate(listOf(
        FormHttpMessageConverter(),
        OAuth2AccessTokenResponseHttpMessageConverter()))

restTemplate.errorHandler = OAuth2ErrorResponseErrorHandler()</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Spring MVC <code>FormHttpMessageConverter</code> is required as it&#8217;s used when sending the OAuth 2.0 Access Token Request.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>OAuth2AccessTokenResponseHttpMessageConverter</code> is a <code>HttpMessageConverter</code> for an OAuth 2.0 Access Token Response.
You can provide <code>OAuth2AccessTokenResponseHttpMessageConverter.setTokenResponseConverter()</code> with a custom <code>Converter&lt;Map&lt;String, String&gt;, OAuth2AccessTokenResponse&gt;</code> that is used for converting the OAuth 2.0 Access Token Response parameters to an <code>OAuth2AccessTokenResponse</code>.</p>
</div>
<div class="paragraph">
<p><code>OAuth2ErrorResponseErrorHandler</code> is a <code>ResponseErrorHandler</code> that can handle an OAuth 2.0 Error, eg. 400 Bad Request.
It uses an <code>OAuth2ErrorHttpMessageConverter</code> for converting the OAuth 2.0 Error parameters to an <code>OAuth2Error</code>.</p>
</div>
<div class="paragraph">
<p>Whether you customize <code>DefaultRefreshTokenTokenResponseClient</code> or provide your own implementation of <code>OAuth2AccessTokenResponseClient</code>, you&#8217;ll need to configure it as shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Customize
OAuth2AccessTokenResponseClient&lt;OAuth2RefreshTokenGrantRequest&gt; refreshTokenTokenResponseClient = ...

OAuth2AuthorizedClientProvider authorizedClientProvider =
		OAuth2AuthorizedClientProviderBuilder.builder()
				.authorizationCode()
				.refreshToken(configurer -&gt; configurer.accessTokenResponseClient(refreshTokenTokenResponseClient))
				.build();

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// Customize
val refreshTokenTokenResponseClient: OAuth2AccessTokenResponseClient&lt;OAuth2RefreshTokenGrantRequest&gt; = ...

val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
        .authorizationCode()
        .refreshToken { it.accessTokenResponseClient(refreshTokenTokenResponseClient) }
        .build()

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>OAuth2AuthorizedClientProviderBuilder.builder().refreshToken()</code> configures a <code>RefreshTokenOAuth2AuthorizedClientProvider</code>,
which is an implementation of an <code>OAuth2AuthorizedClientProvider</code> for the Refresh Token grant.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>OAuth2RefreshToken</code> may optionally be returned in the Access Token Response for the <code>authorization_code</code> and <code>password</code> grant types.
If the <code>OAuth2AuthorizedClient.getRefreshToken()</code> is available and the <code>OAuth2AuthorizedClient.getAccessToken()</code> is expired, it will automatically be refreshed by the <code>RefreshTokenOAuth2AuthorizedClientProvider</code>.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2Client-client-creds-grant"><a class="anchor" href="#oauth2Client-client-creds-grant"></a>Client Credentials</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please refer to the OAuth 2.0 Authorization Framework for further details on the <a href="https://tools.ietf.org/html/rfc6749#section-1.3.4">Client Credentials</a> grant.
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="_requesting_an_access_token_2"><a class="anchor" href="#_requesting_an_access_token_2"></a>Requesting an Access Token</h6>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please refer to the <a href="https://tools.ietf.org/html/rfc6749#section-4.4.2">Access Token Request/Response</a> protocol flow for the Client Credentials grant.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The default implementation of <code>OAuth2AccessTokenResponseClient</code> for the Client Credentials grant is <code>DefaultClientCredentialsTokenResponseClient</code>, which uses a <code>RestOperations</code> when requesting an access token at the Authorization Servers Token Endpoint.</p>
</div>
<div class="paragraph">
<p>The <code>DefaultClientCredentialsTokenResponseClient</code> is quite flexible as it allows you to customize the pre-processing of the Token Request and/or post-handling of the Token Response.</p>
</div>
</div>
<div class="sect5">
<h6 id="_customizing_the_access_token_request_3"><a class="anchor" href="#_customizing_the_access_token_request_3"></a>Customizing the Access Token Request</h6>
<div class="paragraph">
<p>If you need to customize the pre-processing of the Token Request, you can provide <code>DefaultClientCredentialsTokenResponseClient.setRequestEntityConverter()</code> with a custom <code>Converter&lt;OAuth2ClientCredentialsGrantRequest, RequestEntity&lt;?&gt;&gt;</code>.
The default implementation <code>OAuth2ClientCredentialsGrantRequestEntityConverter</code> builds a <code>RequestEntity</code> representation of a standard <a href="https://tools.ietf.org/html/rfc6749#section-4.4.2">OAuth 2.0 Access Token Request</a>.
However, providing a custom <code>Converter</code>, would allow you to extend the standard Token Request and add custom parameter(s).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The custom <code>Converter</code> must return a valid <code>RequestEntity</code> representation of an OAuth 2.0 Access Token Request that is understood by the intended OAuth 2.0 Provider.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_customizing_the_access_token_response_3"><a class="anchor" href="#_customizing_the_access_token_response_3"></a>Customizing the Access Token Response</h6>
<div class="paragraph">
<p>On the other end, if you need to customize the post-handling of the Token Response, you will need to provide <code>DefaultClientCredentialsTokenResponseClient.setRestOperations()</code> with a custom configured <code>RestOperations</code>.
The default <code>RestOperations</code> is configured as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RestTemplate restTemplate = new RestTemplate(Arrays.asList(
		new FormHttpMessageConverter(),
		new OAuth2AccessTokenResponseHttpMessageConverter()));

restTemplate.setErrorHandler(new OAuth2ErrorResponseErrorHandler());</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val restTemplate = RestTemplate(listOf(
        FormHttpMessageConverter(),
        OAuth2AccessTokenResponseHttpMessageConverter()))

restTemplate.errorHandler = OAuth2ErrorResponseErrorHandler()</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Spring MVC <code>FormHttpMessageConverter</code> is required as it&#8217;s used when sending the OAuth 2.0 Access Token Request.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>OAuth2AccessTokenResponseHttpMessageConverter</code> is a <code>HttpMessageConverter</code> for an OAuth 2.0 Access Token Response.
You can provide <code>OAuth2AccessTokenResponseHttpMessageConverter.setTokenResponseConverter()</code> with a custom <code>Converter&lt;Map&lt;String, String&gt;, OAuth2AccessTokenResponse&gt;</code> that is used for converting the OAuth 2.0 Access Token Response parameters to an <code>OAuth2AccessTokenResponse</code>.</p>
</div>
<div class="paragraph">
<p><code>OAuth2ErrorResponseErrorHandler</code> is a <code>ResponseErrorHandler</code> that can handle an OAuth 2.0 Error, eg. 400 Bad Request.
It uses an <code>OAuth2ErrorHttpMessageConverter</code> for converting the OAuth 2.0 Error parameters to an <code>OAuth2Error</code>.</p>
</div>
<div class="paragraph">
<p>Whether you customize <code>DefaultClientCredentialsTokenResponseClient</code> or provide your own implementation of <code>OAuth2AccessTokenResponseClient</code>, you&#8217;ll need to configure it as shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Customize
OAuth2AccessTokenResponseClient&lt;OAuth2ClientCredentialsGrantRequest&gt; clientCredentialsTokenResponseClient = ...

OAuth2AuthorizedClientProvider authorizedClientProvider =
		OAuth2AuthorizedClientProviderBuilder.builder()
				.clientCredentials(configurer -&gt; configurer.accessTokenResponseClient(clientCredentialsTokenResponseClient))
				.build();

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// Customize
val clientCredentialsTokenResponseClient: OAuth2AccessTokenResponseClient&lt;OAuth2ClientCredentialsGrantRequest&gt; = ...

val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
        .clientCredentials { it.accessTokenResponseClient(clientCredentialsTokenResponseClient) }
        .build()

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>OAuth2AuthorizedClientProviderBuilder.builder().clientCredentials()</code> configures a <code>ClientCredentialsOAuth2AuthorizedClientProvider</code>,
which is an implementation of an <code>OAuth2AuthorizedClientProvider</code> for the Client Credentials grant.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_using_the_access_token"><a class="anchor" href="#_using_the_access_token"></a>Using the Access Token</h6>
<div class="paragraph">
<p>Given the following Spring Boot 2.x properties for an OAuth 2.0 Client registration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-secret: okta-client-secret
            authorization-grant-type: client_credentials
            scope: read, write
        provider:
          okta:
            token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;and the <code>OAuth2AuthorizedClientManager</code> <code>@Bean</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public OAuth2AuthorizedClientManager authorizedClientManager(
		ClientRegistrationRepository clientRegistrationRepository,
		OAuth2AuthorizedClientRepository authorizedClientRepository) {

	OAuth2AuthorizedClientProvider authorizedClientProvider =
			OAuth2AuthorizedClientProviderBuilder.builder()
					.clientCredentials()
					.build();

	DefaultOAuth2AuthorizedClientManager authorizedClientManager =
			new DefaultOAuth2AuthorizedClientManager(
					clientRegistrationRepository, authorizedClientRepository);
	authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

	return authorizedClientManager;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authorizedClientManager(
        clientRegistrationRepository: ClientRegistrationRepository,
        authorizedClientRepository: OAuth2AuthorizedClientRepository): OAuth2AuthorizedClientManager {
    val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
            .clientCredentials()
            .build()
    val authorizedClientManager = DefaultOAuth2AuthorizedClientManager(
            clientRegistrationRepository, authorizedClientRepository)
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)
    return authorizedClientManager
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You may obtain the <code>OAuth2AccessToken</code> as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
public class OAuth2ClientController {

	@Autowired
	private OAuth2AuthorizedClientManager authorizedClientManager;

	@GetMapping("/")
	public String index(Authentication authentication,
						HttpServletRequest servletRequest,
						HttpServletResponse servletResponse) {

		OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId("okta")
				.principal(authentication)
				.attributes(attrs -&gt; {
					attrs.put(HttpServletRequest.class.getName(), servletRequest);
					attrs.put(HttpServletResponse.class.getName(), servletResponse);
				})
				.build();
		OAuth2AuthorizedClient authorizedClient = this.authorizedClientManager.authorize(authorizeRequest);

		OAuth2AccessToken accessToken = authorizedClient.getAccessToken();

		...

		return "index";
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class OAuth2ClientController {

    @Autowired
    private lateinit var authorizedClientManager: OAuth2AuthorizedClientManager

    @GetMapping("/")
    fun index(authentication: Authentication?,
              servletRequest: HttpServletRequest,
              servletResponse: HttpServletResponse): String {
        val authorizeRequest: OAuth2AuthorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId("okta")
                .principal(authentication)
                .attributes(Consumer { attrs: MutableMap&lt;String, Any&gt; -&gt;
                    attrs[HttpServletRequest::class.java.name] = servletRequest
                    attrs[HttpServletResponse::class.java.name] = servletResponse
                })
                .build()
        val authorizedClient = authorizedClientManager.authorize(authorizeRequest)
        val accessToken: OAuth2AccessToken = authorizedClient.accessToken

        ...

        return "index"
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>HttpServletRequest</code> and <code>HttpServletResponse</code> are both OPTIONAL attributes.
If not provided, it will default to <code>ServletRequestAttributes</code> using <code>RequestContextHolder.getRequestAttributes()</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2Client-password-grant"><a class="anchor" href="#oauth2Client-password-grant"></a>Resource Owner Password Credentials</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please refer to the OAuth 2.0 Authorization Framework for further details on the <a href="https://tools.ietf.org/html/rfc6749#section-1.3.3">Resource Owner Password Credentials</a> grant.
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="_requesting_an_access_token_3"><a class="anchor" href="#_requesting_an_access_token_3"></a>Requesting an Access Token</h6>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please refer to the <a href="https://tools.ietf.org/html/rfc6749#section-4.3.2">Access Token Request/Response</a> protocol flow for the Resource Owner Password Credentials grant.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The default implementation of <code>OAuth2AccessTokenResponseClient</code> for the Resource Owner Password Credentials grant is <code>DefaultPasswordTokenResponseClient</code>, which uses a <code>RestOperations</code> when requesting an access token at the Authorization Servers Token Endpoint.</p>
</div>
<div class="paragraph">
<p>The <code>DefaultPasswordTokenResponseClient</code> is quite flexible as it allows you to customize the pre-processing of the Token Request and/or post-handling of the Token Response.</p>
</div>
</div>
<div class="sect5">
<h6 id="_customizing_the_access_token_request_4"><a class="anchor" href="#_customizing_the_access_token_request_4"></a>Customizing the Access Token Request</h6>
<div class="paragraph">
<p>If you need to customize the pre-processing of the Token Request, you can provide <code>DefaultPasswordTokenResponseClient.setRequestEntityConverter()</code> with a custom <code>Converter&lt;OAuth2PasswordGrantRequest, RequestEntity&lt;?&gt;&gt;</code>.
The default implementation <code>OAuth2PasswordGrantRequestEntityConverter</code> builds a <code>RequestEntity</code> representation of a standard <a href="https://tools.ietf.org/html/rfc6749#section-4.3.2">OAuth 2.0 Access Token Request</a>.
However, providing a custom <code>Converter</code>, would allow you to extend the standard Token Request and add custom parameter(s).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The custom <code>Converter</code> must return a valid <code>RequestEntity</code> representation of an OAuth 2.0 Access Token Request that is understood by the intended OAuth 2.0 Provider.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_customizing_the_access_token_response_4"><a class="anchor" href="#_customizing_the_access_token_response_4"></a>Customizing the Access Token Response</h6>
<div class="paragraph">
<p>On the other end, if you need to customize the post-handling of the Token Response, you will need to provide <code>DefaultPasswordTokenResponseClient.setRestOperations()</code> with a custom configured <code>RestOperations</code>.
The default <code>RestOperations</code> is configured as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RestTemplate restTemplate = new RestTemplate(Arrays.asList(
		new FormHttpMessageConverter(),
		new OAuth2AccessTokenResponseHttpMessageConverter()));

restTemplate.setErrorHandler(new OAuth2ErrorResponseErrorHandler());</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val restTemplate = RestTemplate(listOf(
        FormHttpMessageConverter(),
        OAuth2AccessTokenResponseHttpMessageConverter()))

restTemplate.errorHandler = OAuth2ErrorResponseErrorHandler()</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Spring MVC <code>FormHttpMessageConverter</code> is required as it&#8217;s used when sending the OAuth 2.0 Access Token Request.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>OAuth2AccessTokenResponseHttpMessageConverter</code> is a <code>HttpMessageConverter</code> for an OAuth 2.0 Access Token Response.
You can provide <code>OAuth2AccessTokenResponseHttpMessageConverter.setTokenResponseConverter()</code> with a custom <code>Converter&lt;Map&lt;String, String&gt;, OAuth2AccessTokenResponse&gt;</code> that is used for converting the OAuth 2.0 Access Token Response parameters to an <code>OAuth2AccessTokenResponse</code>.</p>
</div>
<div class="paragraph">
<p><code>OAuth2ErrorResponseErrorHandler</code> is a <code>ResponseErrorHandler</code> that can handle an OAuth 2.0 Error, eg. 400 Bad Request.
It uses an <code>OAuth2ErrorHttpMessageConverter</code> for converting the OAuth 2.0 Error parameters to an <code>OAuth2Error</code>.</p>
</div>
<div class="paragraph">
<p>Whether you customize <code>DefaultPasswordTokenResponseClient</code> or provide your own implementation of <code>OAuth2AccessTokenResponseClient</code>, you&#8217;ll need to configure it as shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Customize
OAuth2AccessTokenResponseClient&lt;OAuth2PasswordGrantRequest&gt; passwordTokenResponseClient = ...

OAuth2AuthorizedClientProvider authorizedClientProvider =
		OAuth2AuthorizedClientProviderBuilder.builder()
				.password(configurer -&gt; configurer.accessTokenResponseClient(passwordTokenResponseClient))
				.refreshToken()
				.build();

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val passwordTokenResponseClient: OAuth2AccessTokenResponseClient&lt;OAuth2PasswordGrantRequest&gt; = ...

val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
        .password { it.accessTokenResponseClient(passwordTokenResponseClient) }
        .refreshToken()
        .build()

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>OAuth2AuthorizedClientProviderBuilder.builder().password()</code> configures a <code>PasswordOAuth2AuthorizedClientProvider</code>,
which is an implementation of an <code>OAuth2AuthorizedClientProvider</code> for the Resource Owner Password Credentials grant.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_using_the_access_token_2"><a class="anchor" href="#_using_the_access_token_2"></a>Using the Access Token</h6>
<div class="paragraph">
<p>Given the following Spring Boot 2.x properties for an OAuth 2.0 Client registration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-secret: okta-client-secret
            authorization-grant-type: password
            scope: read, write
        provider:
          okta:
            token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;and the <code>OAuth2AuthorizedClientManager</code> <code>@Bean</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public OAuth2AuthorizedClientManager authorizedClientManager(
		ClientRegistrationRepository clientRegistrationRepository,
		OAuth2AuthorizedClientRepository authorizedClientRepository) {

	OAuth2AuthorizedClientProvider authorizedClientProvider =
			OAuth2AuthorizedClientProviderBuilder.builder()
					.password()
					.refreshToken()
					.build();

	DefaultOAuth2AuthorizedClientManager authorizedClientManager =
			new DefaultOAuth2AuthorizedClientManager(
					clientRegistrationRepository, authorizedClientRepository);
	authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

	// Assuming the `username` and `password` are supplied as `HttpServletRequest` parameters,
	// map the `HttpServletRequest` parameters to `OAuth2AuthorizationContext.getAttributes()`
	authorizedClientManager.setContextAttributesMapper(contextAttributesMapper());

	return authorizedClientManager;
}

private Function&lt;OAuth2AuthorizeRequest, Map&lt;String, Object&gt;&gt; contextAttributesMapper() {
	return authorizeRequest -&gt; {
		Map&lt;String, Object&gt; contextAttributes = Collections.emptyMap();
		HttpServletRequest servletRequest = authorizeRequest.getAttribute(HttpServletRequest.class.getName());
		String username = servletRequest.getParameter(OAuth2ParameterNames.USERNAME);
		String password = servletRequest.getParameter(OAuth2ParameterNames.PASSWORD);
		if (StringUtils.hasText(username) &amp;&amp; StringUtils.hasText(password)) {
			contextAttributes = new HashMap&lt;&gt;();

			// `PasswordOAuth2AuthorizedClientProvider` requires both attributes
			contextAttributes.put(OAuth2AuthorizationContext.USERNAME_ATTRIBUTE_NAME, username);
			contextAttributes.put(OAuth2AuthorizationContext.PASSWORD_ATTRIBUTE_NAME, password);
		}
		return contextAttributes;
	};
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authorizedClientManager(
        clientRegistrationRepository: ClientRegistrationRepository,
        authorizedClientRepository: OAuth2AuthorizedClientRepository): OAuth2AuthorizedClientManager {
    val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
            .password()
            .refreshToken()
            .build()
    val authorizedClientManager = DefaultOAuth2AuthorizedClientManager(
            clientRegistrationRepository, authorizedClientRepository)
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)

    // Assuming the `username` and `password` are supplied as `HttpServletRequest` parameters,
    // map the `HttpServletRequest` parameters to `OAuth2AuthorizationContext.getAttributes()`
    authorizedClientManager.setContextAttributesMapper(contextAttributesMapper())
    return authorizedClientManager
}

private fun contextAttributesMapper(): Function&lt;OAuth2AuthorizeRequest, MutableMap&lt;String, Any&gt;&gt; {
    return Function { authorizeRequest -&gt;
        var contextAttributes: MutableMap&lt;String, Any&gt; = mutableMapOf()
        val servletRequest: HttpServletRequest = authorizeRequest.getAttribute(HttpServletRequest::class.java.name)
        val username = servletRequest.getParameter(OAuth2ParameterNames.USERNAME)
        val password = servletRequest.getParameter(OAuth2ParameterNames.PASSWORD)
        if (StringUtils.hasText(username) &amp;&amp; StringUtils.hasText(password)) {
            contextAttributes = hashMapOf()

            // `PasswordOAuth2AuthorizedClientProvider` requires both attributes
            contextAttributes[OAuth2AuthorizationContext.USERNAME_ATTRIBUTE_NAME] = username
            contextAttributes[OAuth2AuthorizationContext.PASSWORD_ATTRIBUTE_NAME] = password
        }
        contextAttributes
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You may obtain the <code>OAuth2AccessToken</code> as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
public class OAuth2ClientController {

	@Autowired
	private OAuth2AuthorizedClientManager authorizedClientManager;

	@GetMapping("/")
	public String index(Authentication authentication,
						HttpServletRequest servletRequest,
						HttpServletResponse servletResponse) {

		OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId("okta")
				.principal(authentication)
				.attributes(attrs -&gt; {
					attrs.put(HttpServletRequest.class.getName(), servletRequest);
					attrs.put(HttpServletResponse.class.getName(), servletResponse);
				})
				.build();
		OAuth2AuthorizedClient authorizedClient = this.authorizedClientManager.authorize(authorizeRequest);

		OAuth2AccessToken accessToken = authorizedClient.getAccessToken();

		...

		return "index";
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Controller
class OAuth2ClientController {
    @Autowired
    private lateinit var authorizedClientManager: OAuth2AuthorizedClientManager

    @GetMapping("/")
    fun index(authentication: Authentication?,
              servletRequest: HttpServletRequest,
              servletResponse: HttpServletResponse): String {
        val authorizeRequest: OAuth2AuthorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId("okta")
                .principal(authentication)
                .attributes(Consumer {
                    it[HttpServletRequest::class.java.name] = servletRequest
                    it[HttpServletResponse::class.java.name] = servletResponse
                })
                .build()
        val authorizedClient = authorizedClientManager.authorize(authorizeRequest)
        val accessToken: OAuth2AccessToken = authorizedClient.accessToken

        ...

        return "index"
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>HttpServletRequest</code> and <code>HttpServletResponse</code> are both OPTIONAL attributes.
If not provided, it will default to <code>ServletRequestAttributes</code> using <code>RequestContextHolder.getRequestAttributes()</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2Client-jwt-bearer-grant"><a class="anchor" href="#oauth2Client-jwt-bearer-grant"></a>JWT Bearer</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please refer to JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants for further details on the <a href="https://datatracker.ietf.org/doc/html/rfc7523">JWT Bearer</a> grant.
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="_requesting_an_access_token_4"><a class="anchor" href="#_requesting_an_access_token_4"></a>Requesting an Access Token</h6>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please refer to the <a href="https://datatracker.ietf.org/doc/html/rfc7523#section-2.1">Access Token Request/Response</a> protocol flow for the JWT Bearer grant.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The default implementation of <code>OAuth2AccessTokenResponseClient</code> for the JWT Bearer grant is <code>DefaultJwtBearerTokenResponseClient</code>, which uses a <code>RestOperations</code> when requesting an access token at the Authorization Servers Token Endpoint.</p>
</div>
<div class="paragraph">
<p>The <code>DefaultJwtBearerTokenResponseClient</code> is quite flexible as it allows you to customize the pre-processing of the Token Request and/or post-handling of the Token Response.</p>
</div>
</div>
<div class="sect5">
<h6 id="_customizing_the_access_token_request_5"><a class="anchor" href="#_customizing_the_access_token_request_5"></a>Customizing the Access Token Request</h6>
<div class="paragraph">
<p>If you need to customize the pre-processing of the Token Request, you can provide <code>DefaultJwtBearerTokenResponseClient.setRequestEntityConverter()</code> with a custom <code>Converter&lt;JwtBearerGrantRequest, RequestEntity&lt;?&gt;&gt;</code>.
The default implementation <code>JwtBearerGrantRequestEntityConverter</code> builds a <code>RequestEntity</code> representation of a <a href="https://datatracker.ietf.org/doc/html/rfc7523#section-2.1">OAuth 2.0 Access Token Request</a>.
However, providing a custom <code>Converter</code>, would allow you to extend the Token Request and add custom parameter(s).</p>
</div>
</div>
<div class="sect5">
<h6 id="_customizing_the_access_token_response_5"><a class="anchor" href="#_customizing_the_access_token_response_5"></a>Customizing the Access Token Response</h6>
<div class="paragraph">
<p>On the other end, if you need to customize the post-handling of the Token Response, you will need to provide <code>DefaultJwtBearerTokenResponseClient.setRestOperations()</code> with a custom configured <code>RestOperations</code>.
The default <code>RestOperations</code> is configured as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RestTemplate restTemplate = new RestTemplate(Arrays.asList(
		new FormHttpMessageConverter(),
		new OAuth2AccessTokenResponseHttpMessageConverter()));

restTemplate.setErrorHandler(new OAuth2ErrorResponseErrorHandler());</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val restTemplate = RestTemplate(listOf(
        FormHttpMessageConverter(),
        OAuth2AccessTokenResponseHttpMessageConverter()))

restTemplate.errorHandler = OAuth2ErrorResponseErrorHandler()</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Spring MVC <code>FormHttpMessageConverter</code> is required as it&#8217;s used when sending the OAuth 2.0 Access Token Request.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>OAuth2AccessTokenResponseHttpMessageConverter</code> is a <code>HttpMessageConverter</code> for an OAuth 2.0 Access Token Response.
You can provide <code>OAuth2AccessTokenResponseHttpMessageConverter.setTokenResponseConverter()</code> with a custom <code>Converter&lt;Map&lt;String, String&gt;, OAuth2AccessTokenResponse&gt;</code> that is used for converting the OAuth 2.0 Access Token Response parameters to an <code>OAuth2AccessTokenResponse</code>.</p>
</div>
<div class="paragraph">
<p><code>OAuth2ErrorResponseErrorHandler</code> is a <code>ResponseErrorHandler</code> that can handle an OAuth 2.0 Error, eg. 400 Bad Request.
It uses an <code>OAuth2ErrorHttpMessageConverter</code> for converting the OAuth 2.0 Error parameters to an <code>OAuth2Error</code>.</p>
</div>
<div class="paragraph">
<p>Whether you customize <code>DefaultJwtBearerTokenResponseClient</code> or provide your own implementation of <code>OAuth2AccessTokenResponseClient</code>, you&#8217;ll need to configure it as shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Customize
OAuth2AccessTokenResponseClient&lt;JwtBearerGrantRequest&gt; jwtBearerTokenResponseClient = ...

JwtBearerOAuth2AuthorizedClientProvider jwtBearerAuthorizedClientProvider = new JwtBearerOAuth2AuthorizedClientProvider();
jwtBearerAuthorizedClientProvider.setAccessTokenResponseClient(jwtBearerTokenResponseClient);

OAuth2AuthorizedClientProvider authorizedClientProvider =
		OAuth2AuthorizedClientProviderBuilder.builder()
				.provider(jwtBearerAuthorizedClientProvider)
				.build();

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// Customize
val jwtBearerTokenResponseClient: OAuth2AccessTokenResponseClient&lt;JwtBearerGrantRequest&gt; = ...

val jwtBearerAuthorizedClientProvider = JwtBearerOAuth2AuthorizedClientProvider()
jwtBearerAuthorizedClientProvider.setAccessTokenResponseClient(jwtBearerTokenResponseClient);

val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
        .provider(jwtBearerAuthorizedClientProvider)
        .build()

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_using_the_access_token_3"><a class="anchor" href="#_using_the_access_token_3"></a>Using the Access Token</h6>
<div class="paragraph">
<p>Given the following Spring Boot 2.x properties for an OAuth 2.0 Client registration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-secret: okta-client-secret
            authorization-grant-type: urn:ietf:params:oauth:grant-type:jwt-bearer
            scope: read
        provider:
          okta:
            token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;and the <code>OAuth2AuthorizedClientManager</code> <code>@Bean</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public OAuth2AuthorizedClientManager authorizedClientManager(
		ClientRegistrationRepository clientRegistrationRepository,
		OAuth2AuthorizedClientRepository authorizedClientRepository) {

	JwtBearerOAuth2AuthorizedClientProvider jwtBearerAuthorizedClientProvider =
			new JwtBearerOAuth2AuthorizedClientProvider();

	OAuth2AuthorizedClientProvider authorizedClientProvider =
			OAuth2AuthorizedClientProviderBuilder.builder()
					.provider(jwtBearerAuthorizedClientProvider)
					.build();

	DefaultOAuth2AuthorizedClientManager authorizedClientManager =
			new DefaultOAuth2AuthorizedClientManager(
					clientRegistrationRepository, authorizedClientRepository);
	authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

	return authorizedClientManager;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authorizedClientManager(
        clientRegistrationRepository: ClientRegistrationRepository,
        authorizedClientRepository: OAuth2AuthorizedClientRepository): OAuth2AuthorizedClientManager {
    val jwtBearerAuthorizedClientProvider = JwtBearerOAuth2AuthorizedClientProvider()
    val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
            .provider(jwtBearerAuthorizedClientProvider)
            .build()
    val authorizedClientManager = DefaultOAuth2AuthorizedClientManager(
            clientRegistrationRepository, authorizedClientRepository)
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)
    return authorizedClientManager
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You may obtain the <code>OAuth2AccessToken</code> as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RestController
public class OAuth2ResourceServerController {

	@Autowired
	private OAuth2AuthorizedClientManager authorizedClientManager;

	@GetMapping("/resource")
	public String resource(JwtAuthenticationToken jwtAuthentication) {
		OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId("okta")
				.principal(jwtAuthentication)
				.build();
		OAuth2AuthorizedClient authorizedClient = this.authorizedClientManager.authorize(authorizeRequest);
		OAuth2AccessToken accessToken = authorizedClient.getAccessToken();

		...

	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class OAuth2ResourceServerController {

    @Autowired
    private lateinit var authorizedClientManager: OAuth2AuthorizedClientManager

    @GetMapping("/resource")
    fun resource(jwtAuthentication: JwtAuthenticationToken?): String {
        val authorizeRequest: OAuth2AuthorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId("okta")
                .principal(jwtAuthentication)
                .build()
        val authorizedClient = authorizedClientManager.authorize(authorizeRequest)
        val accessToken: OAuth2AccessToken = authorizedClient.accessToken

        ...

    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2Client-client-auth-support"><a class="anchor" href="#oauth2Client-client-auth-support"></a>Client Authentication Support</h4>
<div class="sect4">
<h5 id="oauth2Client-jwt-bearer-auth"><a class="anchor" href="#oauth2Client-jwt-bearer-auth"></a>JWT Bearer</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please refer to JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants for further details on <a href="https://datatracker.ietf.org/doc/html/rfc7523#section-2.2">JWT Bearer</a> Client Authentication.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The default implementation for JWT Bearer Client Authentication is <code>NimbusJwtClientAuthenticationParametersConverter</code>,
which is a <code>Converter</code> that customizes the Token Request parameters by adding
a signed JSON Web Token (JWS) in the <code>client_assertion</code> parameter.</p>
</div>
<div class="paragraph">
<p>The <code>java.security.PrivateKey</code> or <code>javax.crypto.SecretKey</code> used for signing the JWS
is supplied by the <code>com.nimbusds.jose.jwk.JWK</code> resolver associated with <code>NimbusJwtClientAuthenticationParametersConverter</code>.</p>
</div>
<div class="sect5">
<h6 id="_authenticate_using_private_key_jwt"><a class="anchor" href="#_authenticate_using_private_key_jwt"></a>Authenticate using <code>private_key_jwt</code></h6>
<div class="paragraph">
<p>Given the following Spring Boot 2.x properties for an OAuth 2.0 Client registration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-authentication-method: private_key_jwt
            authorization-grant-type: authorization_code
            ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to configure <code>DefaultAuthorizationCodeTokenResponseClient</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Function&lt;ClientRegistration, JWK&gt; jwkResolver = (clientRegistration) -&gt; {
	if (clientRegistration.getClientAuthenticationMethod().equals(ClientAuthenticationMethod.PRIVATE_KEY_JWT)) {
		// Assuming RSA key type
		RSAPublicKey publicKey = ...
		RSAPrivateKey privateKey = ...
		return new RSAKey.Builder(publicKey)
				.privateKey(privateKey)
				.keyID(UUID.randomUUID().toString())
				.build();
	}
	return null;
};

OAuth2AuthorizationCodeGrantRequestEntityConverter requestEntityConverter =
		new OAuth2AuthorizationCodeGrantRequestEntityConverter();
requestEntityConverter.addParametersConverter(
		new NimbusJwtClientAuthenticationParametersConverter&lt;&gt;(jwkResolver));

DefaultAuthorizationCodeTokenResponseClient tokenResponseClient =
		new DefaultAuthorizationCodeTokenResponseClient();
tokenResponseClient.setRequestEntityConverter(requestEntityConverter);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val jwkResolver: Function&lt;ClientRegistration, JWK&gt; =
    Function&lt;ClientRegistration, JWK&gt; { clientRegistration -&gt;
        if (clientRegistration.clientAuthenticationMethod.equals(ClientAuthenticationMethod.PRIVATE_KEY_JWT)) {
            // Assuming RSA key type
            var publicKey: RSAPublicKey
            var privateKey: RSAPrivateKey
            RSAKey.Builder(publicKey) = //...
                .privateKey(privateKey) = //...
                .keyID(UUID.randomUUID().toString())
                .build()
        }
        null
    }

val requestEntityConverter = OAuth2AuthorizationCodeGrantRequestEntityConverter()
requestEntityConverter.addParametersConverter(
    NimbusJwtClientAuthenticationParametersConverter(jwkResolver)
)

val tokenResponseClient = DefaultAuthorizationCodeTokenResponseClient()
tokenResponseClient.setRequestEntityConverter(requestEntityConverter)</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_authenticate_using_client_secret_jwt"><a class="anchor" href="#_authenticate_using_client_secret_jwt"></a>Authenticate using <code>client_secret_jwt</code></h6>
<div class="paragraph">
<p>Given the following Spring Boot 2.x properties for an OAuth 2.0 Client registration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-secret: okta-client-secret
            client-authentication-method: client_secret_jwt
            authorization-grant-type: client_credentials
            ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to configure <code>DefaultClientCredentialsTokenResponseClient</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Function&lt;ClientRegistration, JWK&gt; jwkResolver = (clientRegistration) -&gt; {
	if (clientRegistration.getClientAuthenticationMethod().equals(ClientAuthenticationMethod.CLIENT_SECRET_JWT)) {
		SecretKeySpec secretKey = new SecretKeySpec(
				clientRegistration.getClientSecret().getBytes(StandardCharsets.UTF_8),
				"HmacSHA256");
		return new OctetSequenceKey.Builder(secretKey)
				.keyID(UUID.randomUUID().toString())
				.build();
	}
	return null;
};

OAuth2ClientCredentialsGrantRequestEntityConverter requestEntityConverter =
		new OAuth2ClientCredentialsGrantRequestEntityConverter();
requestEntityConverter.addParametersConverter(
		new NimbusJwtClientAuthenticationParametersConverter&lt;&gt;(jwkResolver));

DefaultClientCredentialsTokenResponseClient tokenResponseClient =
		new DefaultClientCredentialsTokenResponseClient();
tokenResponseClient.setRequestEntityConverter(requestEntityConverter);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val jwkResolver = Function&lt;ClientRegistration, JWK?&gt; { clientRegistration: ClientRegistration -&gt;
    if (clientRegistration.clientAuthenticationMethod == ClientAuthenticationMethod.CLIENT_SECRET_JWT) {
        val secretKey = SecretKeySpec(
            clientRegistration.clientSecret.toByteArray(StandardCharsets.UTF_8),
            "HmacSHA256"
        )
        OctetSequenceKey.Builder(secretKey)
            .keyID(UUID.randomUUID().toString())
            .build()
    }
    null
}

val requestEntityConverter = OAuth2ClientCredentialsGrantRequestEntityConverter()
requestEntityConverter.addParametersConverter(
    NimbusJwtClientAuthenticationParametersConverter(jwkResolver)
)

val tokenResponseClient = DefaultClientCredentialsTokenResponseClient()
tokenResponseClient.setRequestEntityConverter(requestEntityConverter)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2Client-additional-features"><a class="anchor" href="#oauth2Client-additional-features"></a>Additional Features</h4>
<div class="sect4">
<h5 id="oauth2Client-registered-authorized-client"><a class="anchor" href="#oauth2Client-registered-authorized-client"></a>Resolving an Authorized Client</h5>
<div class="paragraph">
<p>The <code>@RegisteredOAuth2AuthorizedClient</code> annotation provides the capability of resolving a method parameter to an argument value of type <code>OAuth2AuthorizedClient</code>.
This is a convenient alternative compared to accessing the <code>OAuth2AuthorizedClient</code> using the <code>OAuth2AuthorizedClientManager</code> or <code>OAuth2AuthorizedClientService</code>.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
public class OAuth2ClientController {

	@GetMapping("/")
	public String index(@RegisteredOAuth2AuthorizedClient("okta") OAuth2AuthorizedClient authorizedClient) {
		OAuth2AccessToken accessToken = authorizedClient.getAccessToken();

		...

		return "index";
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Controller
class OAuth2ClientController {
    @GetMapping("/")
    fun index(@RegisteredOAuth2AuthorizedClient("okta") authorizedClient: OAuth2AuthorizedClient): String {
        val accessToken = authorizedClient.accessToken

        ...

        return "index"
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>@RegisteredOAuth2AuthorizedClient</code> annotation is handled by <code>OAuth2AuthorizedClientArgumentResolver</code>, which directly uses an <a href="#oauth2Client-authorized-manager-provider">OAuth2AuthorizedClientManager</a> and therefore inherits it&#8217;s capabilities.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2Client-webclient-servlet"><a class="anchor" href="#oauth2Client-webclient-servlet"></a>WebClient integration for Servlet Environments</h4>
<div class="paragraph">
<p>The OAuth 2.0 Client support integrates with <code>WebClient</code> using an <code>ExchangeFilterFunction</code>.</p>
</div>
<div class="paragraph">
<p>The <code>ServletOAuth2AuthorizedClientExchangeFilterFunction</code> provides a simple mechanism for requesting protected resources by using an <code>OAuth2AuthorizedClient</code> and including the associated <code>OAuth2AccessToken</code> as a Bearer Token.
It directly uses an <a href="#oauth2Client-authorized-manager-provider">OAuth2AuthorizedClientManager</a> and therefore inherits the following capabilities:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An <code>OAuth2AccessToken</code> will be requested if the client has not yet been authorized.</p>
<div class="ulist">
<ul>
<li>
<p><code>authorization_code</code> - triggers the Authorization Request redirect to initiate the flow</p>
</li>
<li>
<p><code>client_credentials</code> - the access token is obtained directly from the Token Endpoint</p>
</li>
<li>
<p><code>password</code> - the access token is obtained directly from the Token Endpoint</p>
</li>
</ul>
</div>
</li>
<li>
<p>If the <code>OAuth2AccessToken</code> is expired, it will be refreshed (or renewed) if an <code>OAuth2AuthorizedClientProvider</code> is available to perform the authorization</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following code shows an example of how to configure <code>WebClient</code> with OAuth 2.0 Client support:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
WebClient webClient(OAuth2AuthorizedClientManager authorizedClientManager) {
	ServletOAuth2AuthorizedClientExchangeFilterFunction oauth2Client =
			new ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager);
	return WebClient.builder()
			.apply(oauth2Client.oauth2Configuration())
			.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun webClient(authorizedClientManager: OAuth2AuthorizedClientManager?): WebClient {
    val oauth2Client = ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager)
    return WebClient.builder()
            .apply(oauth2Client.oauth2Configuration())
            .build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_providing_the_authorized_client"><a class="anchor" href="#_providing_the_authorized_client"></a>Providing the Authorized Client</h5>
<div class="paragraph">
<p>The <code>ServletOAuth2AuthorizedClientExchangeFilterFunction</code> determines the client to use (for a request) by resolving the <code>OAuth2AuthorizedClient</code> from the <code>ClientRequest.attributes()</code> (request attributes).</p>
</div>
<div class="paragraph">
<p>The following code shows how to set an <code>OAuth2AuthorizedClient</code> as a request attribute:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/")
public String index(@RegisteredOAuth2AuthorizedClient("okta") OAuth2AuthorizedClient authorizedClient) {
	String resourceUri = ...

	String body = webClient
			.get()
			.uri(resourceUri)
			.attributes(oauth2AuthorizedClient(authorizedClient))   <i class="conum" data-value="1"></i><b>(1)</b>
			.retrieve()
			.bodyToMono(String.class)
			.block();

	...

	return "index";
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/")
fun index(@RegisteredOAuth2AuthorizedClient("okta") authorizedClient: OAuth2AuthorizedClient): String {
    val resourceUri: String = ...
    val body: String = webClient
            .get()
            .uri(resourceUri)
            .attributes(oauth2AuthorizedClient(authorizedClient)) <i class="conum" data-value="1"></i><b>(1)</b>
            .retrieve()
            .bodyToMono()
            .block()

    ...

    return "index"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>oauth2AuthorizedClient()</code> is a <code>static</code> method in <code>ServletOAuth2AuthorizedClientExchangeFilterFunction</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following code shows how to set the <code>ClientRegistration.getRegistrationId()</code> as a request attribute:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/")
public String index() {
	String resourceUri = ...

	String body = webClient
			.get()
			.uri(resourceUri)
			.attributes(clientRegistrationId("okta"))   <i class="conum" data-value="1"></i><b>(1)</b>
			.retrieve()
			.bodyToMono(String.class)
			.block();

	...

	return "index";
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/")
fun index(): String {
    val resourceUri: String = ...

    val body: String = webClient
            .get()
            .uri(resourceUri)
            .attributes(clientRegistrationId("okta"))  <i class="conum" data-value="1"></i><b>(1)</b>
            .retrieve()
            .bodyToMono()
            .block()

    ...

    return "index"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>clientRegistrationId()</code> is a <code>static</code> method in <code>ServletOAuth2AuthorizedClientExchangeFilterFunction</code>.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_defaulting_the_authorized_client"><a class="anchor" href="#_defaulting_the_authorized_client"></a>Defaulting the Authorized Client</h5>
<div class="paragraph">
<p>If neither <code>OAuth2AuthorizedClient</code> or <code>ClientRegistration.getRegistrationId()</code> is provided as a request attribute, the <code>ServletOAuth2AuthorizedClientExchangeFilterFunction</code> can determine the <em>default</em> client to use depending on it&#8217;s configuration.</p>
</div>
<div class="paragraph">
<p>If <code>setDefaultOAuth2AuthorizedClient(true)</code> is configured and the user has authenticated using <code>HttpSecurity.oauth2Login()</code>, the <code>OAuth2AccessToken</code> associated with the current <code>OAuth2AuthenticationToken</code> is used.</p>
</div>
<div class="paragraph">
<p>The following code shows the specific configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
WebClient webClient(OAuth2AuthorizedClientManager authorizedClientManager) {
	ServletOAuth2AuthorizedClientExchangeFilterFunction oauth2Client =
			new ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager);
	oauth2Client.setDefaultOAuth2AuthorizedClient(true);
	return WebClient.builder()
			.apply(oauth2Client.oauth2Configuration())
			.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun webClient(authorizedClientManager: OAuth2AuthorizedClientManager?): WebClient {
    val oauth2Client = ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager)
    oauth2Client.setDefaultOAuth2AuthorizedClient(true)
    return WebClient.builder()
            .apply(oauth2Client.oauth2Configuration())
            .build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
It is recommended to be cautious with this feature since all HTTP requests will receive the access token.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Alternatively, if <code>setDefaultClientRegistrationId("okta")</code> is configured with a valid <code>ClientRegistration</code>, the <code>OAuth2AccessToken</code> associated with the <code>OAuth2AuthorizedClient</code> is used.</p>
</div>
<div class="paragraph">
<p>The following code shows the specific configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
WebClient webClient(OAuth2AuthorizedClientManager authorizedClientManager) {
	ServletOAuth2AuthorizedClientExchangeFilterFunction oauth2Client =
			new ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager);
	oauth2Client.setDefaultClientRegistrationId("okta");
	return WebClient.builder()
			.apply(oauth2Client.oauth2Configuration())
			.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun webClient(authorizedClientManager: OAuth2AuthorizedClientManager?): WebClient {
    val oauth2Client = ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager)
    oauth2Client.setDefaultClientRegistrationId("okta")
    return WebClient.builder()
            .apply(oauth2Client.oauth2Configuration())
            .build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
It is recommended to be cautious with this feature since all HTTP requests will receive the access token.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="oauth2resourceserver"><a class="anchor" href="#oauth2resourceserver"></a>OAuth 2.0 Resource Server</h3>
<div class="paragraph">
<p>Spring Security supports protecting endpoints using two forms of OAuth 2.0 <a href="https://tools.ietf.org/html/rfc6750.html">Bearer Tokens</a>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://tools.ietf.org/html/rfc7519">JWT</a></p>
</li>
<li>
<p>Opaque Tokens</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This is handy in circumstances where an application has delegated its authority management to an <a href="https://tools.ietf.org/html/rfc6749">authorization server</a> (for example, Okta or Ping Identity).
This authorization server can be consulted by resource servers to authorize requests.</p>
</div>
<div class="paragraph">
<p>This section provides details on how Spring Security provides support for OAuth 2.0 <a href="https://tools.ietf.org/html/rfc6750.html">Bearer Tokens</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Working samples for both {gh-samples-url}/servlet/spring-boot/java/oauth2/resource-server/jwe[JWTs] and {gh-samples-url}/servlet/spring-boot/java/oauth2/resource-server/opaque[Opaque Tokens] are available in the {gh-samples-url}[Spring Security Samples repository].</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s take a look at how Bearer Token Authentication works within Spring Security.
First, we see that, like <a href="#servlet-authentication-basic">Basic Authentication</a>, the <a href="https://tools.ietf.org/html/rfc7235#section-4.1">WWW-Authenticate</a> header is sent back to an unauthenticated client.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/servlet/oauth2/bearerauthenticationentrypoint.png" alt="bearerauthenticationentrypoint">
</div>
<div class="title">Figure 1. Sending WWW-Authenticate Header</div>
</div>
<div class="paragraph">
<p>The figure above builds off our <a href="#servlet-securityfilterchain"><code>SecurityFilterChain</code></a> diagram.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_1.png" alt="number 1"></span> First, a user makes an unauthenticated request to the resource <code>/private</code> for which it is not authorized.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_2.png" alt="number 2"></span> Spring Security&#8217;s <a href="#servlet-authorization-filtersecurityinterceptor"><code>FilterSecurityInterceptor</code></a> indicates that the unauthenticated request is <em>Denied</em> by throwing an <code>AccessDeniedException</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_3.png" alt="number 3"></span> Since the user is not authenticated, <a href="#servlet-exceptiontranslationfilter"><code>ExceptionTranslationFilter</code></a> initiates <em>Start Authentication</em>.
The configured <a href="#servlet-authentication-authenticationentrypoint"><code>AuthenticationEntryPoint</code></a> is an instance of {security-api-url}org/springframework/security/oauth2/server/resource/web/BearerTokenAuthenticationEntryPoint.html[<code>BearerTokenAuthenticationEntryPoint</code>] which sends a WWW-Authenticate header.
The <code>RequestCache</code> is typically a <code>NullRequestCache</code> that does not save the request since the client is capable of replaying the requests it originally requested.</p>
</div>
<div class="paragraph">
<p>When a client receives the <code>WWW-Authenticate: Bearer</code> header, it knows it should retry with a bearer token.
Below is the flow for the bearer token being processed.</p>
</div>
<div id="oauth2resourceserver-authentication-bearertokenauthenticationfilter" class="imageblock">
<div class="content">
<img src="images/servlet/oauth2/bearertokenauthenticationfilter.png" alt="bearertokenauthenticationfilter">
</div>
<div class="title">Figure 2. Authenticating Bearer Token</div>
</div>
<div class="paragraph">
<p>The figure builds off our <a href="#servlet-securityfilterchain"><code>SecurityFilterChain</code></a> diagram.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_1.png" alt="number 1"></span> When the user submits their bearer token, the <code>BearerTokenAuthenticationFilter</code> creates a <code>BearerTokenAuthenticationToken</code> which is a type of <a href="#servlet-authentication-authentication"><code>Authentication</code></a> by extracting the token from the <code>HttpServletRequest</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_2.png" alt="number 2"></span> Next, the <code>HttpServletRequest</code> is passed to the <code>AuthenticationManagerResolver</code>, which selects the <code>AuthenticationManager</code>. The <code>BearerTokenAuthenticationToken</code> is passed into the <code>AuthenticationManager</code> to be authenticated.
The details of what <code>AuthenticationManager</code> looks like depends on whether you&#8217;re configured for <a href="#oauth2resourceserver-jwt-minimalconfiguration">JWT</a> or <a href="#oauth2resourceserver-opaque-minimalconfiguration">opaque token</a>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_3.png" alt="number 3"></span> If authentication fails, then <em>Failure</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="#servlet-authentication-securitycontextholder">[servlet-authentication-securitycontextholder]</a> is cleared out.</p>
</li>
<li>
<p>The <code>AuthenticationEntryPoint</code> is invoked to trigger the WWW-Authenticate header to be sent again.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_4.png" alt="number 4"></span> If authentication is successful, then <em>Success</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="#servlet-authentication-authentication">[servlet-authentication-authentication]</a> is set on the <a href="#servlet-authentication-securitycontextholder">[servlet-authentication-securitycontextholder]</a>.</p>
</li>
<li>
<p>The <code>BearerTokenAuthenticationFilter</code> invokes <code>FilterChain.doFilter(request,response)</code> to continue with the rest of the application logic.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-minimaldependencies"><a class="anchor" href="#oauth2resourceserver-jwt-minimaldependencies"></a>Minimal Dependencies for JWT</h4>
<div class="paragraph">
<p>Most Resource Server support is collected into <code>spring-security-oauth2-resource-server</code>.
However, the support for decoding and verifying JWTs is in <code>spring-security-oauth2-jose</code>, meaning that both are necessary in order to have a working resource server that supports JWT-encoded Bearer Tokens.</p>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-minimalconfiguration"><a class="anchor" href="#oauth2resourceserver-jwt-minimalconfiguration"></a>Minimal Configuration for JWTs</h4>
<div class="paragraph">
<p>When using <a href="https://spring.io/projects/spring-boot">Spring Boot</a>, configuring an application as a resource server consists of two basic steps.
First, include the needed dependencies and second, indicate the location of the authorization server.</p>
</div>
<div class="sect4">
<h5 id="_specifying_the_authorization_server"><a class="anchor" href="#_specifying_the_authorization_server"></a>Specifying the Authorization Server</h5>
<div class="paragraph">
<p>In a Spring Boot application, to specify which authorization server to use, simply do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: https://idp.example.com/issuer</code></pre>
</div>
</div>
<div class="paragraph">
<p>Where <code><a href="https://idp.example.com/issuer" class="bare">https://idp.example.com/issuer</a></code> is the value contained in the <code>iss</code> claim for JWT tokens that the authorization server will issue.
Resource Server will use this property to further self-configure, discover the authorization server&#8217;s public keys, and subsequently validate incoming JWTs.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
To use the <code>issuer-uri</code> property, it must also be true that one of <code><a href="https://idp.example.com/issuer/.well-known/openid-configuration" class="bare">https://idp.example.com/issuer/.well-known/openid-configuration</a></code>, <code><a href="https://idp.example.com/.well-known/openid-configuration/issuer" class="bare">https://idp.example.com/.well-known/openid-configuration/issuer</a></code>, or <code><a href="https://idp.example.com/.well-known/oauth-authorization-server/issuer" class="bare">https://idp.example.com/.well-known/oauth-authorization-server/issuer</a></code> is a supported endpoint for the authorization server.
This endpoint is referred to as a <a href="https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig">Provider Configuration</a> endpoint or a <a href="https://tools.ietf.org/html/rfc8414#section-3">Authorization Server Metadata</a> endpoint.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>And that&#8217;s it!</p>
</div>
</div>
<div class="sect4">
<h5 id="_startup_expectations"><a class="anchor" href="#_startup_expectations"></a>Startup Expectations</h5>
<div class="paragraph">
<p>When this property and these dependencies are used, Resource Server will automatically configure itself to validate JWT-encoded Bearer Tokens.</p>
</div>
<div class="paragraph">
<p>It achieves this through a deterministic startup process:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Query the Provider Configuration or Authorization Server Metadata endpoint for the <code>jwks_url</code> property</p>
</li>
<li>
<p>Query the <code>jwks_url</code> endpoint for supported algorithms</p>
</li>
<li>
<p>Configure the validation strategy to query <code>jwks_url</code> for valid public keys of the algorithms found</p>
</li>
<li>
<p>Configure the validation strategy to validate each JWTs <code>iss</code> claim against <code><a href="https://idp.example.com" class="bare">https://idp.example.com</a></code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>A consequence of this process is that the authorization server must be up and receiving requests in order for Resource Server to successfully start up.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If the authorization server is down when Resource Server queries it (given appropriate timeouts), then startup will fail.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_runtime_expectations"><a class="anchor" href="#_runtime_expectations"></a>Runtime Expectations</h5>
<div class="paragraph">
<p>Once the application is started up, Resource Server will attempt to process any request containing an <code>Authorization: Bearer</code> header:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">GET / HTTP/1.1
Authorization: Bearer some-token-value # Resource Server will process this</code></pre>
</div>
</div>
<div class="paragraph">
<p>So long as this scheme is indicated, Resource Server will attempt to process the request according to the Bearer Token specification.</p>
</div>
<div class="paragraph">
<p>Given a well-formed JWT, Resource Server will:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Validate its signature against a public key obtained from the <code>jwks_url</code> endpoint during startup and matched against the JWT</p>
</li>
<li>
<p>Validate the JWT&#8217;s <code>exp</code> and <code>nbf</code> timestamps and the JWT&#8217;s <code>iss</code> claim, and</p>
</li>
<li>
<p>Map each scope to an authority with the prefix <code>SCOPE_</code>.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As the authorization server makes available new keys, Spring Security will automatically rotate the keys used to validate JWTs.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The resulting <code>Authentication#getPrincipal</code>, by default, is a Spring Security <code>Jwt</code> object, and <code>Authentication#getName</code> maps to the JWT&#8217;s <code>sub</code> property, if one is present.</p>
</div>
<div class="paragraph">
<p>From here, consider jumping to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2resourceserver-jwt-architecture">How JWT Authentication Works</a></p>
</li>
<li>
<p><a href="#oauth2resourceserver-jwt-jwkseturi">How to Configure without tying Resource Server startup to an authorization server&#8217;s availability</a></p>
</li>
<li>
<p><a href="#oauth2resourceserver-jwt-sansboot">How to Configure without Spring Boot</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-architecture"><a class="anchor" href="#oauth2resourceserver-jwt-architecture"></a>How JWT Authentication Works</h4>
<div class="paragraph">
<p>Next, let&#8217;s see the architectural components that Spring Security uses to support <a href="https://tools.ietf.org/html/rfc7519">JWT</a> Authentication in servlet-based applications, like the one we just saw.</p>
</div>
<div class="paragraph">
<p>{security-api-url}org/springframework/security/oauth2/server/resource/authentication/JwtAuthenticationProvider.html[<code>JwtAuthenticationProvider</code>] is an <a href="#servlet-authentication-authenticationprovider"><code>AuthenticationProvider</code></a> implementation that leverages a <a href="#oauth2resourceserver-jwt-decoder"><code>JwtDecoder</code></a> and <a href="#oauth2resourceserver-jwt-authorization-extraction"><code>JwtAuthenticationConverter</code></a> to authenticate a JWT.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s take a look at how <code>JwtAuthenticationProvider</code> works within Spring Security.
The figure explains details of how the <a href="#servlet-authentication-authenticationmanager"><code>AuthenticationManager</code></a> in figures from <a href="#oauth2resourceserver-authentication-bearertokenauthenticationfilter">Reading the Bearer Token</a> works.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/servlet/oauth2/jwtauthenticationprovider.png" alt="jwtauthenticationprovider">
</div>
<div class="title">Figure 3. <code>JwtAuthenticationProvider</code> Usage</div>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_1.png" alt="number 1"></span> The authentication <code>Filter</code> from <a href="#oauth2resourceserver-authentication-bearertokenauthenticationfilter">Reading the Bearer Token</a> passes a <code>BearerTokenAuthenticationToken</code> to the <code>AuthenticationManager</code> which is implemented by <a href="#servlet-authentication-providermanager"><code>ProviderManager</code></a>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_2.png" alt="number 2"></span> The <code>ProviderManager</code> is configured to use an <a href="#servlet-authentication-authenticationprovider">[servlet-authentication-authenticationprovider]</a> of type <code>JwtAuthenticationProvider</code>.</p>
</div>
<div id="oauth2resourceserver-jwt-architecture-jwtdecoder" class="paragraph">
<p><span class="image"><img src="images/icons/number_3.png" alt="number 3"></span> <code>JwtAuthenticationProvider</code> decodes, verifies, and validates the <code>Jwt</code> using a <a href="#oauth2resourceserver-jwt-decoder"><code>JwtDecoder</code></a>.</p>
</div>
<div id="oauth2resourceserver-jwt-architecture-jwtauthenticationconverter" class="paragraph">
<p><span class="image"><img src="images/icons/number_4.png" alt="number 4"></span> <code>JwtAuthenticationProvider</code> then uses the <a href="#oauth2resourceserver-jwt-authorization-extraction"><code>JwtAuthenticationConverter</code></a> to convert the <code>Jwt</code> into a <code>Collection</code> of granted authorities.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_5.png" alt="number 5"></span> When authentication is successful, the <a href="#servlet-authentication-authentication"><code>Authentication</code></a> that is returned is of type <code>JwtAuthenticationToken</code> and has a principal that is the <code>Jwt</code> returned by the configured <code>JwtDecoder</code>.
Ultimately, the returned <code>JwtAuthenticationToken</code> will be set on the <a href="#servlet-authentication-securitycontextholder"><code>SecurityContextHolder</code></a> by the authentication <code>Filter</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-jwkseturi"><a class="anchor" href="#oauth2resourceserver-jwt-jwkseturi"></a>Specifying the Authorization Server JWK Set Uri Directly</h4>
<div class="paragraph">
<p>If the authorization server doesn&#8217;t support any configuration endpoints, or if Resource Server must be able to start up independently from the authorization server, then the <code>jwk-set-uri</code> can be supplied as well:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: https://idp.example.com
          jwk-set-uri: https://idp.example.com/.well-known/jwks.json</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The JWK Set uri is not standardized, but can typically be found in the authorization server&#8217;s documentation
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Consequently, Resource Server will not ping the authorization server at startup.
We still specify the <code>issuer-uri</code> so that Resource Server still validates the <code>iss</code> claim on incoming JWTs.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This property can also be supplied directly on the <a href="#oauth2resourceserver-jwt-jwkseturi-dsl">DSL</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-sansboot"><a class="anchor" href="#oauth2resourceserver-jwt-sansboot"></a>Overriding or Replacing Boot Auto Configuration</h4>
<div class="paragraph">
<p>There are two <code>@Bean</code> s that Spring Boot generates on Resource Server&#8217;s behalf.</p>
</div>
<div class="paragraph">
<p>The first is a <code>WebSecurityConfigurerAdapter</code> that configures the app as a resource server. When including <code>spring-security-oauth2-jose</code>, this <code>WebSecurityConfigurerAdapter</code> looks like:</p>
</div>
<div class="exampleblock">
<div class="title">Example 17. Default JWT Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">protected void configure(HttpSecurity http) {
    http
        .authorizeRequests(authorize -&gt; authorize
            .anyRequest().authenticated()
        )
        .oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun configure(http: HttpSecurity) {
    http {
        authorizeRequests {
            authorize(anyRequest, authenticated)
        }
        oauth2ResourceServer {
            jwt { }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the application doesn&#8217;t expose a <code>WebSecurityConfigurerAdapter</code> bean, then Spring Boot will expose the above default one.</p>
</div>
<div class="paragraph">
<p>Replacing this is as simple as exposing the bean within the application:</p>
</div>
<div class="exampleblock">
<div class="title">Example 18. Custom JWT Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class MyCustomSecurityConfiguration extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -&gt; authorize
                .mvcMatchers("/messages/**").hasAuthority("SCOPE_message:read")
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -&gt; oauth2
                .jwt(jwt -&gt; jwt
                    .jwtAuthenticationConverter(myConverter())
                )
            );
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class MyCustomSecurityConfiguration : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize("/messages/**", hasAuthority("SCOPE_message:read"))
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                jwt {
                    jwtAuthenticationConverter = myConverter()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The above requires the scope of <code>message:read</code> for any URL that starts with <code>/messages/</code>.</p>
</div>
<div class="paragraph">
<p>Methods on the <code>oauth2ResourceServer</code> DSL will also override or replace auto configuration.</p>
</div>
<div id="oauth2resourceserver-jwt-decoder" class="paragraph">
<p>For example, the second <code>@Bean</code> Spring Boot creates is a <code>JwtDecoder</code>, which <a href="#oauth2resourceserver-jwt-architecture-jwtdecoder">decodes <code>String</code> tokens into validated instances of <code>Jwt</code></a>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 19. JWT Decoder</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public JwtDecoder jwtDecoder() {
    return JwtDecoders.fromIssuerLocation(issuerUri);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    return JwtDecoders.fromIssuerLocation(issuerUri)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Calling <code>{security-api-url}org/springframework/security/oauth2/jwt/JwtDecoders.html#fromIssuerLocation-java.lang.String-[JwtDecoders#fromIssuerLocation]</code> is what invokes the Provider Configuration or Authorization Server Metadata endpoint in order to derive the JWK Set Uri.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the application doesn&#8217;t expose a <code>JwtDecoder</code> bean, then Spring Boot will expose the above default one.</p>
</div>
<div class="paragraph">
<p>And its configuration can be overridden using <code>jwkSetUri()</code> or replaced using <code>decoder()</code>.</p>
</div>
<div class="paragraph">
<p>Or, if you&#8217;re not using Spring Boot at all, then both of these components - the filter chain and a <code>JwtDecoder</code> can be specified in XML.</p>
</div>
<div class="paragraph">
<p>The filter chain is specified like so:</p>
</div>
<div class="exampleblock">
<div class="title">Example 20. Default JWT Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
    &lt;intercept-uri pattern="/**" access="authenticated"/&gt;
    &lt;oauth2-resource-server&gt;
        &lt;jwt decoder-ref="jwtDecoder"/&gt;
    &lt;/oauth2-resource-server&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>And the <code>JwtDecoder</code> like so:</p>
</div>
<div class="exampleblock">
<div class="title">Example 21. JWT Decoder</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="jwtDecoder"
        class="org.springframework.security.oauth2.jwt.JwtDecoders"
        factory-method="fromIssuerLocation"&gt;
    &lt;constructor-arg value="${spring.security.oauth2.resourceserver.jwt.jwk-set-uri}"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-jwkseturi-dsl"><a class="anchor" href="#oauth2resourceserver-jwt-jwkseturi-dsl"></a>Using <code>jwkSetUri()</code></h5>
<div class="paragraph">
<p>An authorization server&#8217;s JWK Set Uri can be configured <a href="#oauth2resourceserver-jwt-jwkseturi">as a configuration property</a> or it can be supplied in the DSL:</p>
</div>
<div class="exampleblock">
<div class="title">Example 22. JWK Set Uri Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class DirectlyConfiguredJwkSetUri extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -&gt; authorize
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -&gt; oauth2
                .jwt(jwt -&gt; jwt
                    .jwkSetUri("https://idp.example.com/.well-known/jwks.json")
                )
            );
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class DirectlyConfiguredJwkSetUri : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                jwt {
                    jwkSetUri = "https://idp.example.com/.well-known/jwks.json"
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
    &lt;intercept-uri pattern="/**" access="authenticated"/&gt;
    &lt;oauth2-resource-server&gt;
        &lt;jwt jwk-set-uri="https://idp.example.com/.well-known/jwks.json"/&gt;
    &lt;/oauth2-resource-server&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Using <code>jwkSetUri()</code> takes precedence over any configuration property.</p>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-decoder-dsl"><a class="anchor" href="#oauth2resourceserver-jwt-decoder-dsl"></a>Using <code>decoder()</code></h5>
<div class="paragraph">
<p>More powerful than <code>jwkSetUri()</code> is <code>decoder()</code>, which will completely replace any Boot auto configuration of <a href="#oauth2resourceserver-jwt-architecture-jwtdecoder"><code>JwtDecoder</code></a>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 23. JWT Decoder Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class DirectlyConfiguredJwtDecoder extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -&gt; authorize
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -&gt; oauth2
                .jwt(jwt -&gt; jwt
                    .decoder(myCustomDecoder())
                )
            );
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class DirectlyConfiguredJwtDecoder : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                jwt {
                    jwtDecoder = myCustomDecoder()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
    &lt;intercept-uri pattern="/**" access="authenticated"/&gt;
    &lt;oauth2-resource-server&gt;
        &lt;jwt decoder-ref="myCustomDecoder"/&gt;
    &lt;/oauth2-resource-server&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This is handy when deeper configuration, like <a href="#oauth2resourceserver-jwt-validation">validation</a>, <a href="#oauth2resourceserver-jwt-claimsetmapping">mapping</a>, or <a href="#oauth2resourceserver-jwt-timeouts">request timeouts</a>, is necessary.</p>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-decoder-bean"><a class="anchor" href="#oauth2resourceserver-jwt-decoder-bean"></a>Exposing a <code>JwtDecoder</code> <code>@Bean</code></h5>
<div class="paragraph">
<p>Or, exposing a <a href="#oauth2resourceserver-jwt-architecture-jwtdecoder"><code>JwtDecoder</code></a> <code>@Bean</code> has the same effect as <code>decoder()</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public JwtDecoder jwtDecoder() {
    return NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    return NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-decoder-algorithm"><a class="anchor" href="#oauth2resourceserver-jwt-decoder-algorithm"></a>Configuring Trusted Algorithms</h4>
<div class="paragraph">
<p>By default, <code>NimbusJwtDecoder</code>, and hence Resource Server, will only trust and verify tokens using <code>RS256</code>.</p>
</div>
<div class="paragraph">
<p>You can customize this via <a href="#oauth2resourceserver-jwt-boot-algorithm">Spring Boot</a>, <a href="#oauth2resourceserver-jwt-decoder-builder">the NimbusJwtDecoder builder</a>, or from the <a href="#oauth2resourceserver-jwt-decoder-jwk-response">JWK Set response</a>.</p>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-boot-algorithm"><a class="anchor" href="#oauth2resourceserver-jwt-boot-algorithm"></a>Via Spring Boot</h5>
<div class="paragraph">
<p>The simplest way to set the algorithm is as a property:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          jws-algorithm: RS512
          jwk-set-uri: https://idp.example.org/.well-known/jwks.json</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-decoder-builder"><a class="anchor" href="#oauth2resourceserver-jwt-decoder-builder"></a>Using a Builder</h5>
<div class="paragraph">
<p>For greater power, though, we can use a builder that ships with <code>NimbusJwtDecoder</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
JwtDecoder jwtDecoder() {
    return NimbusJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithm(RS512).build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    return NimbusJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithm(RS512).build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Calling <code>jwsAlgorithm</code> more than once will configure <code>NimbusJwtDecoder</code> to trust more than one algorithm, like so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
JwtDecoder jwtDecoder() {
    return NimbusJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithm(RS512).jwsAlgorithm(ES512).build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    return NimbusJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithm(RS512).jwsAlgorithm(ES512).build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Or, you can call <code>jwsAlgorithms</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
JwtDecoder jwtDecoder() {
    return NimbusJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithms(algorithms -&gt; {
                    algorithms.add(RS512);
                    algorithms.add(ES512);
            }).build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    return NimbusJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithms {
                it.add(RS512)
                it.add(ES512)
            }.build()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-decoder-jwk-response"><a class="anchor" href="#oauth2resourceserver-jwt-decoder-jwk-response"></a>From JWK Set response</h5>
<div class="paragraph">
<p>Since Spring Security&#8217;s JWT support is based off of Nimbus, you can use all it&#8217;s great features as well.</p>
</div>
<div class="paragraph">
<p>For example, Nimbus has a <code>JWSKeySelector</code> implementation that will select the set of algorithms based on the JWK Set URI response.
You can use it to generate a <code>NimbusJwtDecoder</code> like so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public JwtDecoder jwtDecoder() {
    // makes a request to the JWK Set endpoint
    JWSKeySelector&lt;SecurityContext&gt; jwsKeySelector =
            JWSAlgorithmFamilyJWSKeySelector.fromJWKSetURL(this.jwkSetUrl);

    DefaultJWTProcessor&lt;SecurityContext&gt; jwtProcessor =
            new DefaultJWTProcessor&lt;&gt;();
    jwtProcessor.setJWSKeySelector(jwsKeySelector);

    return new NimbusJwtDecoder(jwtProcessor);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    // makes a request to the JWK Set endpoint
    val jwsKeySelector: JWSKeySelector&lt;SecurityContext&gt; = JWSAlgorithmFamilyJWSKeySelector.fromJWKSetURL&lt;SecurityContext&gt;(this.jwkSetUrl)
    val jwtProcessor: DefaultJWTProcessor&lt;SecurityContext&gt; = DefaultJWTProcessor()
    jwtProcessor.jwsKeySelector = jwsKeySelector
    return NimbusJwtDecoder(jwtProcessor)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-decoder-public-key"><a class="anchor" href="#oauth2resourceserver-jwt-decoder-public-key"></a>Trusting a Single Asymmetric Key</h4>
<div class="paragraph">
<p>Simpler than backing a Resource Server with a JWK Set endpoint is to hard-code an RSA public key.
The public key can be provided via <a href="#oauth2resourceserver-jwt-decoder-public-key-boot">Spring Boot</a> or by <a href="#oauth2resourceserver-jwt-decoder-public-key-builder">Using a Builder</a>.</p>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-decoder-public-key-boot"><a class="anchor" href="#oauth2resourceserver-jwt-decoder-public-key-boot"></a>Via Spring Boot</h5>
<div class="paragraph">
<p>Specifying a key via Spring Boot is quite simple.
The key&#8217;s location can be specified like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          public-key-location: classpath:my-key.pub</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or, to allow for a more sophisticated lookup, you can post-process the <code>RsaKeyConversionServicePostProcessor</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
BeanFactoryPostProcessor conversionServiceCustomizer() {
    return beanFactory -&gt;
        beanFactory.getBean(RsaKeyConversionServicePostProcessor.class)
                .setResourceLoader(new CustomResourceLoader());
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun conversionServiceCustomizer(): BeanFactoryPostProcessor {
    return BeanFactoryPostProcessor { beanFactory -&gt;
        beanFactory.getBean&lt;RsaKeyConversionServicePostProcessor&gt;()
                .setResourceLoader(CustomResourceLoader())
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Specify your key&#8217;s location:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">key.location: hfds://my-key.pub</code></pre>
</div>
</div>
<div class="paragraph">
<p>And then autowire the value:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Value("${key.location}")
RSAPublicKey key;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Value("\${key.location}")
val key: RSAPublicKey? = null</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-decoder-public-key-builder"><a class="anchor" href="#oauth2resourceserver-jwt-decoder-public-key-builder"></a>Using a Builder</h5>
<div class="paragraph">
<p>To wire an <code>RSAPublicKey</code> directly, you can simply use the appropriate <code>NimbusJwtDecoder</code> builder, like so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public JwtDecoder jwtDecoder() {
    return NimbusJwtDecoder.withPublicKey(this.key).build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    return NimbusJwtDecoder.withPublicKey(this.key).build()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-decoder-secret-key"><a class="anchor" href="#oauth2resourceserver-jwt-decoder-secret-key"></a>Trusting a Single Symmetric Key</h4>
<div class="paragraph">
<p>Using a single symmetric key is also simple.
You can simply load in your <code>SecretKey</code> and use the appropriate <code>NimbusJwtDecoder</code> builder, like so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public JwtDecoder jwtDecoder() {
    return NimbusJwtDecoder.withSecretKey(this.key).build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    return NimbusJwtDecoder.withSecretKey(key).build()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-authorization"><a class="anchor" href="#oauth2resourceserver-jwt-authorization"></a>Configuring Authorization</h4>
<div class="paragraph">
<p>A JWT that is issued from an OAuth 2.0 Authorization Server will typically either have a <code>scope</code> or <code>scp</code> attribute, indicating the scopes (or authorities) it&#8217;s been granted, for example:</p>
</div>
<div class="paragraph">
<p><code>{ &#8230;&#8203;, "scope" : "messages contacts"}</code></p>
</div>
<div class="paragraph">
<p>When this is the case, Resource Server will attempt to coerce these scopes into a list of granted authorities, prefixing each scope with the string "SCOPE_".</p>
</div>
<div class="paragraph">
<p>This means that to protect an endpoint or method with a scope derived from a JWT, the corresponding expressions should include this prefix:</p>
</div>
<div class="exampleblock">
<div class="title">Example 24. Authorization Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class DirectlyConfiguredJwkSetUri extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -&gt; authorize
                .mvcMatchers("/contacts/**").hasAuthority("SCOPE_contacts")
                .mvcMatchers("/messages/**").hasAuthority("SCOPE_messages")
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class DirectlyConfiguredJwkSetUri : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize("/contacts/**", hasAuthority("SCOPE_contacts"))
                authorize("/messages/**", hasAuthority("SCOPE_messages"))
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                jwt { }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
    &lt;intercept-uri pattern="/contacts/**" access="hasAuthority('SCOPE_contacts')"/&gt;
    &lt;intercept-uri pattern="/messages/**" access="hasAuthority('SCOPE_messages')"/&gt;
    &lt;oauth2-resource-server&gt;
        &lt;jwt jwk-set-uri="https://idp.example.org/.well-known/jwks.json"/&gt;
    &lt;/oauth2-resource-server&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Or similarly with method security:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PreAuthorize("hasAuthority('SCOPE_messages')")
public List&lt;Message&gt; getMessages(...) {}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-authorization-extraction"><a class="anchor" href="#oauth2resourceserver-jwt-authorization-extraction"></a>Extracting Authorities Manually</h5>
<div class="paragraph">
<p>However, there are a number of circumstances where this default is insufficient.
For example, some authorization servers don&#8217;t use the <code>scope</code> attribute, but instead have their own custom attribute.
Or, at other times, the resource server may need to adapt the attribute or a composition of attributes into internalized authorities.</p>
</div>
<div class="paragraph">
<p>To this end, Spring Security ships with <code>JwtAuthenticationConverter</code>, which is responsible for <a href="#oauth2resourceserver-jwt-architecture-jwtauthenticationconverter">converting a <code>Jwt</code> into an <code>Authentication</code></a>.
By default, Spring Security will wire the <code>JwtAuthenticationProvider</code> with a default instance of <code>JwtAuthenticationConverter</code>.</p>
</div>
<div class="paragraph">
<p>As part of configuring a <code>JwtAuthenticationConverter</code>, you can supply a subsidiary converter to go from <code>Jwt</code> to a <code>Collection</code> of granted authorities.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say that that your authorization server communicates authorities in a custom claim called <code>authorities</code>.
In that case, you can configure the claim that <a href="#oauth2resourceserver-jwt-architecture-jwtauthenticationconverter"><code>JwtAuthenticationConverter</code></a> should inspect, like so:</p>
</div>
<div class="exampleblock">
<div class="title">Example 25. Authorities Claim Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public JwtAuthenticationConverter jwtAuthenticationConverter() {
    JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
    grantedAuthoritiesConverter.setAuthoritiesClaimName("authorities");

    JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
    jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter);
    return jwtAuthenticationConverter;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtAuthenticationConverter(): JwtAuthenticationConverter {
    val grantedAuthoritiesConverter = JwtGrantedAuthoritiesConverter()
    grantedAuthoritiesConverter.setAuthoritiesClaimName("authorities")

    val jwtAuthenticationConverter = JwtAuthenticationConverter()
    jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter)
    return jwtAuthenticationConverter
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
    &lt;intercept-uri pattern="/contacts/**" access="hasAuthority('SCOPE_contacts')"/&gt;
    &lt;intercept-uri pattern="/messages/**" access="hasAuthority('SCOPE_messages')"/&gt;
    &lt;oauth2-resource-server&gt;
        &lt;jwt jwk-set-uri="https://idp.example.org/.well-known/jwks.json"
                jwt-authentication-converter-ref="jwtAuthenticationConverter"/&gt;
    &lt;/oauth2-resource-server&gt;
&lt;/http&gt;

&lt;bean id="jwtAuthenticationConverter"
        class="org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter"&gt;
    &lt;property name="jwtGrantedAuthoritiesConverter" ref="jwtGrantedAuthoritiesConverter"/&gt;
&lt;/bean&gt;

&lt;bean id="jwtGrantedAuthoritiesConverter"
        class="org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter"&gt;
    &lt;property name="authoritiesClaimName" value="authorities"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also configure the authority prefix to be different as well.
Instead of prefixing each authority with <code>SCOPE_</code>, you can change it to <code>ROLE_</code> like so:</p>
</div>
<div class="exampleblock">
<div class="title">Example 26. Authorities Prefix Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public JwtAuthenticationConverter jwtAuthenticationConverter() {
    JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
    grantedAuthoritiesConverter.setAuthorityPrefix("ROLE_");

    JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
    jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter);
    return jwtAuthenticationConverter;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtAuthenticationConverter(): JwtAuthenticationConverter {
    val grantedAuthoritiesConverter = JwtGrantedAuthoritiesConverter()
    grantedAuthoritiesConverter.setAuthorityPrefix("ROLE_")

    val jwtAuthenticationConverter = JwtAuthenticationConverter()
    jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter)
    return jwtAuthenticationConverter
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
    &lt;intercept-uri pattern="/contacts/**" access="hasAuthority('SCOPE_contacts')"/&gt;
    &lt;intercept-uri pattern="/messages/**" access="hasAuthority('SCOPE_messages')"/&gt;
    &lt;oauth2-resource-server&gt;
        &lt;jwt jwk-set-uri="https://idp.example.org/.well-known/jwks.json"
                jwt-authentication-converter-ref="jwtAuthenticationConverter"/&gt;
    &lt;/oauth2-resource-server&gt;
&lt;/http&gt;

&lt;bean id="jwtAuthenticationConverter"
        class="org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter"&gt;
    &lt;property name="jwtGrantedAuthoritiesConverter" ref="jwtGrantedAuthoritiesConverter"/&gt;
&lt;/bean&gt;

&lt;bean id="jwtGrantedAuthoritiesConverter"
        class="org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter"&gt;
    &lt;property name="authorityPrefix" value="ROLE_"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Or, you can remove the prefix altogether by calling <code>JwtGrantedAuthoritiesConverter#setAuthorityPrefix("")</code>.</p>
</div>
<div class="paragraph">
<p>For more flexibility, the DSL supports entirely replacing the converter with any class that implements <code>Converter&lt;Jwt, AbstractAuthenticationToken&gt;</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">static class CustomAuthenticationConverter implements Converter&lt;Jwt, AbstractAuthenticationToken&gt; {
    public AbstractAuthenticationToken convert(Jwt jwt) {
        return new CustomAuthenticationToken(jwt);
    }
}

// ...

@EnableWebSecurity
public class CustomAuthenticationConverterConfig extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -&gt; authorize
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -&gt; oauth2
                .jwt(jwt -&gt; jwt
                    .jwtAuthenticationConverter(new CustomAuthenticationConverter())
                )
            );
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">internal class CustomAuthenticationConverter : Converter&lt;Jwt, AbstractAuthenticationToken&gt; {
    override fun convert(jwt: Jwt): AbstractAuthenticationToken {
        return CustomAuthenticationToken(jwt)
    }
}

// ...

@EnableWebSecurity
class CustomAuthenticationConverterConfig : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
       http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
           oauth2ResourceServer {
               jwt {
                   jwtAuthenticationConverter = CustomAuthenticationConverter()
               }
           }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-validation"><a class="anchor" href="#oauth2resourceserver-jwt-validation"></a>Configuring Validation</h4>
<div class="paragraph">
<p>Using <a href="#oauth2resourceserver-jwt-minimalconfiguration">minimal Spring Boot configuration</a>, indicating the authorization server&#8217;s issuer uri, Resource Server will default to verifying the <code>iss</code> claim as well as the <code>exp</code> and <code>nbf</code> timestamp claims.</p>
</div>
<div class="paragraph">
<p>In circumstances where validation needs to be customized, Resource Server ships with two standard validators and also accepts custom <code>OAuth2TokenValidator</code> instances.</p>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-validation-clockskew"><a class="anchor" href="#oauth2resourceserver-jwt-validation-clockskew"></a>Customizing Timestamp Validation</h5>
<div class="paragraph">
<p>JWT&#8217;s typically have a window of validity, with the start of the window indicated in the <code>nbf</code> claim and the end indicated in the <code>exp</code> claim.</p>
</div>
<div class="paragraph">
<p>However, every server can experience clock drift, which can cause tokens to appear expired to one server, but not to another.
This can cause some implementation heartburn as the number of collaborating servers increases in a distributed system.</p>
</div>
<div class="paragraph">
<p>Resource Server uses <code>JwtTimestampValidator</code> to verify a token&#8217;s validity window, and it can be configured with a <code>clockSkew</code> to alleviate the above problem:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
JwtDecoder jwtDecoder() {
     NimbusJwtDecoder jwtDecoder = (NimbusJwtDecoder)
             JwtDecoders.fromIssuerLocation(issuerUri);

     OAuth2TokenValidator&lt;Jwt&gt; withClockSkew = new DelegatingOAuth2TokenValidator&lt;&gt;(
            new JwtTimestampValidator(Duration.ofSeconds(60)),
            new JwtIssuerValidator(issuerUri));

     jwtDecoder.setJwtValidator(withClockSkew);

     return jwtDecoder;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    val jwtDecoder: NimbusJwtDecoder = JwtDecoders.fromIssuerLocation(issuerUri) as NimbusJwtDecoder

    val withClockSkew: OAuth2TokenValidator&lt;Jwt&gt; = DelegatingOAuth2TokenValidator(
            JwtTimestampValidator(Duration.ofSeconds(60)),
            JwtIssuerValidator(issuerUri))

    jwtDecoder.setJwtValidator(withClockSkew)

    return jwtDecoder
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
By default, Resource Server configures a clock skew of 60 seconds.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-validation-custom"><a class="anchor" href="#oauth2resourceserver-jwt-validation-custom"></a>Configuring a Custom Validator</h5>
<div class="paragraph">
<p>Adding a check for the <code>aud</code> claim is simple with the <code>OAuth2TokenValidator</code> API:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">OAuth2TokenValidator&lt;Jwt&gt; audienceValidator() {
    return new JwtClaimValidator&lt;List&lt;String&gt;&gt;(AUD, aud -&gt; aud.contains("messaging"));
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun audienceValidator(): OAuth2TokenValidator&lt;Jwt?&gt; {
    return JwtClaimValidator&lt;List&lt;String&gt;&gt;(AUD) { aud -&gt; aud.contains("messaging") }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Or, for more control you can implement your own <code>OAuth2TokenValidator</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">static class AudienceValidator implements OAuth2TokenValidator&lt;Jwt&gt; {
    OAuth2Error error = new OAuth2Error("custom_code", "Custom error message", null);

    @Override
    public OAuth2TokenValidatorResult validate(Jwt jwt) {
        if (jwt.getAudience().contains("messaging")) {
            return OAuth2TokenValidatorResult.success();
        } else {
            return OAuth2TokenValidatorResult.failure(error);
        }
    }
}

// ...

OAuth2TokenValidator&lt;Jwt&gt; audienceValidator() {
    return new AudienceValidator();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">internal class AudienceValidator : OAuth2TokenValidator&lt;Jwt&gt; {
    var error: OAuth2Error = OAuth2Error("custom_code", "Custom error message", null)

    override fun validate(jwt: Jwt): OAuth2TokenValidatorResult {
        return if (jwt.audience.contains("messaging")) {
            OAuth2TokenValidatorResult.success()
        } else {
            OAuth2TokenValidatorResult.failure(error)
        }
    }
}

// ...

fun audienceValidator(): OAuth2TokenValidator&lt;Jwt&gt; {
    return AudienceValidator()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Then, to add into a resource server, it&#8217;s a matter of specifying the <a href="#oauth2resourceserver-jwt-architecture-jwtdecoder"><code>JwtDecoder</code></a> instance:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
JwtDecoder jwtDecoder() {
    NimbusJwtDecoder jwtDecoder = (NimbusJwtDecoder)
        JwtDecoders.fromIssuerLocation(issuerUri);

    OAuth2TokenValidator&lt;Jwt&gt; audienceValidator = audienceValidator();
    OAuth2TokenValidator&lt;Jwt&gt; withIssuer = JwtValidators.createDefaultWithIssuer(issuerUri);
    OAuth2TokenValidator&lt;Jwt&gt; withAudience = new DelegatingOAuth2TokenValidator&lt;&gt;(withIssuer, audienceValidator);

    jwtDecoder.setJwtValidator(withAudience);

    return jwtDecoder;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    val jwtDecoder: NimbusJwtDecoder = JwtDecoders.fromIssuerLocation(issuerUri) as NimbusJwtDecoder

    val audienceValidator = audienceValidator()
    val withIssuer: OAuth2TokenValidator&lt;Jwt&gt; = JwtValidators.createDefaultWithIssuer(issuerUri)
    val withAudience: OAuth2TokenValidator&lt;Jwt&gt; = DelegatingOAuth2TokenValidator(withIssuer, audienceValidator)

    jwtDecoder.setJwtValidator(withAudience)

    return jwtDecoder
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-claimsetmapping"><a class="anchor" href="#oauth2resourceserver-jwt-claimsetmapping"></a>Configuring Claim Set Mapping</h4>
<div class="paragraph">
<p>Spring Security uses the <a href="https://bitbucket.org/connect2id/nimbus-jose-jwt/wiki/Home">Nimbus</a> library for parsing JWTs and validating their signatures.
Consequently, Spring Security is subject to Nimbus&#8217;s interpretation of each field value and how to coerce each into a Java type.</p>
</div>
<div class="paragraph">
<p>For example, because Nimbus remains Java 7 compatible, it doesn&#8217;t use <code>Instant</code> to represent timestamp fields.</p>
</div>
<div class="paragraph">
<p>And it&#8217;s entirely possible to use a different library or for JWT processing, which may make its own coercion decisions that need adjustment.</p>
</div>
<div class="paragraph">
<p>Or, quite simply, a resource server may want to add or remove claims from a JWT for domain-specific reasons.</p>
</div>
<div class="paragraph">
<p>For these purposes, Resource Server supports mapping the JWT claim set with <code>MappedJwtClaimSetConverter</code>.</p>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-claimsetmapping-singleclaim"><a class="anchor" href="#oauth2resourceserver-jwt-claimsetmapping-singleclaim"></a>Customizing the Conversion of a Single Claim</h5>
<div class="paragraph">
<p>By default, <code>MappedJwtClaimSetConverter</code> will attempt to coerce claims into the following types:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Claim</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Java Type</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>aud</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Collection&lt;String&gt;</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>exp</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Instant</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iat</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Instant</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iss</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>jti</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>nbf</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Instant</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sub</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>An individual claim&#8217;s conversion strategy can be configured using <code>MappedJwtClaimSetConverter.withDefaults</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
JwtDecoder jwtDecoder() {
    NimbusJwtDecoder jwtDecoder = NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build();

    MappedJwtClaimSetConverter converter = MappedJwtClaimSetConverter
            .withDefaults(Collections.singletonMap("sub", this::lookupUserIdBySub));
    jwtDecoder.setClaimSetConverter(converter);

    return jwtDecoder;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    val jwtDecoder = NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build()

    val converter = MappedJwtClaimSetConverter
            .withDefaults(mapOf("sub" to this::lookupUserIdBySub))
    jwtDecoder.setClaimSetConverter(converter)

    return jwtDecoder
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This will keep all the defaults, except it will override the default claim converter for <code>sub</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-claimsetmapping-add"><a class="anchor" href="#oauth2resourceserver-jwt-claimsetmapping-add"></a>Adding a Claim</h5>
<div class="paragraph">
<p><code>MappedJwtClaimSetConverter</code> can also be used to add a custom claim, for example, to adapt to an existing system:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MappedJwtClaimSetConverter.withDefaults(Collections.singletonMap("custom", custom -&gt; "value"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">MappedJwtClaimSetConverter.withDefaults(mapOf("custom" to Converter&lt;Any, String&gt; { "value" }))</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-claimsetmapping-remove"><a class="anchor" href="#oauth2resourceserver-jwt-claimsetmapping-remove"></a>Removing a Claim</h5>
<div class="paragraph">
<p>And removing a claim is also simple, using the same API:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MappedJwtClaimSetConverter.withDefaults(Collections.singletonMap("legacyclaim", legacy -&gt; null));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">MappedJwtClaimSetConverter.withDefaults(mapOf("legacyclaim" to Converter&lt;Any, Any&gt; { null }))</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-claimsetmapping-rename"><a class="anchor" href="#oauth2resourceserver-jwt-claimsetmapping-rename"></a>Renaming a Claim</h5>
<div class="paragraph">
<p>In more sophisticated scenarios, like consulting multiple claims at once or renaming a claim, Resource Server accepts any class that implements <code>Converter&lt;Map&lt;String, Object&gt;, Map&lt;String,Object&gt;&gt;</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class UsernameSubClaimAdapter implements Converter&lt;Map&lt;String, Object&gt;, Map&lt;String, Object&gt;&gt; {
    private final MappedJwtClaimSetConverter delegate =
            MappedJwtClaimSetConverter.withDefaults(Collections.emptyMap());

    public Map&lt;String, Object&gt; convert(Map&lt;String, Object&gt; claims) {
        Map&lt;String, Object&gt; convertedClaims = this.delegate.convert(claims);

        String username = (String) convertedClaims.get("user_name");
        convertedClaims.put("sub", username);

        return convertedClaims;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class UsernameSubClaimAdapter : Converter&lt;Map&lt;String, Any?&gt;, Map&lt;String, Any?&gt;&gt; {
    private val delegate = MappedJwtClaimSetConverter.withDefaults(Collections.emptyMap())
    override fun convert(claims: Map&lt;String, Any?&gt;): Map&lt;String, Any?&gt; {
        val convertedClaims = delegate.convert(claims)
        val username = convertedClaims["user_name"] as String
        convertedClaims["sub"] = username
        return convertedClaims
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>And then, the instance can be supplied like normal:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
JwtDecoder jwtDecoder() {
    NimbusJwtDecoder jwtDecoder = NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build();
    jwtDecoder.setClaimSetConverter(new UsernameSubClaimAdapter());
    return jwtDecoder;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    val jwtDecoder: NimbusJwtDecoder = NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build()
    jwtDecoder.setClaimSetConverter(UsernameSubClaimAdapter())
    return jwtDecoder
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-timeouts"><a class="anchor" href="#oauth2resourceserver-jwt-timeouts"></a>Configuring Timeouts</h4>
<div class="paragraph">
<p>By default, Resource Server uses connection and socket timeouts of 30 seconds each for coordinating with the authorization server.</p>
</div>
<div class="paragraph">
<p>This may be too short in some scenarios.
Further, it doesn&#8217;t take into account more sophisticated patterns like back-off and discovery.</p>
</div>
<div class="paragraph">
<p>To adjust the way in which Resource Server connects to the authorization server, <code>NimbusJwtDecoder</code> accepts an instance of <code>RestOperations</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public JwtDecoder jwtDecoder(RestTemplateBuilder builder) {
    RestOperations rest = builder
            .setConnectTimeout(Duration.ofSeconds(60))
            .setReadTimeout(Duration.ofSeconds(60))
            .build();

    NimbusJwtDecoder jwtDecoder = NimbusJwtDecoder.withJwkSetUri(jwkSetUri).restOperations(rest).build();
    return jwtDecoder;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(builder: RestTemplateBuilder): JwtDecoder {
    val rest: RestOperations = builder
            .setConnectTimeout(Duration.ofSeconds(60))
            .setReadTimeout(Duration.ofSeconds(60))
            .build()
    return NimbusJwtDecoder.withJwkSetUri(jwkSetUri).restOperations(rest).build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Also by default, Resource Server caches in-memory the authorization server&#8217;s JWK set for 5 minutes, which you may want to adjust.
Further, it doesn&#8217;t take into account more sophisticated caching patterns like eviction or using a shared cache.</p>
</div>
<div class="paragraph">
<p>To adjust the way in which Resource Server caches the JWK set, <code>NimbusJwtDecoder</code> accepts an instance of <code>Cache</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public JwtDecoder jwtDecoder(CacheManager cacheManager) {
    return NimbusJwtDecoder.withJwkSetUri(jwkSetUri)
            .cache(cacheManager.getCache("jwks"))
            .build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(cacheManager: CacheManager): JwtDecoder {
    return NimbusJwtDecoder.withJwkSetUri(jwkSetUri)
            .cache(cacheManager.getCache("jwks"))
            .build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When given a <code>Cache</code>, Resource Server will use the JWK Set Uri as the key and the JWK Set JSON as the value.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring isn&#8217;t a cache provider, so you&#8217;ll need to make sure to include the appropriate dependencies, like <code>spring-boot-starter-cache</code> and your favorite caching provider.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Whether it&#8217;s socket or cache timeouts, you may instead want to work with Nimbus directly.
To do so, remember that <code>NimbusJwtDecoder</code> ships with a constructor that takes Nimbus&#8217;s <code>JWTProcessor</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-opaque-minimaldependencies"><a class="anchor" href="#oauth2resourceserver-opaque-minimaldependencies"></a>Minimal Dependencies for Introspection</h4>
<div class="paragraph">
<p>As described in <a href="#oauth2resourceserver-jwt-minimaldependencies">Minimal Dependencies for JWT</a> most of Resource Server support is collected in <code>spring-security-oauth2-resource-server</code>.
However unless a custom <a href="#oauth2resourceserver-opaque-introspector"><code>OpaqueTokenIntrospector</code></a> is provided, the Resource Server will fallback to NimbusOpaqueTokenIntrospector.
Meaning that both <code>spring-security-oauth2-resource-server</code> and <code>oauth2-oidc-sdk</code> are necessary in order to have a working minimal Resource Server that supports opaque Bearer Tokens.
Please refer to <code>spring-security-oauth2-resource-server</code> in order to determin the correct version for <code>oauth2-oidc-sdk</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-opaque-minimalconfiguration"><a class="anchor" href="#oauth2resourceserver-opaque-minimalconfiguration"></a>Minimal Configuration for Introspection</h4>
<div class="paragraph">
<p>Typically, an opaque token can be verified via an <a href="https://tools.ietf.org/html/rfc7662">OAuth 2.0 Introspection Endpoint</a>, hosted by the authorization server.
This can be handy when revocation is a requirement.</p>
</div>
<div class="paragraph">
<p>When using <a href="https://spring.io/projects/spring-boot">Spring Boot</a>, configuring an application as a resource server that uses introspection consists of two basic steps.
First, include the needed dependencies and second, indicate the introspection endpoint details.</p>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-opaque-introspectionuri"><a class="anchor" href="#oauth2resourceserver-opaque-introspectionuri"></a>Specifying the Authorization Server</h5>
<div class="paragraph">
<p>To specify where the introspection endpoint is, simply do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">security:
  oauth2:
    resourceserver:
      opaque-token:
        introspection-uri: https://idp.example.com/introspect
        client-id: client
        client-secret: secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>Where <code><a href="https://idp.example.com/introspect" class="bare">https://idp.example.com/introspect</a></code> is the introspection endpoint hosted by your authorization server and <code>client-id</code> and <code>client-secret</code> are the credentials needed to hit that endpoint.</p>
</div>
<div class="paragraph">
<p>Resource Server will use these properties to further self-configure and subsequently validate incoming JWTs.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When using introspection, the authorization server&#8217;s word is the law.
If the authorization server responses that the token is valid, then it is.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>And that&#8217;s it!</p>
</div>
</div>
<div class="sect4">
<h5 id="_startup_expectations_2"><a class="anchor" href="#_startup_expectations_2"></a>Startup Expectations</h5>
<div class="paragraph">
<p>When this property and these dependencies are used, Resource Server will automatically configure itself to validate Opaque Bearer Tokens.</p>
</div>
<div class="paragraph">
<p>This startup process is quite a bit simpler than for JWTs since no endpoints need to be discovered and no additional validation rules get added.</p>
</div>
</div>
<div class="sect4">
<h5 id="_runtime_expectations_2"><a class="anchor" href="#_runtime_expectations_2"></a>Runtime Expectations</h5>
<div class="paragraph">
<p>Once the application is started up, Resource Server will attempt to process any request containing an <code>Authorization: Bearer</code> header:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-http hljs" data-lang="http">GET / HTTP/1.1
Authorization: Bearer some-token-value # Resource Server will process this</code></pre>
</div>
</div>
<div class="paragraph">
<p>So long as this scheme is indicated, Resource Server will attempt to process the request according to the Bearer Token specification.</p>
</div>
<div class="paragraph">
<p>Given an Opaque Token, Resource Server will</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Query the provided introspection endpoint using the provided credentials and the token</p>
</li>
<li>
<p>Inspect the response for an <code>{ 'active' : true }</code> attribute</p>
</li>
<li>
<p>Map each scope to an authority with the prefix <code>SCOPE_</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The resulting <code>Authentication#getPrincipal</code>, by default, is a Spring Security <code>{security-api-url}org/springframework/security/oauth2/core/OAuth2AuthenticatedPrincipal.html[OAuth2AuthenticatedPrincipal]</code> object, and <code>Authentication#getName</code> maps to the token&#8217;s <code>sub</code> property, if one is present.</p>
</div>
<div class="paragraph">
<p>From here, you may want to jump to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2resourceserver-opaque-architecture">How Opaque Token Authentication Works</a></p>
</li>
<li>
<p><a href="#oauth2resourceserver-opaque-attributes">Looking Up Attributes Post-Authentication</a></p>
</li>
<li>
<p><a href="#oauth2resourceserver-opaque-authorization-extraction">Extracting Authorities Manually</a></p>
</li>
<li>
<p><a href="#oauth2resourceserver-opaque-jwt-introspector">Using Introspection with JWTs</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-opaque-architecture"><a class="anchor" href="#oauth2resourceserver-opaque-architecture"></a>How Opaque Token Authentication Works</h4>
<div class="paragraph">
<p>Next, let&#8217;s see the architectural components that Spring Security uses to support <a href="https://tools.ietf.org/html/rfc7662">opaque token</a> Authentication in servlet-based applications, like the one we just saw.</p>
</div>
<div class="paragraph">
<p>{security-api-url}org/springframework/security/oauth2/server/resource/authentication/OpaqueTokenAuthenticationProvider.html[<code>OpaqueTokenAuthenticationProvider</code>] is an <a href="#servlet-authentication-authenticationprovider"><code>AuthenticationProvider</code></a> implementation that leverages a <a href="#oauth2resourceserver-opaque-introspector"><code>OpaqueTokenIntrospector</code></a> to authenticate an opaque token.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s take a look at how <code>OpaqueTokenAuthenticationProvider</code> works within Spring Security.
The figure explains details of how the <a href="#servlet-authentication-authenticationmanager"><code>AuthenticationManager</code></a> in figures from <a href="#oauth2resourceserver-authentication-bearertokenauthenticationfilter">Reading the Bearer Token</a> works.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/servlet/oauth2/opaquetokenauthenticationprovider.png" alt="opaquetokenauthenticationprovider">
</div>
<div class="title">Figure 4. <code>OpaqueTokenAuthenticationProvider</code> Usage</div>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_1.png" alt="number 1"></span> The authentication <code>Filter</code> from <a href="#oauth2resourceserver-authentication-bearertokenauthenticationfilter">Reading the Bearer Token</a> passes a <code>BearerTokenAuthenticationToken</code> to the <code>AuthenticationManager</code> which is implemented by <a href="#servlet-authentication-providermanager"><code>ProviderManager</code></a>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_2.png" alt="number 2"></span> The <code>ProviderManager</code> is configured to use an <a href="#servlet-authentication-authenticationprovider">[servlet-authentication-authenticationprovider]</a> of type <code>OpaqueTokenAuthenticationProvider</code>.</p>
</div>
<div id="oauth2resourceserver-opaque-architecture-introspector" class="paragraph">
<p><span class="image"><img src="images/icons/number_3.png" alt="number 3"></span> <code>OpaqueTokenAuthenticationProvider</code> introspects the opaque token and adds granted authorities using an <a href="#oauth2resourceserver-opaque-introspector"><code>OpaqueTokenIntrospector</code></a>.
When authentication is successful, the <a href="#servlet-authentication-authentication"><code>Authentication</code></a> that is returned is of type <code>BearerTokenAuthentication</code> and has a principal that is the <code>OAuth2AuthenticatedPrincipal</code> returned by the configured <a href="#oauth2resourceserver-opaque-introspector"><code>OpaqueTokenIntrospector</code></a>.
Ultimately, the returned <code>BearerTokenAuthentication</code> will be set on the <a href="#servlet-authentication-securitycontextholder"><code>SecurityContextHolder</code></a> by the authentication <code>Filter</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-opaque-attributes"><a class="anchor" href="#oauth2resourceserver-opaque-attributes"></a>Looking Up Attributes Post-Authentication</h4>
<div class="paragraph">
<p>Once a token is authenticated, an instance of <code>BearerTokenAuthentication</code> is set in the <code>SecurityContext</code>.</p>
</div>
<div class="paragraph">
<p>This means that it&#8217;s available in <code>@Controller</code> methods when using <code>@EnableWebMvc</code> in your configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/foo")
public String foo(BearerTokenAuthentication authentication) {
    return authentication.getTokenAttributes().get("sub") + " is the subject";
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/foo")
fun foo(authentication: BearerTokenAuthentication): String {
    return authentication.tokenAttributes["sub"].toString() + " is the subject"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Since <code>BearerTokenAuthentication</code> holds an <code>OAuth2AuthenticatedPrincipal</code>, that also means that it&#8217;s available to controller methods, too:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/foo")
public String foo(@AuthenticationPrincipal OAuth2AuthenticatedPrincipal principal) {
    return principal.getAttribute("sub") + " is the subject";
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/foo")
fun foo(@AuthenticationPrincipal principal: OAuth2AuthenticatedPrincipal): String {
    return principal.getAttribute&lt;Any&gt;("sub").toString() + " is the subject"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_looking_up_attributes_via_spel"><a class="anchor" href="#_looking_up_attributes_via_spel"></a>Looking Up Attributes Via SpEL</h5>
<div class="paragraph">
<p>Of course, this also means that attributes can be accessed via SpEL.</p>
</div>
<div class="paragraph">
<p>For example, if using <code>@EnableGlobalMethodSecurity</code> so that you can use <code>@PreAuthorize</code> annotations, you can do:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PreAuthorize("principal?.attributes['sub'] == 'foo'")
public String forFoosEyesOnly() {
    return "foo";
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@PreAuthorize("principal?.attributes['sub'] == 'foo'")
fun forFoosEyesOnly(): String {
    return "foo"
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-opaque-sansboot"><a class="anchor" href="#oauth2resourceserver-opaque-sansboot"></a>Overriding or Replacing Boot Auto Configuration</h4>
<div class="paragraph">
<p>There are two <code>@Bean</code> s that Spring Boot generates on Resource Server&#8217;s behalf.</p>
</div>
<div class="paragraph">
<p>The first is a <code>WebSecurityConfigurerAdapter</code> that configures the app as a resource server.
When use Opaque Token, this <code>WebSecurityConfigurerAdapter</code> looks like:</p>
</div>
<div class="exampleblock">
<div class="title">Example 27. Default Opaque Token Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">protected void configure(HttpSecurity http) {
    http
        .authorizeRequests(authorize -&gt; authorize
            .anyRequest().authenticated()
        )
        .oauth2ResourceServer(OAuth2ResourceServerConfigurer::opaqueToken);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">override fun configure(http: HttpSecurity) {
    http {
        authorizeRequests {
            authorize(anyRequest, authenticated)
        }
        oauth2ResourceServer {
            opaqueToken { }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the application doesn&#8217;t expose a <code>WebSecurityConfigurerAdapter</code> bean, then Spring Boot will expose the above default one.</p>
</div>
<div class="paragraph">
<p>Replacing this is as simple as exposing the bean within the application:</p>
</div>
<div class="exampleblock">
<div class="title">Example 28. Custom Opaque Token Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class MyCustomSecurityConfiguration extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -&gt; authorize
                .mvcMatchers("/messages/**").hasAuthority("SCOPE_message:read")
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -&gt; oauth2
                .opaqueToken(opaqueToken -&gt; opaqueToken
                    .introspector(myIntrospector())
                )
            );
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class MyCustomSecurityConfiguration : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize("/messages/**", hasAuthority("SCOPE_message:read"))
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                opaqueToken {
                    introspector = myIntrospector()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The above requires the scope of <code>message:read</code> for any URL that starts with <code>/messages/</code>.</p>
</div>
<div class="paragraph">
<p>Methods on the <code>oauth2ResourceServer</code> DSL will also override or replace auto configuration.</p>
</div>
<div id="oauth2resourceserver-opaque-introspector" class="paragraph">
<p>For example, the second <code>@Bean</code> Spring Boot creates is an <code>OpaqueTokenIntrospector</code>, <a href="#oauth2resourceserver-opaque-architecture-introspector">which decodes <code>String</code> tokens into validated instances of <code>OAuth2AuthenticatedPrincipal</code></a>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public OpaqueTokenIntrospector introspector() {
    return new NimbusOpaqueTokenIntrospector(introspectionUri, clientId, clientSecret);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun introspector(): OpaqueTokenIntrospector {
    return NimbusOpaqueTokenIntrospector(introspectionUri, clientId, clientSecret)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the application doesn&#8217;t expose a <a href="#oauth2resourceserver-opaque-architecture-introspector"><code>OpaqueTokenIntrospector</code></a> bean, then Spring Boot will expose the above default one.</p>
</div>
<div class="paragraph">
<p>And its configuration can be overridden using <code>introspectionUri()</code> and <code>introspectionClientCredentials()</code> or replaced using <code>introspector()</code>.</p>
</div>
<div class="paragraph">
<p>Or, if you&#8217;re not using Spring Boot at all, then both of these components - the filter chain and a <a href="#oauth2resourceserver-opaque-architecture-introspector"><code>OpaqueTokenIntrospector</code></a> can be specified in XML.</p>
</div>
<div class="paragraph">
<p>The filter chain is specified like so:</p>
</div>
<div class="exampleblock">
<div class="title">Example 29. Default Opaque Token Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
    &lt;intercept-uri pattern="/**" access="authenticated"/&gt;
    &lt;oauth2-resource-server&gt;
        &lt;opaque-token introspector-ref="opaqueTokenIntrospector"/&gt;
    &lt;/oauth2-resource-server&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>And the <a href="#oauth2resourceserver-opaque-architecture-introspector"><code>OpaqueTokenIntrospector</code></a> like so:</p>
</div>
<div class="exampleblock">
<div class="title">Example 30. Opaque Token Introspector</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="opaqueTokenIntrospector"
        class="org.springframework.security.oauth2.server.resource.introspection.NimbusOpaqueTokenIntrospector"&gt;
    &lt;constructor-arg value="${spring.security.oauth2.resourceserver.opaquetoken.introspection_uri}"/&gt;
    &lt;constructor-arg value="${spring.security.oauth2.resourceserver.opaquetoken.client_id}"/&gt;
    &lt;constructor-arg value="${spring.security.oauth2.resourceserver.opaquetoken.client_secret}"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-opaque-introspectionuri-dsl"><a class="anchor" href="#oauth2resourceserver-opaque-introspectionuri-dsl"></a>Using <code>introspectionUri()</code></h5>
<div class="paragraph">
<p>An authorization server&#8217;s Introspection Uri can be configured <a href="#oauth2resourceserver-opaque-introspectionuri">as a configuration property</a> or it can be supplied in the DSL:</p>
</div>
<div class="exampleblock">
<div class="title">Example 31. Introspection URI Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class DirectlyConfiguredIntrospectionUri extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -&gt; authorize
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -&gt; oauth2
                .opaqueToken(opaqueToken -&gt; opaqueToken
                    .introspectionUri("https://idp.example.com/introspect")
                    .introspectionClientCredentials("client", "secret")
                )
            );
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class DirectlyConfiguredIntrospectionUri : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                opaqueToken {
                    introspectionUri = "https://idp.example.com/introspect"
                    introspectionClientCredentials("client", "secret")
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="opaqueTokenIntrospector"
        class="org.springframework.security.oauth2.server.resource.introspection.NimbusOpaqueTokenIntrospector"&gt;
    &lt;constructor-arg value="https://idp.example.com/introspect"/&gt;
    &lt;constructor-arg value="client"/&gt;
    &lt;constructor-arg value="secret"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Using <code>introspectionUri()</code> takes precedence over any configuration property.</p>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-opaque-introspector-dsl"><a class="anchor" href="#oauth2resourceserver-opaque-introspector-dsl"></a>Using <code>introspector()</code></h5>
<div class="paragraph">
<p>More powerful than <code>introspectionUri()</code> is <code>introspector()</code>, which will completely replace any Boot auto configuration of <a href="#oauth2resourceserver-opaque-architecture-introspector"><code>OpaqueTokenIntrospector</code></a>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 32. Introspector Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class DirectlyConfiguredIntrospector extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -&gt; authorize
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -&gt; oauth2
                .opaqueToken(opaqueToken -&gt; opaqueToken
                    .introspector(myCustomIntrospector())
                )
            );
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class DirectlyConfiguredIntrospector : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                opaqueToken {
                    introspector = myCustomIntrospector()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
    &lt;intercept-uri pattern="/**" access="authenticated"/&gt;
    &lt;oauth2-resource-server&gt;
        &lt;opaque-token introspector-ref="myCustomIntrospector"/&gt;
    &lt;/oauth2-resource-server&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This is handy when deeper configuration, like <a href="#oauth2resourceserver-opaque-authorization-extraction">authority mapping</a>, <a href="#oauth2resourceserver-opaque-jwt-introspector">JWT revocation</a>, or <a href="#oauth2resourceserver-opaque-timeouts">request timeouts</a>, is necessary.</p>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-opaque-introspector-bean"><a class="anchor" href="#oauth2resourceserver-opaque-introspector-bean"></a>Exposing a <code>OpaqueTokenIntrospector</code> <code>@Bean</code></h5>
<div class="paragraph">
<p>Or, exposing a <a href="#oauth2resourceserver-opaque-architecture-introspector"><code>OpaqueTokenIntrospector</code></a> <code>@Bean</code> has the same effect as <code>introspector()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public OpaqueTokenIntrospector introspector() {
    return new NimbusOpaqueTokenIntrospector(introspectionUri, clientId, clientSecret);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-opaque-authorization"><a class="anchor" href="#oauth2resourceserver-opaque-authorization"></a>Configuring Authorization</h4>
<div class="paragraph">
<p>An OAuth 2.0 Introspection endpoint will typically return a <code>scope</code> attribute, indicating the scopes (or authorities) it&#8217;s been granted, for example:</p>
</div>
<div class="paragraph">
<p><code>{ &#8230;&#8203;, "scope" : "messages contacts"}</code></p>
</div>
<div class="paragraph">
<p>When this is the case, Resource Server will attempt to coerce these scopes into a list of granted authorities, prefixing each scope with the string "SCOPE_".</p>
</div>
<div class="paragraph">
<p>This means that to protect an endpoint or method with a scope derived from an Opaque Token, the corresponding expressions should include this prefix:</p>
</div>
<div class="exampleblock">
<div class="title">Example 33. Authorization Opaque Token Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class MappedAuthorities extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorizeRequests -&gt; authorizeRequests
                .mvcMatchers("/contacts/**").hasAuthority("SCOPE_contacts")
                .mvcMatchers("/messages/**").hasAuthority("SCOPE_messages")
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(OAuth2ResourceServerConfigurer::opaqueToken);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class MappedAuthorities : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
       http {
            authorizeRequests {
                authorize("/contacts/**", hasAuthority("SCOPE_contacts"))
                authorize("/messages/**", hasAuthority("SCOPE_messages"))
                authorize(anyRequest, authenticated)
            }
           oauth2ResourceServer {
               opaqueToken { }
           }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
    &lt;intercept-uri pattern="/contacts/**" access="hasAuthority('SCOPE_contacts')"/&gt;
    &lt;intercept-uri pattern="/messages/**" access="hasAuthority('SCOPE_messages')"/&gt;
    &lt;oauth2-resource-server&gt;
        &lt;opaque-token introspector-ref="opaqueTokenIntrospector"/&gt;
    &lt;/oauth2-resource-server&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Or similarly with method security:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PreAuthorize("hasAuthority('SCOPE_messages')")
public List&lt;Message&gt; getMessages(...) {}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@PreAuthorize("hasAuthority('SCOPE_messages')")
fun getMessages(): List&lt;Message?&gt; {}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-opaque-authorization-extraction"><a class="anchor" href="#oauth2resourceserver-opaque-authorization-extraction"></a>Extracting Authorities Manually</h5>
<div class="paragraph">
<p>By default, Opaque Token support will extract the scope claim from an introspection response and parse it into individual <code>GrantedAuthority</code> instances.</p>
</div>
<div class="paragraph">
<p>For example, if the introspection response were:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "active" : true,
    "scope" : "message:read message:write"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then Resource Server would generate an <code>Authentication</code> with two authorities, one for <code>message:read</code> and the other for <code>message:write</code>.</p>
</div>
<div class="paragraph">
<p>This can, of course, be customized using a custom <a href="#oauth2resourceserver-opaque-architecture-introspector"><code>OpaqueTokenIntrospector</code></a> that takes a look at the attribute set and converts in its own way:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class CustomAuthoritiesOpaqueTokenIntrospector implements OpaqueTokenIntrospector {
    private OpaqueTokenIntrospector delegate =
            new NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret");

    public OAuth2AuthenticatedPrincipal introspect(String token) {
        OAuth2AuthenticatedPrincipal principal = this.delegate.introspect(token);
        return new DefaultOAuth2AuthenticatedPrincipal(
                principal.getName(), principal.getAttributes(), extractAuthorities(principal));
    }

    private Collection&lt;GrantedAuthority&gt; extractAuthorities(OAuth2AuthenticatedPrincipal principal) {
        List&lt;String&gt; scopes = principal.getAttribute(OAuth2IntrospectionClaimNames.SCOPE);
        return scopes.stream()
                .map(SimpleGrantedAuthority::new)
                .collect(Collectors.toList());
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class CustomAuthoritiesOpaqueTokenIntrospector : OpaqueTokenIntrospector {
    private val delegate: OpaqueTokenIntrospector = NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret")
    override fun introspect(token: String): OAuth2AuthenticatedPrincipal {
        val principal: OAuth2AuthenticatedPrincipal = delegate.introspect(token)
        return DefaultOAuth2AuthenticatedPrincipal(
                principal.name, principal.attributes, extractAuthorities(principal))
    }

    private fun extractAuthorities(principal: OAuth2AuthenticatedPrincipal): Collection&lt;GrantedAuthority&gt; {
        val scopes: List&lt;String&gt; = principal.getAttribute(OAuth2IntrospectionClaimNames.SCOPE)
        return scopes
                .map { SimpleGrantedAuthority(it) }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Thereafter, this custom introspector can be configured simply by exposing it as a <code>@Bean</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public OpaqueTokenIntrospector introspector() {
    return new CustomAuthoritiesOpaqueTokenIntrospector();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun introspector(): OpaqueTokenIntrospector {
    return CustomAuthoritiesOpaqueTokenIntrospector()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-opaque-timeouts"><a class="anchor" href="#oauth2resourceserver-opaque-timeouts"></a>Configuring Timeouts</h4>
<div class="paragraph">
<p>By default, Resource Server uses connection and socket timeouts of 30 seconds each for coordinating with the authorization server.</p>
</div>
<div class="paragraph">
<p>This may be too short in some scenarios.
Further, it doesn&#8217;t take into account more sophisticated patterns like back-off and discovery.</p>
</div>
<div class="paragraph">
<p>To adjust the way in which Resource Server connects to the authorization server, <code>NimbusOpaqueTokenIntrospector</code> accepts an instance of <code>RestOperations</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public OpaqueTokenIntrospector introspector(RestTemplateBuilder builder, OAuth2ResourceServerProperties properties) {
    RestOperations rest = builder
            .basicAuthentication(properties.getOpaquetoken().getClientId(), properties.getOpaquetoken().getClientSecret())
            .setConnectTimeout(Duration.ofSeconds(60))
            .setReadTimeout(Duration.ofSeconds(60))
            .build();

    return new NimbusOpaqueTokenIntrospector(introspectionUri, rest);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun introspector(builder: RestTemplateBuilder, properties: OAuth2ResourceServerProperties): OpaqueTokenIntrospector? {
    val rest: RestOperations = builder
            .basicAuthentication(properties.opaquetoken.clientId, properties.opaquetoken.clientSecret)
            .setConnectTimeout(Duration.ofSeconds(60))
            .setReadTimeout(Duration.ofSeconds(60))
            .build()
    return NimbusOpaqueTokenIntrospector(introspectionUri, rest)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-opaque-jwt-introspector"><a class="anchor" href="#oauth2resourceserver-opaque-jwt-introspector"></a>Using Introspection with JWTs</h4>
<div class="paragraph">
<p>A common question is whether or not introspection is compatible with JWTs.
Spring Security&#8217;s Opaque Token support has been designed to not care about the format of the token&#8201;&#8212;&#8201;it will gladly pass any token to the introspection endpoint provided.</p>
</div>
<div class="paragraph">
<p>So, let&#8217;s say that you&#8217;ve got a requirement that requires you to check with the authorization server on each request, in case the JWT has been revoked.</p>
</div>
<div class="paragraph">
<p>Even though you are using the JWT format for the token, your validation method is introspection, meaning you&#8217;d want to do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      resourceserver:
        opaque-token:
          introspection-uri: https://idp.example.org/introspection
          client-id: client
          client-secret: secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, the resulting <code>Authentication</code> would be <code>BearerTokenAuthentication</code>.
Any attributes in the corresponding <code>OAuth2AuthenticatedPrincipal</code> would be whatever was returned by the introspection endpoint.</p>
</div>
<div class="paragraph">
<p>But, let&#8217;s say that, oddly enough, the introspection endpoint only returns whether or not the token is active.
Now what?</p>
</div>
<div class="paragraph">
<p>In this case, you can create a custom <a href="#oauth2resourceserver-opaque-architecture-introspector"><code>OpaqueTokenIntrospector</code></a> that still hits the endpoint, but then updates the returned principal to have the JWTs claims as the attributes:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class JwtOpaqueTokenIntrospector implements OpaqueTokenIntrospector {
    private OpaqueTokenIntrospector delegate =
            new NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret");
    private JwtDecoder jwtDecoder = new NimbusJwtDecoder(new ParseOnlyJWTProcessor());

    public OAuth2AuthenticatedPrincipal introspect(String token) {
        OAuth2AuthenticatedPrincipal principal = this.delegate.introspect(token);
        try {
            Jwt jwt = this.jwtDecoder.decode(token);
            return new DefaultOAuth2AuthenticatedPrincipal(jwt.getClaims(), NO_AUTHORITIES);
        } catch (JwtException ex) {
            throw new OAuth2IntrospectionException(ex);
        }
    }

    private static class ParseOnlyJWTProcessor extends DefaultJWTProcessor&lt;SecurityContext&gt; {
    	JWTClaimsSet process(SignedJWT jwt, SecurityContext context)
                throws JOSEException {
            return jwt.getJWTClaimsSet();
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class JwtOpaqueTokenIntrospector : OpaqueTokenIntrospector {
    private val delegate: OpaqueTokenIntrospector = NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret")
    private val jwtDecoder: JwtDecoder = NimbusJwtDecoder(ParseOnlyJWTProcessor())
    override fun introspect(token: String): OAuth2AuthenticatedPrincipal {
        val principal = delegate.introspect(token)
        return try {
            val jwt: Jwt = jwtDecoder.decode(token)
            DefaultOAuth2AuthenticatedPrincipal(jwt.claims, NO_AUTHORITIES)
        } catch (ex: JwtException) {
            throw OAuth2IntrospectionException(ex.message)
        }
    }

    private class ParseOnlyJWTProcessor : DefaultJWTProcessor&lt;SecurityContext&gt;() {
        override fun process(jwt: SignedJWT, context: SecurityContext): JWTClaimsSet {
            return jwt.jwtClaimsSet
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Thereafter, this custom introspector can be configured simply by exposing it as a <code>@Bean</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public OpaqueTokenIntrospector introspector() {
    return new JwtOpaqueTokenIntrospector();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun introspector(): OpaqueTokenIntrospector {
    return JwtOpaqueTokenIntrospector()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-opaque-userinfo"><a class="anchor" href="#oauth2resourceserver-opaque-userinfo"></a>Calling a <code>/userinfo</code> Endpoint</h4>
<div class="paragraph">
<p>Generally speaking, a Resource Server doesn&#8217;t care about the underlying user, but instead about the authorities that have been granted.</p>
</div>
<div class="paragraph">
<p>That said, at times it can be valuable to tie the authorization statement back to a user.</p>
</div>
<div class="paragraph">
<p>If an application is also using <code>spring-security-oauth2-client</code>, having set up the appropriate <code>ClientRegistrationRepository</code>, then this is quite simple with a custom <a href="#oauth2resourceserver-opaque-architecture-introspector"><code>OpaqueTokenIntrospector</code></a>.
This implementation below does three things:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Delegates to the introspection endpoint, to affirm the token&#8217;s validity</p>
</li>
<li>
<p>Looks up the appropriate client registration associated with the <code>/userinfo</code> endpoint</p>
</li>
<li>
<p>Invokes and returns the response from the <code>/userinfo</code> endpoint</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class UserInfoOpaqueTokenIntrospector implements OpaqueTokenIntrospector {
    private final OpaqueTokenIntrospector delegate =
            new NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret");
    private final OAuth2UserService oauth2UserService = new DefaultOAuth2UserService();

    private final ClientRegistrationRepository repository;

    // ... constructor

    @Override
    public OAuth2AuthenticatedPrincipal introspect(String token) {
        OAuth2AuthenticatedPrincipal authorized = this.delegate.introspect(token);
        Instant issuedAt = authorized.getAttribute(ISSUED_AT);
        Instant expiresAt = authorized.getAttribute(EXPIRES_AT);
        ClientRegistration clientRegistration = this.repository.findByRegistrationId("registration-id");
        OAuth2AccessToken token = new OAuth2AccessToken(BEARER, token, issuedAt, expiresAt);
        OAuth2UserRequest oauth2UserRequest = new OAuth2UserRequest(clientRegistration, token);
        return this.oauth2UserService.loadUser(oauth2UserRequest);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class UserInfoOpaqueTokenIntrospector : OpaqueTokenIntrospector {
    private val delegate: OpaqueTokenIntrospector = NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret")
    private val oauth2UserService = DefaultOAuth2UserService()
    private val repository: ClientRegistrationRepository? = null

    // ... constructor

    override fun introspect(token: String): OAuth2AuthenticatedPrincipal {
        val authorized = delegate.introspect(token)
        val issuedAt: Instant? = authorized.getAttribute(ISSUED_AT)
        val expiresAt: Instant? = authorized.getAttribute(EXPIRES_AT)
        val clientRegistration: ClientRegistration = repository!!.findByRegistrationId("registration-id")
        val accessToken = OAuth2AccessToken(BEARER, token, issuedAt, expiresAt)
        val oauth2UserRequest = OAuth2UserRequest(clientRegistration, accessToken)
        return oauth2UserService.loadUser(oauth2UserRequest)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you aren&#8217;t using <code>spring-security-oauth2-client</code>, it&#8217;s still quite simple.
You will simply need to invoke the <code>/userinfo</code> with your own instance of <code>WebClient</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class UserInfoOpaqueTokenIntrospector implements OpaqueTokenIntrospector {
    private final OpaqueTokenIntrospector delegate =
            new NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret");
    private final WebClient rest = WebClient.create();

    @Override
    public OAuth2AuthenticatedPrincipal introspect(String token) {
        OAuth2AuthenticatedPrincipal authorized = this.delegate.introspect(token);
        return makeUserInfoRequest(authorized);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class UserInfoOpaqueTokenIntrospector : OpaqueTokenIntrospector {
    private val delegate: OpaqueTokenIntrospector = NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret")
    private val rest: WebClient = WebClient.create()

    override fun introspect(token: String): OAuth2AuthenticatedPrincipal {
        val authorized = delegate.introspect(token)
        return makeUserInfoRequest(authorized)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Either way, having created your <a href="#oauth2resourceserver-opaque-architecture-introspector"><code>OpaqueTokenIntrospector</code></a>, you should publish it as a <code>@Bean</code> to override the defaults:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
OpaqueTokenIntrospector introspector() {
    return new UserInfoOpaqueTokenIntrospector(...);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun introspector(): OpaqueTokenIntrospector {
    return UserInfoOpaqueTokenIntrospector(...)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2reourceserver-opaqueandjwt"><a class="anchor" href="#oauth2reourceserver-opaqueandjwt"></a>Supporting both JWT and Opaque Token</h4>
<div class="paragraph">
<p>In some cases, you may have a need to access both kinds of tokens.
For example, you may support more than one tenant where one tenant issues JWTs and the other issues opaque tokens.</p>
</div>
<div class="paragraph">
<p>If this decision must be made at request-time, then you can use an <code>AuthenticationManagerResolver</code> to achieve it, like so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
AuthenticationManagerResolver&lt;HttpServletRequest&gt; tokenAuthenticationManagerResolver() {
    BearerTokenResolver bearerToken = new DefaultBearerTokenResolver();
    JwtAuthenticationProvider jwt = jwt();
    OpaqueTokenAuthenticationProvider opaqueToken = opaqueToken();

    return request -&gt; {
        if (useJwt(request)) {
            return jwt::authenticate;
        } else {
            return opaqueToken::authenticate;
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun tokenAuthenticationManagerResolver(): AuthenticationManagerResolver&lt;HttpServletRequest&gt; {
    val bearerToken: BearerTokenResolver = DefaultBearerTokenResolver()
    val jwt: JwtAuthenticationProvider = jwt()
    val opaqueToken: OpaqueTokenAuthenticationProvider = opaqueToken()

    return AuthenticationManagerResolver { request -&gt;
        if (useJwt(request)) {
            AuthenticationManager { jwt.authenticate(it) }
        } else {
            AuthenticationManager { opaqueToken.authenticate(it) }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The implementation of <code>useJwt(HttpServletRequest)</code> will likely depend on custom request material like the path.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>And then specify this <code>AuthenticationManagerResolver</code> in the DSL:</p>
</div>
<div class="exampleblock">
<div class="title">Example 34. Authentication Manager Resolver</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">http
    .authorizeRequests(authorize -&gt; authorize
        .anyRequest().authenticated()
    )
    .oauth2ResourceServer(oauth2 -&gt; oauth2
        .authenticationManagerResolver(this.tokenAuthenticationManagerResolver)
    );</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">http {
    authorizeRequests {
        authorize(anyRequest, authenticated)
    }
    oauth2ResourceServer {
        authenticationManagerResolver = tokenAuthenticationManagerResolver()
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
    &lt;oauth2-resource-server authentication-manager-resolver-ref="tokenAuthenticationManagerResolver"/&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-multitenancy"><a class="anchor" href="#oauth2resourceserver-multitenancy"></a>Multi-tenancy</h4>
<div class="paragraph">
<p>A resource server is considered multi-tenant when there are multiple strategies for verifying a bearer token, keyed by some tenant identifier.</p>
</div>
<div class="paragraph">
<p>For example, your resource server may accept bearer tokens from two different authorization servers.
Or, your authorization server may represent a multiplicity of issuers.</p>
</div>
<div class="paragraph">
<p>In each case, there are two things that need to be done and trade-offs associated with how you choose to do them:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Resolve the tenant</p>
</li>
<li>
<p>Propagate the tenant</p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="_resolving_the_tenant_by_claim"><a class="anchor" href="#_resolving_the_tenant_by_claim"></a>Resolving the Tenant By Claim</h5>
<div class="paragraph">
<p>One way to differentiate tenants is by the issuer claim. Since the issuer claim accompanies signed JWTs, this can be done with the <code>JwtIssuerAuthenticationManagerResolver</code>, like so:</p>
</div>
<div class="exampleblock">
<div class="title">Example 35. Multitenancy Tenant by JWT Claim</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">JwtIssuerAuthenticationManagerResolver authenticationManagerResolver = new JwtIssuerAuthenticationManagerResolver
    ("https://idp.example.org/issuerOne", "https://idp.example.org/issuerTwo");

http
    .authorizeRequests(authorize -&gt; authorize
        .anyRequest().authenticated()
    )
    .oauth2ResourceServer(oauth2 -&gt; oauth2
        .authenticationManagerResolver(authenticationManagerResolver)
    );</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val customAuthenticationManagerResolver = JwtIssuerAuthenticationManagerResolver
    ("https://idp.example.org/issuerOne", "https://idp.example.org/issuerTwo")
http {
    authorizeRequests {
        authorize(anyRequest, authenticated)
    }
    oauth2ResourceServer {
        authenticationManagerResolver = customAuthenticationManagerResolver
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
    &lt;oauth2-resource-server authentication-manager-resolver-ref="authenticationManagerResolver"/&gt;
&lt;/http&gt;

&lt;bean id="authenticationManagerResolver"
        class="org.springframework.security.oauth2.server.resource.authentication.JwtIssuerAuthenticationManagerResolver"&gt;
    &lt;constructor-arg&gt;
        &lt;list&gt;
            &lt;value&gt;https://idp.example.org/issuerOne&lt;/value&gt;
            &lt;value&gt;https://idp.example.org/issuerTwo&lt;/value&gt;
        &lt;/list&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This is nice because the issuer endpoints are loaded lazily.
In fact, the corresponding <code>JwtAuthenticationProvider</code> is instantiated only when the first request with the corresponding issuer is sent.
This allows for an application startup that is independent from those authorization servers being up and available.</p>
</div>
<div class="sect5">
<h6 id="_dynamic_tenants"><a class="anchor" href="#_dynamic_tenants"></a>Dynamic Tenants</h6>
<div class="paragraph">
<p>Of course, you may not want to restart the application each time a new tenant is added.
In this case, you can configure the <code>JwtIssuerAuthenticationManagerResolver</code> with a repository of <code>AuthenticationManager</code> instances, which you can edit at runtime, like so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">private void addManager(Map&lt;String, AuthenticationManager&gt; authenticationManagers, String issuer) {
	JwtAuthenticationProvider authenticationProvider = new JwtAuthenticationProvider
	        (JwtDecoders.fromIssuerLocation(issuer));
	authenticationManagers.put(issuer, authenticationProvider::authenticate);
}

// ...

JwtIssuerAuthenticationManagerResolver authenticationManagerResolver =
        new JwtIssuerAuthenticationManagerResolver(authenticationManagers::get);

http
    .authorizeRequests(authorize -&gt; authorize
        .anyRequest().authenticated()
    )
    .oauth2ResourceServer(oauth2 -&gt; oauth2
        .authenticationManagerResolver(authenticationManagerResolver)
    );</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">private fun addManager(authenticationManagers: MutableMap&lt;String, AuthenticationManager&gt;, issuer: String) {
    val authenticationProvider = JwtAuthenticationProvider(JwtDecoders.fromIssuerLocation(issuer))
    authenticationManagers[issuer] = AuthenticationManager {
        authentication: Authentication? -&gt; authenticationProvider.authenticate(authentication)
    }
}

// ...

val customAuthenticationManagerResolver: JwtIssuerAuthenticationManagerResolver =
    JwtIssuerAuthenticationManagerResolver(authenticationManagers::get)
http {
    authorizeRequests {
        authorize(anyRequest, authenticated)
    }
    oauth2ResourceServer {
        authenticationManagerResolver = customAuthenticationManagerResolver
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In this case, you construct <code>JwtIssuerAuthenticationManagerResolver</code> with a strategy for obtaining the <code>AuthenticationManager</code> given the issuer.
This approach allows us to add and remove elements from the repository (shown as a <code>Map</code> in the snippet) at runtime.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It would be unsafe to simply take any issuer and construct an <code>AuthenticationManager</code> from it.
The issuer should be one that the code can verify from a trusted source like a list of allowed issuers.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_parsing_the_claim_only_once"><a class="anchor" href="#_parsing_the_claim_only_once"></a>Parsing the Claim Only Once</h6>
<div class="paragraph">
<p>You may have observed that this strategy, while simple, comes with the trade-off that the JWT is parsed once by the <code>AuthenticationManagerResolver</code> and then again by the <a href="#oauth2resourceserver-jwt-architecture-jwtdecoder"><code>JwtDecoder</code></a> later on in the request.</p>
</div>
<div class="paragraph">
<p>This extra parsing can be alleviated by configuring the <a href="#oauth2resourceserver-jwt-architecture-jwtdecoder"><code>JwtDecoder</code></a> directly with a <code>JWTClaimsSetAwareJWSKeySelector</code> from Nimbus:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class TenantJWSKeySelector
    implements JWTClaimsSetAwareJWSKeySelector&lt;SecurityContext&gt; {

	private final TenantRepository tenants; <i class="conum" data-value="1"></i><b>(1)</b>
	private final Map&lt;String, JWSKeySelector&lt;SecurityContext&gt;&gt; selectors = new ConcurrentHashMap&lt;&gt;(); <i class="conum" data-value="2"></i><b>(2)</b>

	public TenantJWSKeySelector(TenantRepository tenants) {
		this.tenants = tenants;
	}

	@Override
	public List&lt;? extends Key&gt; selectKeys(JWSHeader jwsHeader, JWTClaimsSet jwtClaimsSet, SecurityContext securityContext)
			throws KeySourceException {
		return this.selectors.computeIfAbsent(toTenant(jwtClaimsSet), this::fromTenant)
				.selectJWSKeys(jwsHeader, securityContext);
	}

	private String toTenant(JWTClaimsSet claimSet) {
		return (String) claimSet.getClaim("iss");
	}

	private JWSKeySelector&lt;SecurityContext&gt; fromTenant(String tenant) {
		return Optional.ofNullable(this.tenantRepository.findById(tenant)) <i class="conum" data-value="3"></i><b>(3)</b>
		        .map(t -&gt; t.getAttrbute("jwks_uri"))
				.map(this::fromUri)
				.orElseThrow(() -&gt; new IllegalArgumentException("unknown tenant"));
	}

	private JWSKeySelector&lt;SecurityContext&gt; fromUri(String uri) {
		try {
			return JWSAlgorithmFamilyJWSKeySelector.fromJWKSetURL(new URL(uri)); <i class="conum" data-value="4"></i><b>(4)</b>
		} catch (Exception ex) {
			throw new IllegalArgumentException(ex);
		}
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Component
class TenantJWSKeySelector(tenants: TenantRepository) : JWTClaimsSetAwareJWSKeySelector&lt;SecurityContext&gt; {
    private val tenants: TenantRepository <i class="conum" data-value="1"></i><b>(1)</b>
    private val selectors: MutableMap&lt;String, JWSKeySelector&lt;SecurityContext&gt;&gt; = ConcurrentHashMap() <i class="conum" data-value="2"></i><b>(2)</b>

    init {
        this.tenants = tenants
    }

    fun selectKeys(jwsHeader: JWSHeader?, jwtClaimsSet: JWTClaimsSet, securityContext: SecurityContext): List&lt;Key?&gt; {
        return selectors.computeIfAbsent(toTenant(jwtClaimsSet)) { tenant: String -&gt; fromTenant(tenant) }
                .selectJWSKeys(jwsHeader, securityContext)
    }

    private fun toTenant(claimSet: JWTClaimsSet): String {
        return claimSet.getClaim("iss") as String
    }

    private fun fromTenant(tenant: String): JWSKeySelector&lt;SecurityContext&gt; {
        return Optional.ofNullable(this.tenants.findById(tenant)) <i class="conum" data-value="3"></i><b>(3)</b>
                .map { t -&gt; t.getAttrbute("jwks_uri") }
                .map { uri: String -&gt; fromUri(uri) }
                .orElseThrow { IllegalArgumentException("unknown tenant") }
    }

    private fun fromUri(uri: String): JWSKeySelector&lt;SecurityContext?&gt; {
        return try {
            JWSAlgorithmFamilyJWSKeySelector.fromJWKSetURL(URL(uri)) <i class="conum" data-value="4"></i><b>(4)</b>
        } catch (ex: Exception) {
            throw IllegalArgumentException(ex)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>A hypothetical source for tenant information</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>A cache for `JWKKeySelector`s, keyed by tenant identifier</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Looking up the tenant is more secure than simply calculating the JWK Set endpoint on the fly - the lookup acts as a list of allowed tenants</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Create a <code>JWSKeySelector</code> via the types of keys that come back from the JWK Set endpoint - the lazy lookup here means that you don&#8217;t need to configure all tenants at startup</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The above key selector is a composition of many key selectors.
It chooses which key selector to use based on the <code>iss</code> claim in the JWT.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
To use this approach, make sure that the authorization server is configured to include the claim set as part of the token&#8217;s signature.
Without this, you have no guarantee that the issuer hasn&#8217;t been altered by a bad actor.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Next, we can construct a <code>JWTProcessor</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
JWTProcessor jwtProcessor(JWTClaimSetJWSKeySelector keySelector) {
	ConfigurableJWTProcessor&lt;SecurityContext&gt; jwtProcessor =
            new DefaultJWTProcessor();
	jwtProcessor.setJWTClaimSetJWSKeySelector(keySelector);
	return jwtProcessor;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtProcessor(keySelector: JWTClaimsSetAwareJWSKeySelector&lt;SecurityContext&gt;): JWTProcessor&lt;SecurityContext&gt; {
    val jwtProcessor = DefaultJWTProcessor&lt;SecurityContext&gt;()
    jwtProcessor.jwtClaimsSetAwareJWSKeySelector = keySelector
    return jwtProcessor
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As you are already seeing, the trade-off for moving tenant-awareness down to this level is more configuration.
We have just a bit more.</p>
</div>
<div class="paragraph">
<p>Next, we still want to make sure you are validating the issuer.
But, since the issuer may be different per JWT, then you&#8217;ll need a tenant-aware validator, too:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class TenantJwtIssuerValidator implements OAuth2TokenValidator&lt;Jwt&gt; {
	private final TenantRepository tenants;
	private final Map&lt;String, JwtIssuerValidator&gt; validators = new ConcurrentHashMap&lt;&gt;();

	public TenantJwtIssuerValidator(TenantRepository tenants) {
		this.tenants = tenants;
	}

	@Override
	public OAuth2TokenValidatorResult validate(Jwt token) {
		return this.validators.computeIfAbsent(toTenant(token), this::fromTenant)
				.validate(token);
	}

	private String toTenant(Jwt jwt) {
		return jwt.getIssuer();
	}

	private JwtIssuerValidator fromTenant(String tenant) {
		return Optional.ofNullable(this.tenants.findById(tenant))
		        .map(t -&gt; t.getAttribute("issuer"))
				.map(JwtIssuerValidator::new)
				.orElseThrow(() -&gt; new IllegalArgumentException("unknown tenant"));
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Component
class TenantJwtIssuerValidator(tenants: TenantRepository) : OAuth2TokenValidator&lt;Jwt&gt; {
    private val tenants: TenantRepository
    private val validators: MutableMap&lt;String, JwtIssuerValidator&gt; = ConcurrentHashMap()
    override fun validate(token: Jwt): OAuth2TokenValidatorResult {
        return validators.computeIfAbsent(toTenant(token)) { tenant: String -&gt; fromTenant(tenant) }
                .validate(token)
    }

    private fun toTenant(jwt: Jwt): String {
        return jwt.issuer.toString()
    }

    private fun fromTenant(tenant: String): JwtIssuerValidator {
        return Optional.ofNullable(tenants.findById(tenant))
                .map({ t -&gt; t.getAttribute("issuer") })
                .map({ JwtIssuerValidator() })
                .orElseThrow({ IllegalArgumentException("unknown tenant") })
    }

    init {
        this.tenants = tenants
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Now that we have a tenant-aware processor and a tenant-aware validator, we can proceed with creating our <a href="#oauth2resourceserver-jwt-architecture-jwtdecoder"><code>JwtDecoder</code></a>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
JwtDecoder jwtDecoder(JWTProcessor jwtProcessor, OAuth2TokenValidator&lt;Jwt&gt; jwtValidator) {
	NimbusJwtDecoder decoder = new NimbusJwtDecoder(processor);
	OAuth2TokenValidator&lt;Jwt&gt; validator = new DelegatingOAuth2TokenValidator&lt;&gt;
			(JwtValidators.createDefault(), this.jwtValidator);
	decoder.setJwtValidator(validator);
	return decoder;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(jwtProcessor: JWTProcessor&lt;SecurityContext&gt;?, jwtValidator: OAuth2TokenValidator&lt;Jwt&gt;?): JwtDecoder {
    val decoder = NimbusJwtDecoder(jwtProcessor)
    val validator: OAuth2TokenValidator&lt;Jwt&gt; = DelegatingOAuth2TokenValidator(JwtValidators.createDefault(), jwtValidator)
    decoder.setJwtValidator(validator)
    return decoder
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>We&#8217;ve finished talking about resolving the tenant.</p>
</div>
<div class="paragraph">
<p>If you&#8217;ve chosen to resolve the tenant by something other than a JWT claim, then you&#8217;ll need to make sure you address your downstream resource servers in the same way.
For example, if you are resolving it by subdomain, you may need to address the downstream resource server using the same subdomain.</p>
</div>
<div class="paragraph">
<p>However, if you resolve it by a claim in the bearer token, read on to learn about <a href="#oauth2resourceserver-bearertoken-resolver">Spring Security&#8217;s support for bearer token propagation</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-bearertoken-resolver"><a class="anchor" href="#oauth2resourceserver-bearertoken-resolver"></a>Bearer Token Resolution</h4>
<div class="paragraph">
<p>By default, Resource Server looks for a bearer token in the <code>Authorization</code> header.
This, however, can be customized in a handful of ways.</p>
</div>
<div class="sect4">
<h5 id="_reading_the_bearer_token_from_a_custom_header"><a class="anchor" href="#_reading_the_bearer_token_from_a_custom_header"></a>Reading the Bearer Token from a Custom Header</h5>
<div class="paragraph">
<p>For example, you may have a need to read the bearer token from a custom header.
To achieve this, you can expose a <code>DefaultBearerTokenResolver</code> as a bean, or wire an instance into the DSL, as you can see in the following example:</p>
</div>
<div class="exampleblock">
<div class="title">Example 36. Custom Bearer Token Header</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
BearerTokenResolver bearerTokenResolver() {
    DefaultBearerTokenResolver bearerTokenResolver = new DefaultBearerTokenResolver();
    bearerTokenResolver.setBearerTokenHeaderName(HttpHeaders.PROXY_AUTHORIZATION);
    return bearerTokenResolver;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun bearerTokenResolver(): BearerTokenResolver {
    val bearerTokenResolver = DefaultBearerTokenResolver()
    bearerTokenResolver.setBearerTokenHeaderName(HttpHeaders.PROXY_AUTHORIZATION)
    return bearerTokenResolver
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
    &lt;oauth2-resource-server bearer-token-resolver-ref="bearerTokenResolver"/&gt;
&lt;/http&gt;

&lt;bean id="bearerTokenResolver"
        class="org.springframework.security.oauth2.server.resource.web.DefaultBearerTokenResolver"&gt;
    &lt;property name="bearerTokenHeaderName" value="Proxy-Authorization"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Or, in circumstances where a provider is using both a custom header and value, you can use <code>HeaderBearerTokenResolver</code> instead.</p>
</div>
</div>
<div class="sect4">
<h5 id="_reading_the_bearer_token_from_a_form_parameter"><a class="anchor" href="#_reading_the_bearer_token_from_a_form_parameter"></a>Reading the Bearer Token from a Form Parameter</h5>
<div class="paragraph">
<p>Or, you may wish to read the token from a form parameter, which you can do by configuring the <code>DefaultBearerTokenResolver</code>, as you can see below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 37. Form Parameter Bearer Token</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">DefaultBearerTokenResolver resolver = new DefaultBearerTokenResolver();
resolver.setAllowFormEncodedBodyParameter(true);
http
    .oauth2ResourceServer(oauth2 -&gt; oauth2
        .bearerTokenResolver(resolver)
    );</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val resolver = DefaultBearerTokenResolver()
resolver.setAllowFormEncodedBodyParameter(true)
http {
    oauth2ResourceServer {
        bearerTokenResolver = resolver
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
    &lt;oauth2-resource-server bearer-token-resolver-ref="bearerTokenResolver"/&gt;
&lt;/http&gt;

&lt;bean id="bearerTokenResolver"
        class="org.springframework.security.oauth2.server.resource.web.HeaderBearerTokenResolver"&gt;
    &lt;property name="allowFormEncodedBodyParameter" value="true"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_bearer_token_propagation"><a class="anchor" href="#_bearer_token_propagation"></a>Bearer Token Propagation</h4>
<div class="paragraph">
<p>Now that you&#8217;re resource server has validated the token, it might be handy to pass it to downstream services.
This is quite simple with <code>{security-api-url}org/springframework/security/oauth2/server/resource/web/reactive/function/client/ServletBearerExchangeFilterFunction.html[ServletBearerExchangeFilterFunction]</code>, which you can see in the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public WebClient rest() {
    return WebClient.builder()
            .filter(new ServletBearerExchangeFilterFunction())
            .build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun rest(): WebClient {
    return WebClient.builder()
            .filter(ServletBearerExchangeFilterFunction())
            .build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When the above <code>WebClient</code> is used to perform requests, Spring Security will look up the current <code>Authentication</code> and extract any <code>{security-api-url}org/springframework/security/oauth2/core/AbstractOAuth2Token.html[AbstractOAuth2Token]</code> credential.
Then, it will propagate that token in the <code>Authorization</code> header.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">this.rest.get()
        .uri("https://other-service.example.com/endpoint")
        .retrieve()
        .bodyToMono(String.class)
        .block()</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">this.rest.get()
        .uri("https://other-service.example.com/endpoint")
        .retrieve()
        .bodyToMono&lt;String&gt;()
        .block()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Will invoke the <code><a href="https://other-service.example.com/endpoint" class="bare">https://other-service.example.com/endpoint</a></code>, adding the bearer token <code>Authorization</code> header for you.</p>
</div>
<div class="paragraph">
<p>In places where you need to override this behavior, it&#8217;s a simple matter of supplying the header yourself, like so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">this.rest.get()
        .uri("https://other-service.example.com/endpoint")
        .headers(headers -&gt; headers.setBearerAuth(overridingToken))
        .retrieve()
        .bodyToMono(String.class)
        .block()</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">this.rest.get()
        .uri("https://other-service.example.com/endpoint")
        .headers{  headers -&gt; headers.setBearerAuth(overridingToken)}
        .retrieve()
        .bodyToMono&lt;String&gt;()
        .block()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In this case, the filter will fall back and simply forward the request onto the rest of the web filter chain.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Unlike the {security-api-url}org/springframework/security/oauth2/client/web/reactive/function/client/ServletOAuth2AuthorizedClientExchangeFilterFunction.html[OAuth 2.0 Client filter function], this filter function makes no attempt to renew the token, should it be expired.
To obtain this level of support, please use the OAuth 2.0 Client filter.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_resttemplate_support"><a class="anchor" href="#_resttemplate_support"></a><code>RestTemplate</code> support</h5>
<div class="paragraph">
<p>There is no <code>RestTemplate</code> equivalent for <code>ServletBearerExchangeFilterFunction</code> at the moment, but you can propagate the request&#8217;s bearer token quite simply with your own interceptor:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
RestTemplate rest() {
	RestTemplate rest = new RestTemplate();
	rest.getInterceptors().add((request, body, execution) -&gt; {
		Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
		if (authentication == null) {
			return execution.execute(request, body);
		}

		if (!(authentication.getCredentials() instanceof AbstractOAuth2Token)) {
			return execution.execute(request, body);
		}

		AbstractOAuth2Token token = (AbstractOAuth2Token) authentication.getCredentials();
	    request.getHeaders().setBearerAuth(token.getTokenValue());
	    return execution.execute(request, body);
	});
	return rest;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun rest(): RestTemplate {
    val rest = RestTemplate()
    rest.interceptors.add(ClientHttpRequestInterceptor { request, body, execution -&gt;
        val authentication: Authentication? = SecurityContextHolder.getContext().authentication
        if (authentication != null) {
            execution.execute(request, body)
        }

        if (authentication!!.credentials !is AbstractOAuth2Token) {
            execution.execute(request, body)
        }

        val token: AbstractOAuth2Token = authentication.credentials as AbstractOAuth2Token
        request.headers.setBearerAuth(token.tokenValue)
        execution.execute(request, body)
    })
    return rest
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Unlike the {security-api-url}org/springframework/security/oauth2/client/OAuth2AuthorizedClientManager.html[OAuth 2.0 Authorized Client Manager], this filter interceptor makes no attempt to renew the token, should it be expired.
To obtain this level of support, please create an interceptor using the <a href="#oauth2client">OAuth 2.0 Authorized Client Manager</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-bearertoken-failure"><a class="anchor" href="#oauth2resourceserver-bearertoken-failure"></a>Bearer Token Failure</h4>
<div class="paragraph">
<p>A bearer token may be invalid for a number of reasons. For example, the token may no longer be active.</p>
</div>
<div class="paragraph">
<p>In these circumstances, Resource Server throws an <code>InvalidBearerTokenException</code>.
Like other exceptions, this results in an OAuth 2.0 Bearer Token error response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-http request hljs" data-lang="http request">HTTP/1.1 401 Unauthorized
WWW-Authenticate: Bearer error_code="invalid_token", error_description="Unsupported algorithm of none", error_uri="https://tools.ietf.org/html/rfc6750#section-3.1"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Additionally, it is published as an <code>AuthenticationFailureBadCredentialsEvent</code>, which you can <a href="#servlet-events">listen for in your application</a> like so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class FailureEvents {
	@EventListener
    public void onFailure(AuthenticationFailureBadCredentialsEvent badCredentials) {
		if (badCredentials.getAuthentication() instanceof BearerTokenAuthenticationToken) {
		    // ... handle
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Component
class FailureEvents {
    @EventListener
    fun onFailure(badCredentials: AuthenticationFailureBadCredentialsEvent) {
        if (badCredentials.authentication is BearerTokenAuthenticationToken) {
            // ... handle
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-saml2"><a class="anchor" href="#servlet-saml2"></a>SAML2</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="servlet-saml2login"><a class="anchor" href="#servlet-saml2login"></a>SAML 2.0 Login</h3>
<div class="paragraph">
<p>The SAML 2.0 Login feature provides an application with the capability to act as a SAML 2.0 Relying Party, having users <a href="https://wiki.shibboleth.net/confluence/display/CONCEPT/FlowsAndConfig">log in</a> to the application by using their existing account at a SAML 2.0 Asserting Party (Okta, ADFS, etc).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
SAML 2.0 Login is implemented by using the <strong>Web Browser SSO Profile</strong>, as specified in
<a href="https://www.oasis-open.org/committees/download.php/35389/sstc-saml-profiles-errata-2.0-wd-06-diff.pdf#page=15">SAML 2 Profiles</a>.
</td>
</tr>
</table>
</div>
<div id="servlet-saml2login-spring-security-history" class="paragraph">
<p>Since 2009, support for relying parties has existed as an <a href="https://github.com/spring-projects/spring-security-saml/tree/1e013b07a7772defd6a26fcfae187c9bf661ee8f#spring-saml">extension project</a>.
In 2019, the process began to port that into <a href="https://github.com/spring-projects/spring-security">Spring Security</a> proper.
This process is similar to the one started in 2017 for <a href="#oauth2">Spring Security&#8217;s OAuth 2.0 support</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A working sample for {gh-samples-url}/servlet/spring-boot/java/saml2-login[SAML 2.0 Login] is available in the {gh-samples-url}[Spring Security Samples repository].</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s take a look at how SAML 2.0 Relying Party Authentication works within Spring Security.
First, we see that, like <a href="#oauth2login">OAuth 2.0 Login</a>, Spring Security takes the user to a third-party for performing authentication.
It does this through a series of redirects.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../_images/servlet/saml2/saml2webssoauthenticationrequestfilter.png" alt="saml2webssoauthenticationrequestfilter">
</div>
<div class="title">Figure 5. Redirecting to Asserting Party Authentication</div>
</div>
<div class="paragraph">
<p>The figure above builds off our <a href="#servlet-securityfilterchain"><code>SecurityFilterChain</code></a> and <a href="#servlet-authentication-abstractprocessingfilter"><code>AbstractAuthenticationProcessingFilter</code></a> diagrams:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../_images/icons/number_1.png" alt="number 1"></span> First, a user makes an unauthenticated request to the resource <code>/private</code> for which it is not authorized.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../_images/icons/number_2.png" alt="number 2"></span> Spring Security&#8217;s <a href="#servlet-authorization-filtersecurityinterceptor"><code>FilterSecurityInterceptor</code></a> indicates that the unauthenticated request is <em>Denied</em> by throwing an <code>AccessDeniedException</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../_images/icons/number_3.png" alt="number 3"></span> Since the user lacks authorization, the <a href="#servlet-exceptiontranslationfilter"><code>ExceptionTranslationFilter</code></a> initiates <em>Start Authentication</em>.
The configured <a href="#servlet-authentication-authenticationentrypoint"><code>AuthenticationEntryPoint</code></a> is an instance of {security-api-url}org/springframework/security/web/authentication/LoginUrlAuthenticationEntryPoint.html[<code>LoginUrlAuthenticationEntryPoint</code>] which redirects to <a href="#servlet-saml2login-sp-initiated-factory">the <code>&lt;saml2:AuthnRequest&gt;</code> generating endpoint</a>, <code>Saml2WebSsoAuthenticationRequestFilter</code>.
Or, if you&#8217;ve <a href="#servlet-saml2login-relyingpartyregistrationrepository">configured more than one asserting party</a>, it will first redirect to a picker page.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../_images/icons/number_4.png" alt="number 4"></span> Next, the <code>Saml2WebSsoAuthenticationRequestFilter</code> creates, signs, serializes, and encodes a <code>&lt;saml2:AuthnRequest&gt;</code> using its configured <a href="#servlet-saml2login-sp-initiated-factory"><code>Saml2AuthenticationRequestFactory</code></a>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../_images/icons/number_5.png" alt="number 5"></span> Then, the browser takes this <code>&lt;saml2:AuthnRequest&gt;</code> and presents it to the asserting party.
The asserting party attempts to authentication the user.
If successful, it will return a <code>&lt;saml2:Response&gt;</code> back to the browser.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../_images/icons/number_6.png" alt="number 6"></span> The browser then POSTs the <code>&lt;saml2:Response&gt;</code> to the assertion consumer service endpoint.</p>
</div>
<div id="servlet-saml2login-authentication-saml2webssoauthenticationfilter" class="imageblock">
<div class="content">
<img src="../_images/servlet/saml2/saml2webssoauthenticationfilter.png" alt="saml2webssoauthenticationfilter">
</div>
<div class="title">Figure 6. Authenticating a <code>&lt;saml2:Response&gt;</code></div>
</div>
<div class="paragraph">
<p>The figure builds off our <a href="#servlet-securityfilterchain"><code>SecurityFilterChain</code></a> diagram.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../_images/icons/number_1.png" alt="number 1"></span> When the browser submits a <code>&lt;saml2:Response&gt;</code> to the application, it <a href="#servlet-saml2login-authenticate-responses">delegates to <code>Saml2WebSsoAuthenticationFilter</code></a>.
This filter calls its configured <code>AuthenticationConverter</code> to create a <code>Saml2AuthenticationToken</code> by extracting the response from the <code>HttpServletRequest</code>.
This converter additionally resolves the <a href="#servlet-saml2login-relyingpartyregistration"><code>RelyingPartyRegistration</code></a> and supplies it to <code>Saml2AuthenticationToken</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../_images/icons/number_2.png" alt="number 2"></span> Next, the filter passes the token to its configured <a href="#servlet-authentication-providermanager"><code>AuthenticationManager</code></a>.
By default, it will use the <a href="#servlet-saml2login-architecture"><code>OpenSamlAuthenticationProvider</code></a>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../_images/icons/number_3.png" alt="number 3"></span> If authentication fails, then <em>Failure</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="#servlet-authentication-securitycontextholder"><code>SecurityContextHolder</code></a> is cleared out.</p>
</li>
<li>
<p>The <a href="#servlet-authentication-authenticationentrypoint"><code>AuthenticationEntryPoint</code></a> is invoked to restart the authentication process.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="image"><img src="../_images/icons/number_4.png" alt="number 4"></span> If authentication is successful, then <em>Success</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="#servlet-authentication-authentication"><code>Authentication</code></a> is set on the <a href="#servlet-authentication-securitycontextholder"><code>SecurityContextHolder</code></a>.</p>
</li>
<li>
<p>The <code>Saml2WebSsoAuthenticationFilter</code> invokes <code>FilterChain#doFilter(request,response)</code> to continue with the rest of the application logic.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="servlet-saml2login-minimaldependencies"><a class="anchor" href="#servlet-saml2login-minimaldependencies"></a>Minimal Dependencies</h4>
<div class="paragraph">
<p>SAML 2.0 service provider support resides in <code>spring-security-saml2-service-provider</code>.
It builds off of the OpenSAML library.</p>
</div>
</div>
<div class="sect3">
<h4 id="servlet-saml2login-minimalconfiguration"><a class="anchor" href="#servlet-saml2login-minimalconfiguration"></a>Minimal Configuration</h4>
<div class="paragraph">
<p>When using <a href="https://spring.io/projects/spring-boot">Spring Boot</a>, configuring an application as a service provider consists of two basic steps.
First, include the needed dependencies and second, indicate the necessary asserting party metadata.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Also, this presupposes that you&#8217;ve already <a href="#servlet-saml2login-metadata">registered the relying party with your asserting party</a>.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_specifying_identity_provider_metadata"><a class="anchor" href="#_specifying_identity_provider_metadata"></a>Specifying Identity Provider Metadata</h5>
<div class="paragraph">
<p>In a Spring Boot application, to specify an identity provider&#8217;s metadata, simply do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">spring:
  security:
    saml2:
      relyingparty:
        registration:
          adfs:
            identityprovider:
              entity-id: https://idp.example.com/issuer
              verification.credentials:
                - certificate-location: "classpath:idp.crt"
              singlesignon.url: https://idp.example.com/issuer/sso
              singlesignon.sign-request: false</code></pre>
</div>
</div>
<div class="paragraph">
<p>where</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="https://idp.example.com/issuer" class="bare">https://idp.example.com/issuer</a></code> is the value contained in the <code>Issuer</code> attribute of the SAML responses that the identity provider will issue</p>
</li>
<li>
<p><code>classpath:idp.crt</code> is the location on the classpath for the identity provider&#8217;s certificate for verifying SAML responses, and</p>
</li>
<li>
<p><code><a href="https://idp.example.com/issuer/sso" class="bare">https://idp.example.com/issuer/sso</a></code> is the endpoint where the identity provider is expecting <code>AuthnRequest</code> s.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>And that&#8217;s it!</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Identity Provider and Asserting Party are synonymous, as are Service Provider and Relying Party.
These are frequently abbreviated as AP and RP, respectively.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_runtime_expectations_3"><a class="anchor" href="#_runtime_expectations_3"></a>Runtime Expectations</h5>
<div class="paragraph">
<p>As configured above, the application processes any <code>POST /login/saml2/sso/{registrationId}</code> request containing a <code>SAMLResponse</code> parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">POST /login/saml2/sso/adfs HTTP/1.1

SAMLResponse=PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are two ways to see induce your asserting party to generate a <code>SAMLResponse</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>First, you can navigate to your asserting party.
It likely has some kind of link or button for each registered relying party that you can click to send the <code>SAMLResponse</code>.</p>
</li>
<li>
<p>Second, you can navigate to a protected page in your app, for example, <code><a href="http://localhost:8080" class="bare">http://localhost:8080</a></code>.
Your app then redirects to the configured asserting party which then sends the <code>SAMLResponse</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>From here, consider jumping to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#servlet-saml2login-architecture">How SAML 2.0 Login Integrates with OpenSAML</a></p>
</li>
<li>
<p><a href="#servlet-saml2login-authenticatedprincipal">How to Use the <code>Saml2AuthenticatedPrincipal</code></a></p>
</li>
<li>
<p><a href="#servlet-saml2login-sansboot">How to Override or Replace Spring Boot&#8217;s Auto Configuration</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-saml2login-architecture"><a class="anchor" href="#servlet-saml2login-architecture"></a>How SAML 2.0 Login Integrates with OpenSAML</h4>
<div class="paragraph">
<p>Spring Security&#8217;s SAML 2.0 support has a couple of design goals:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>First, rely on a library for SAML 2.0 operations and domain objects.
To achieve this, Spring Security uses OpenSAML.</p>
</li>
<li>
<p>Second, ensure this library is not required when using Spring Security&#8217;s SAML support.
To achieve this, any interfaces or classes where Spring Security uses OpenSAML in the contract remain encapsulated.
This makes it possible for you to switch out OpenSAML for some other library or even an unsupported version of OpenSAML.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As a natural outcome of the above two goals, Spring Security&#8217;s SAML API is quite small relative to other modules.
Instead, classes like <code>OpenSamlAuthenticationRequestFactory</code> and <code>OpenSamlAuthenticationProvider</code> expose <code>Converter</code> s that customize various steps in the authentication process.</p>
</div>
<div class="paragraph">
<p>For example, once your application receives a <code>SAMLResponse</code> and delegates to <code>Saml2WebSsoAuthenticationFilter</code>, the filter will delegate to <code>OpenSamlAuthenticationProvider</code>.</p>
</div>
<div class="paragraph">
<div class="title">Authenticating an OpenSAML <code>Response</code></div>
<p><span class="image"><img src="../_images/servlet/saml2/opensamlauthenticationprovider.png" alt="opensamlauthenticationprovider"></span></p>
</div>
<div class="paragraph">
<p>This figure builds off of the <a href="#servlet-saml2login-authentication-saml2webssoauthenticationfilter"><code>Saml2WebSsoAuthenticationFilter</code> diagram</a>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../_images/icons/number_1.png" alt="number 1"></span> The <code>Saml2WebSsoAuthenticationFilter</code> formulates the <code>Saml2AuthenticationToken</code> and invokes the <a href="#servlet-authentication-providermanager"><code>AuthenticationManager</code></a>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../_images/icons/number_2.png" alt="number 2"></span> The <a href="#servlet-authentication-providermanager"><code>AuthenticationManager</code></a> invokes the <code>OpenSamlAuthenticationProvider</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../_images/icons/number_3.png" alt="number 3"></span> The authentication provider deserializes the response into an OpenSAML <code>Response</code> and checks its signature.
If the signature is invalid, authentication fails.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../_images/icons/number_4.png" alt="number 4"></span> Then, the provider <a href="#servlet-saml2login-opensamlauthenticationprovider-decryption">decrypts any <code>EncryptedAssertion</code> elements</a>.
If any decryptions fail, authentication fails.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../_images/icons/number_5.png" alt="number 5"></span> Next, the provider validates the response&#8217;s <code>Issuer</code> and <code>Destination</code> values.
If they don&#8217;t match what&#8217;s in the <code>RelyingPartyRegistration</code>, authentication fails.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../_images/icons/number_6.png" alt="number 6"></span> After that, the provider verifies the signature of each <code>Assertion</code>.
If any signature is invalid, authentication fails.
Also, if neither the response nor the assertions have signatures, authentication fails.
Either the response or all the assertions must have signatures.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../_images/icons/number_7.png" alt="number 7"></span> Then, the provider <a href="#servlet-saml2login-opensamlauthenticationprovider-decryption">decrypts any <code>EncryptedID</code> or <code>EncryptedAttribute</code> elements</a>.
If any decryptions fail, authentication fails.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../_images/icons/number_8.png" alt="number 8"></span> Next, the provider validates each assertion&#8217;s <code>ExpiresAt</code> and <code>NotBefore</code> timestamps, the <code>&lt;Subject&gt;</code> and any <code>&lt;AudienceRestriction&gt;</code> conditions.
If any validations fail, authentication fails.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../_images/icons/number_9.png" alt="number 9"></span> Following that, the provider takes the first assertion&#8217;s <code>AttributeStatement</code> and maps it to a <code>Map&lt;String, List&lt;Object&gt;&gt;</code>.
It also grants the <code>ROLE_USER</code> granted authority.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../_images/icons/number_10.png" alt="number 10"></span> And finally, it takes the <code>NameID</code> from the first assertion, the <code>Map</code> of attributes, and the <code>GrantedAuthority</code> and constructs a <code>Saml2AuthenticatedPrincipal</code>.
Then, it places that principal and the authorities into a <code>Saml2Authentication</code>.</p>
</div>
<div class="paragraph">
<p>The resulting <code>Authentication#getPrincipal</code> is a Spring Security <code>Saml2AuthenticatedPrincipal</code> object, and <code>Authentication#getName</code> maps to the first assertion&#8217;s <code>NameID</code> element.</p>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-opensaml-customization"><a class="anchor" href="#servlet-saml2login-opensaml-customization"></a>Customizing OpenSAML Configuration</h5>
<div class="paragraph">
<p>Any class that uses both Spring Security and OpenSAML should statically initialize <code>OpenSamlInitializationService</code> at the beginning of the class, like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">static {
	OpenSamlInitializationService.initialize();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This replaces OpenSAML&#8217;s <code>InitializationService#initialize</code>.</p>
</div>
<div class="paragraph">
<p>Occasionally, it can be valuable to customize how OpenSAML builds, marshalls, and unmarshalls SAML objects.
In these circumstances, you may instead want to call <code>OpenSamlInitializationService#requireInitialize(Consumer)</code> that gives you access to OpenSAML&#8217;s <code>XMLObjectProviderFactory</code>.</p>
</div>
<div class="paragraph">
<p>For example, when sending an unsigned AuthNRequest, you may want to force reauthentication.
In that case, you can register your own <code>AuthnRequestMarshaller</code>, like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">static {
	OpenSamlInitializationService.requireInitialize(factory -&gt; {
		AuthnRequestMarshaller marshaller = new AuthnRequestMarshaller() {
			@Override
            public Element marshall(XMLObject object, Element element) throws MarshallingException {
				configureAuthnRequest((AuthnRequest) object);
				return super.marshall(object, element);
            }

            public Element marshall(XMLObject object, Document document) throws MarshallingException {
				configureAuthnRequest((AuthnRequest) object);
				return super.marshall(object, document);
            }

            private void configureAuthnRequest(AuthnRequest authnRequest) {
				authnRequest.setForceAuthN(true);
            }
		}

	    factory.getMarshallerFactory().registerMarshaller(AuthnRequest.DEFAULT_ELEMENT_NAME, marshaller);
	});
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>requireInitialize</code> method may only be called once per application instance.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-saml2login-sansboot"><a class="anchor" href="#servlet-saml2login-sansboot"></a>Overriding or Replacing Boot Auto Configuration</h4>
<div class="paragraph">
<p>There are two <code>@Bean</code> s that Spring Boot generates for a relying party.</p>
</div>
<div class="paragraph">
<p>The first is a <code>WebSecurityConfigurerAdapter</code> that configures the app as a relying party.
When including <code>spring-security-saml2-service-provider</code>, the <code>WebSecurityConfigurerAdapter</code> looks like:</p>
</div>
<div class="exampleblock">
<div class="title">Example 38. Default JWT Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">protected void configure(HttpSecurity http) {
    http
        .authorizeRequests(authorize -&gt; authorize
            .anyRequest().authenticated()
        )
        .saml2Login(withDefaults());
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun configure(http: HttpSecurity) {
    http {
        authorizeRequests {
            authorize(anyRequest, authenticated)
        }
        saml2Login { }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the application doesn&#8217;t expose a <code>WebSecurityConfigurerAdapter</code> bean, then Spring Boot will expose the above default one.</p>
</div>
<div class="paragraph">
<p>You can replace this by exposing the bean within the application:</p>
</div>
<div class="exampleblock">
<div class="title">Example 39. Custom SAML 2.0 Login Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class MyCustomSecurityConfiguration extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -&gt; authorize
                .mvcMatchers("/messages/**").hasAuthority("ROLE_USER")
                .anyRequest().authenticated()
            )
            .saml2Login(withDefaults());
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class MyCustomSecurityConfiguration : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize("/messages/**", hasAuthority("ROLE_USER"))
                authorize(anyRequest, authenticated)
            }
            saml2Login {
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The above requires the role of <code>USER</code> for any URL that starts with <code>/messages/</code>.</p>
</div>
<div id="servlet-saml2login-relyingpartyregistrationrepository" class="paragraph">
<p>The second <code>@Bean</code> Spring Boot creates is a {security-api-url}org/springframework/security/saml2/provider/service/registration/RelyingPartyRegistrationRepository.html[<code>RelyingPartyRegistrationRepository</code>], which represents the asserting party and relying party metadata.
This includes things like the location of the SSO endpoint the relying party should use when requesting authentication from the asserting party.</p>
</div>
<div class="paragraph">
<p>You can override the default by publishing your own <code>RelyingPartyRegistrationRepository</code> bean.
For example, you can look up the asserting party&#8217;s configuration by hitting its metadata endpoint like so:</p>
</div>
<div class="exampleblock">
<div class="title">Example 40. Relying Party Registration Repository</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Value("${metadata.location}")
String assertingPartyMetadataLocation;

@Bean
public RelyingPartyRegistrationRepository relyingPartyRegistrations() {
	RelyingPartyRegistration registration = RelyingPartyRegistrations
            .fromMetadataLocation(assertingPartyMetadataLocation)
            .registrationId("example")
            .build();
    return new InMemoryRelyingPartyRegistrationRepository(registration);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Or you can provide each detail manually, as you can see below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 41. Relying Party Registration Repository Manual Configuration</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Value("${verification.key}")
File verificationKey;

@Bean
public RelyingPartyRegistrationRepository relyingPartyRegistrations() throws Exception {
    X509Certificate certificate = X509Support.decodeCertificate(this.verificationKey);
    Saml2X509Credential credential = Saml2X509Credential.verification(certificate);
    RelyingPartyRegistration registration = RelyingPartyRegistration
            .withRegistrationId("example")
            .assertingPartyDetails(party -&gt; party
                .entityId("https://idp.example.com/issuer")
                .singleSignOnServiceLocation("https://idp.example.com/SSO.saml2")
                .wantAuthnRequestsSigned(false)
                .verificationX509Credentials(c -&gt; c.add(credential))
            )
            .build();
    return new InMemoryRelyingPartyRegistrationRepository(registration);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Note that <code>X509Support</code> is an OpenSAML class, used here in the snippet for brevity
</td>
</tr>
</table>
</div>
<div id="servlet-saml2login-relyingpartyregistrationrepository-dsl" class="paragraph">
<p>Alternatively, you can directly wire up the repository using the DSL, which will also override the auto-configured <code>WebSecurityConfigurerAdapter</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 42. Custom Relying Party Registration DSL</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class MyCustomSecurityConfiguration extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -&gt; authorize
                .mvcMatchers("/messages/**").hasAuthority("ROLE_USER")
                .anyRequest().authenticated()
            )
            .saml2Login(saml2 -&gt; saml2
                .relyingPartyRegistrationRepository(relyingPartyRegistrations())
            );
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class MyCustomSecurityConfiguration : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize("/messages/**", hasAuthority("ROLE_USER"))
                authorize(anyRequest, authenticated)
            }
            saml2Login {
                relyingPartyRegistrationRepository = relyingPartyRegistrations()
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A relying party can be multi-tenant by registering more than one relying party in the <code>RelyingPartyRegistrationRepository</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="servlet-saml2login-relyingpartyregistration"><a class="anchor" href="#servlet-saml2login-relyingpartyregistration"></a>RelyingPartyRegistration</h4>
<div class="paragraph">
<p>A {security-api-url}org/springframework/security/saml2/provider/service/registration/RelyingPartyRegistration.html[<code>RelyingPartyRegistration</code>]
instance represents a link between an relying party and assering party&#8217;s metadata.</p>
</div>
<div class="paragraph">
<p>In a <code>RelyingPartyRegistration</code>, you can provide relying party metadata like its <code>Issuer</code> value, where it expects SAML Responses to be sent to, and any credentials that it owns for the purposes of signing or decrypting payloads.</p>
</div>
<div class="paragraph">
<p>Also, you can provide asserting party metadata like its <code>Issuer</code> value, where it expects AuthnRequests to be sent to, and any public credentials that it owns for the purposes of the relying party verifying or encrypting payloads.</p>
</div>
<div class="paragraph">
<p>The following <code>RelyingPartyRegistration</code> is the minimum required for most setups:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RelyingPartyRegistration relyingPartyRegistration = RelyingPartyRegistrations
        .fromMetadataLocation("https://ap.example.org/metadata")
        .registrationId("my-id")
        .build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Though a more sophisticated setup is also possible, like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RelyingPartyRegistration relyingPartyRegistration = RelyingPartyRegistration.withRegistrationId("my-id")
        .entityId("{baseUrl}/{registrationId}")
        .decryptionX509Credentials(c -&gt; c.add(relyingPartyDecryptingCredential()))
        .assertionConsumerServiceLocation("/my-login-endpoint/{registrationId}")
        .assertingParty(party -&gt; party
                .entityId("https://ap.example.org")
                .verificationX509Credentials(c -&gt; c.add(assertingPartyVerifyingCredential()))
                .singleSignOnServiceLocation("https://ap.example.org/SSO.saml2")
        );</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The top-level metadata methods are details about the relying party.
The methods inside <code>assertingPartyDetails</code> are details about the asserting party.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The location where a relying party is expecting SAML Responses is the Assertion Consumer Service Location.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The default for the relying party&#8217;s <code>entityId</code> is <code>{baseUrl}/saml2/service-provider-metadata/{registrationId}</code>.
This is this value needed when configuring the asserting party to know about your relying party.</p>
</div>
<div class="paragraph">
<p>The default for the <code>assertionConsumerServiceLocation</code> is <code>/login/saml2/sso/{registrationId}</code>.
It&#8217;s mapped by default to <a href="#servlet-saml2login-authentication-saml2webssoauthenticationfilter"><code>Saml2WebSsoAuthenticationFilter</code></a> in the filter chain.</p>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-rpr-uripatterns"><a class="anchor" href="#servlet-saml2login-rpr-uripatterns"></a>URI Patterns</h5>
<div class="paragraph">
<p>You probably noticed in the above examples the <code>{baseUrl}</code> and <code>{registrationId}</code> placeholders.</p>
</div>
<div class="paragraph">
<p>These are useful for generating URIs. As such, the relying party&#8217;s <code>entityId</code> and <code>assertionConsumerServiceLocation</code> support the following placeholders:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>baseUrl</code> - the scheme, host, and port of a deployed application</p>
</li>
<li>
<p><code>registrationId</code> - the registration id for this relying party</p>
</li>
<li>
<p><code>baseScheme</code> - the scheme of a deployed application</p>
</li>
<li>
<p><code>baseHost</code> - the host of a deployed application</p>
</li>
<li>
<p><code>basePort</code> - the port of a deployed application</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, the <code>assertionConsumerServiceLocation</code> defined above was:</p>
</div>
<div class="paragraph">
<p><code>/my-login-endpoint/{registrationId}</code></p>
</div>
<div class="paragraph">
<p>which in a deployed application would translate to</p>
</div>
<div class="paragraph">
<p><code>/my-login-endpoint/adfs</code></p>
</div>
<div class="paragraph">
<p>The <code>entityId</code> above was defined as:</p>
</div>
<div class="paragraph">
<p><code>{baseUrl}/{registrationId}</code></p>
</div>
<div class="paragraph">
<p>which in a deployed application would translate to</p>
</div>
<div class="paragraph">
<p><code>https://rp.example.com/adfs</code></p>
</div>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-rpr-credentials"><a class="anchor" href="#servlet-saml2login-rpr-credentials"></a>Credentials</h5>
<div class="paragraph">
<p>You also likely noticed the credential that was used.</p>
</div>
<div class="paragraph">
<p>Oftentimes, a relying party will use the same key to sign payloads as well as decrypt them.
Or it will use the same key to verify payloads as well as encrypt them.</p>
</div>
<div class="paragraph">
<p>Because of this, Spring Security ships with <code>Saml2X509Credential</code>, a SAML-specific credential that simplifies configuring the same key for different use cases.</p>
</div>
<div class="paragraph">
<p>At a minimum, it&#8217;s necessary to have a certificate from the asserting party so that the asserting party&#8217;s signed responses can be verified.</p>
</div>
<div class="paragraph">
<p>To construct a <code>Saml2X509Credential</code> that you&#8217;ll use to verify assertions from the asserting party, you can load the file and use
the <code>CertificateFactory</code> like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Resource resource = new ClassPathResource("ap.crt");
try (InputStream is = resource.getInputStream()) {
	X509Certificate certificate = (X509Certificate)
            CertificateFactory.getInstance("X.509").generateCertificate(is);
	return Saml2X509Credential.verification(certificate);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s say that the asserting party is going to also encrypt the assertion.
In that case, the relying party will need a private key to be able to decrypt the encrypted value.</p>
</div>
<div class="paragraph">
<p>In that case, you&#8217;ll need an <code>RSAPrivateKey</code> as well as its corresponding <code>X509Certificate</code>.
You can load the first using Spring Security&#8217;s <code>RsaKeyConverters</code> utility class and the second as you did before:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">X509Certificate certificate = relyingPartyDecryptionCertificate();
Resource resource = new ClassPathResource("rp.crt");
try (InputStream is = resource.getInputStream()) {
	RSAPrivateKey rsa = RsaKeyConverters.pkcs8().convert(is);
	return Saml2X509Credential.decryption(rsa, certificate);
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
When you specify the locations of these files as the appropriate Spring Boot properties, then Spring Boot will perform these conversions for you.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-rpr-relyingpartyregistrationresolver"><a class="anchor" href="#servlet-saml2login-rpr-relyingpartyregistrationresolver"></a>Resolving the Relying Party from the Request</h5>
<div class="paragraph">
<p>As seen so far, Spring Security resolves the <code>RelyingPartyRegistration</code> by looking for the registration id in the URI path.</p>
</div>
<div class="paragraph">
<p>There are a number of reasons you may want to customize. Among them:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You may know that you will never be a multi-tenant application and so want to have a simpler URL scheme</p>
</li>
<li>
<p>You may identify tenants in a way other than by the URI path</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To customize the way that a <code>RelyingPartyRegistration</code> is resolved, you can configure a custom <code>Converter&lt;HttpServletRequest, RelyingPartyRegistration&gt;</code>.
The default looks up the registration id from the URI&#8217;s last path element and looks it up in your <code>RelyingPartyRegistrationRepository</code>.</p>
</div>
<div class="paragraph">
<p>You can provide a simpler resolver that, for example, always returns the same relying party:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SingleRelyingPartyRegistrationResolver
        implements Converter&lt;HttpServletRequest, RelyingPartyRegistration&gt; {

	@Override
    public RelyingPartyRegistration convert(HttpServletRequest request) {
		return this.relyingParty;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, you can provide this resolver to the appropriate filters that <a href="#servlet-saml2login-sp-initiated-factory">produce <code>&lt;saml2:AuthnRequest&gt;</code> s</a>, <a href="#servlet-saml2login-authenticate-responses">authenticate <code>&lt;saml2:Response&gt;</code> s</a>, and <a href="#servlet-saml2login-metadata">produce <code>&lt;saml2:SPSSODescriptor&gt;</code> metadata</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Remember that if you have any placeholders in your <code>RelyingPartyRegistration</code>, your resolver implementation should resolve them.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-rpr-duplicated"><a class="anchor" href="#servlet-saml2login-rpr-duplicated"></a>Duplicated Relying Party Configurations</h5>
<div class="paragraph">
<p>When an application uses multiple asserting parties, some configuration is duplicated between <code>RelyingPartyRegistration</code> instances:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The relying party&#8217;s <code>entityId</code></p>
</li>
<li>
<p>Its <code>assertionConsumerServiceLocation</code>, and</p>
</li>
<li>
<p>Its credentials, for example its signing or decryption credentials</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>What&#8217;s nice about this setup is credentials may be more easily rotated for some identity providers vs others.</p>
</div>
<div class="paragraph">
<p>The duplication can be alleviated in a few different ways.</p>
</div>
<div class="paragraph">
<p>First, in YAML this can be alleviated with references, like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    saml2:
      relyingparty:
        okta:
          signing.credentials: &amp;relying-party-credentials
            - private-key-location: classpath:rp.key
            - certificate-location: classpath:rp.crt
          identityprovider:
            entity-id: ...
        azure:
          signing.credentials: *relying-party-credentials
          identityprovider:
            entity-id: ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Second, in a database, it&#8217;s not necessary to replicate <code>RelyingPartyRegistration</code> 's model.</p>
</div>
<div class="paragraph">
<p>Third, in Java, you can create a custom configuration method, like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">private RelyingPartyRegistration.Builder
        addRelyingPartyDetails(RelyingPartyRegistration.Builder builder) {

	Saml2X509Credential signingCredential = ...
	builder.signingX509Credentials(c -&gt; c.addAll(signingCredential));
	// ... other relying party configurations
}

@Bean
public RelyingPartyRegistrationRepository relyingPartyRegistrations() {
    RelyingPartyRegistration okta = addRelyingPartyDetails(
            RelyingPartyRegistration
                .fromMetadataLocation(oktaMetadataUrl)
                .registrationId("okta")).build();

    RelyingPartyRegistration azure = addRelyingPartyDetails(
            RelyingPartyRegistration
                .fromMetadataLocation(oktaMetadataUrl)
                .registrationId("azure")).build();

    return new InMemoryRelyingPartyRegistrationRepository(okta, azure);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-saml2login-sp-initiated-factory"><a class="anchor" href="#servlet-saml2login-sp-initiated-factory"></a>Producing <code>&lt;saml2:AuthnRequest&gt;</code> s</h4>
<div class="paragraph">
<p>As stated earlier, Spring Security&#8217;s SAML 2.0 support produces a <code>&lt;saml2:AuthnRequest&gt;</code> to commence authentication with the asserting party.</p>
</div>
<div class="paragraph">
<p>Spring Security achieves this in part by registering the <code>Saml2WebSsoAuthenticationRequestFilter</code> in the filter chain.
This filter by default responds to endpoint <code>/saml2/authenticate/{registrationId}</code>.</p>
</div>
<div class="paragraph">
<p>For example, if you were deployed to <code><a href="https://rp.example.com" class="bare">https://rp.example.com</a></code> and you gave your registration an ID of <code>okta</code>, you could navigate to:</p>
</div>
<div class="paragraph">
<p><code><a href="https://rp.example.org/saml2/authenticate/ping" class="bare">https://rp.example.org/saml2/authenticate/ping</a></code></p>
</div>
<div class="paragraph">
<p>and the result would be a redirect that included a <code>SAMLRequest</code> parameter containing the signed, deflated, and encoded <code>&lt;saml2:AuthnRequest&gt;</code>.</p>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-sp-initiated-factory-signing"><a class="anchor" href="#servlet-saml2login-sp-initiated-factory-signing"></a>Changing How the <code>&lt;saml2:AuthnRequest&gt;</code> Gets Sent</h5>
<div class="paragraph">
<p>By default, Spring Security signs each <code>&lt;saml2:AuthnRequest&gt;</code> and send it as a GET to the asserting party.</p>
</div>
<div class="paragraph">
<p>Many asserting parties don&#8217;t require a signed <code>&lt;saml2:AuthnRequest&gt;</code>.
This can be configured automatically via <code>RelyingPartyRegistrations</code>, or you can supply it manually, like so:</p>
</div>
<div class="exampleblock">
<div class="title">Example 43. Not Requiring Signed AuthnRequests</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Boot</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    saml2:
      relyingparty:
        okta:
          identityprovider:
            entity-id: ...
            singlesignon.sign-request: false</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RelyingPartyRegistration relyingPartyRegistration = RelyingPartyRegistration.withRegistrationId("okta")
        // ...
        .assertingPartyDetails(party -&gt; party
            // ...
            .wantAuthnRequestsSigned(false)
        );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Otherwise, you will need to specify a private key to <code>RelyingPartyRegistration#signingX509Credentials</code> so that Spring Security can sign the <code>&lt;saml2:AuthnRequest&gt;</code> before sending.</p>
</div>
<div id="servlet-saml2login-sp-initiated-factory-algorithm" class="paragraph">
<p>By default, Spring Security will sign the <code>&lt;saml2:AuthnRequest&gt;</code> using <code>rsa-sha256</code>, though some asserting parties will require a different algorithm, as indicated in their metadata.</p>
</div>
<div class="paragraph">
<p>You can configure the algorithm based on the asserting party&#8217;s <a href="#servlet-saml2login-relyingpartyregistrationrepository">metadata using <code>RelyingPartyRegistrations</code></a>.</p>
</div>
<div class="paragraph">
<p>Or, you can provide it manually:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String metadataLocation = "classpath:asserting-party-metadata.xml";
RelyingPartyRegistration relyingPartyRegistration = RelyingPartyRegistrations.fromMetadataLocation(metadataLocation)
        // ...
        .assertingPartyDetails((party) -&gt; party
            // ...
            .signingAlgorithms((sign) -&gt; sign.add(SignatureConstants.ALGO_ID_SIGNATURE_RSA_SHA512))
        );</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The snippet above uses the OpenSAML <code>SignatureConstants</code> class to supply the algorithm name.
But, that&#8217;s just for convenience.
Since the datatype is <code>String</code>, you can supply the name of the algorithm directly.
</td>
</tr>
</table>
</div>
<div id="servlet-saml2login-sp-initiated-factory-binding" class="paragraph">
<p>Some asserting parties require that the <code>&lt;saml2:AuthnRequest&gt;</code> be POSTed.
This can be configured automatically via <code>RelyingPartyRegistrations</code>, or you can supply it manually, like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RelyingPartyRegistration relyingPartyRegistration = RelyingPartyRegistration.withRegistrationId("okta")
        // ...
        .assertingPartyDetails(party -&gt; party
            // ...
            .singleSignOnServiceBinding(Saml2MessageType.POST)
        );</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-sp-initiated-factory-custom-authnrequest"><a class="anchor" href="#servlet-saml2login-sp-initiated-factory-custom-authnrequest"></a>Customizing OpenSAML&#8217;s <code>AuthnRequest</code> Instance</h5>
<div class="paragraph">
<p>There are a number of reasons that you may want to adjust an <code>AuthnRequest</code>.
For example, you may want <code>ForceAuthN</code> to be set to <code>true</code>, which Spring Security sets to <code>false</code> by default.</p>
</div>
<div class="paragraph">
<p>If you don&#8217;t need information from the <code>HttpServletRequest</code> to make your decision, then the easiest way is to <a href="#servlet-saml2login-opensaml-customization">register a custom <code>AuthnRequestMarshaller</code> with OpenSAML</a>.
This will give you access to post-process the <code>AuthnRequest</code> instance before it&#8217;s serialized.</p>
</div>
<div class="paragraph">
<p>But, if you do need something from the request, then you can use create a custom <code>Saml2AuthenticationRequestContext</code> implementation and then a <code>Converter&lt;Saml2AuthenticationRequestContext, AuthnRequest&gt;</code> to build an <code>AuthnRequest</code> yourself, like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class AuthnRequestConverter implements
        Converter&lt;MySaml2AuthenticationRequestContext, AuthnRequest&gt; {

	private final AuthnRequestBuilder authnRequestBuilder;
	private final IssuerBuilder issuerBuilder;

	// ... constructor

	public AuthnRequest convert(Saml2AuthenticationRequestContext context) {
		MySaml2AuthenticationRequestContext myContext = (MySaml2AuthenticationRequestContext) context;
		Issuer issuer = issuerBuilder.buildObject();
		issuer.setValue(myContext.getIssuer());

		AuthnRequest authnRequest = authnRequestBuilder.buildObject();
		authnRequest.setIssuer(iss);
        authnRequest.setDestination(myContext.getDestination());
		authnRequest.setAssertionConsumerServiceURL(myContext.getAssertionConsumerServiceUrl());

		// ... additional settings

		authRequest.setForceAuthn(myContext.getForceAuthn());
		return authnRequest;
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, you can construct your own <code>Saml2AuthenticationRequestContextResolver</code> and <code>Saml2AuthenticationRequestFactory</code> and publish them as <code>@Bean</code> s:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
Saml2AuthenticationRequestContextResolver authenticationRequestContextResolver() {
	Saml2AuthenticationRequestContextResolver resolver =
            new DefaultSaml2AuthenticationRequestContextResolver();
	return request -&gt; {
        Saml2AuthenticationRequestContext context = resolver.resolve(request);
        return new MySaml2AuthenticationRequestContext(context, request.getParameter("force") != null);
	};
}

@Bean
Saml2AuthenticationRequestFactory authenticationRequestFactory(
		AuthnRequestConverter authnRequestConverter) {

	OpenSamlAuthenticationRequestFactory authenticationRequestFactory =
            new OpenSamlAuthenticationRequestFactory();
	authenticationRequestFactory.setAuthenticationRequestContextConverter(authnRequestConverter);
	return authenticationRequestFactory;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-saml2login-authenticate-responses"><a class="anchor" href="#servlet-saml2login-authenticate-responses"></a>Authenticating <code>&lt;saml2:Response&gt;</code> s</h4>
<div class="paragraph">
<p>To verify SAML 2.0 Responses, Spring Security uses <a href="#servlet-saml2login-architecture"><code>OpenSamlAuthenticationProvider</code></a> by default.</p>
</div>
<div class="paragraph">
<p>You can configure this in a number of ways including:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Setting a clock skew to timestamp validation</p>
</li>
<li>
<p>Mapping the response to a list of <code>GrantedAuthority</code> instances</p>
</li>
<li>
<p>Customizing the strategy for validating assertions</p>
</li>
<li>
<p>Customizing the strategy for decrypting response and assertion elements</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>To configure these, you&#8217;ll use the <code>saml2Login#authenticationManager</code> method in the DSL.</p>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-opensamlauthenticationprovider-clockskew"><a class="anchor" href="#servlet-saml2login-opensamlauthenticationprovider-clockskew"></a>Setting a Clock Skew</h5>
<div class="paragraph">
<p>It&#8217;s not uncommon for the asserting and relying parties to have system clocks that aren&#8217;t perfectly synchronized.
For that reason, you can configure <code>OpenSamlAuthenticationProvider</code> 's default assertion validator with some tolerance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        OpenSamlAuthenticationProvider authenticationProvider = new OpenSamlAuthenticationProvider();
        authenticationProvider.setAssertionValidator(OpenSamlAuthenticationProvider
                .createDefaultAssertionValidator(assertionToken -&gt; {
        			Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();
        			params.put(CLOCK_SKEW, Duration.ofMinutes(10).toMillis());
        			// ... other validation parameters
        			return new ValidationContext(params);
        		})
        );

        http
            .authorizeRequests(authz -&gt; authz
                .anyRequest().authenticated()
            )
            .saml2Login(saml2 -&gt; saml2
                .authenticationManager(new ProviderManager(authenticationProvider))
            );
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-opensamlauthenticationprovider-userdetailsservice"><a class="anchor" href="#servlet-saml2login-opensamlauthenticationprovider-userdetailsservice"></a>Coordinating with a <code>UserDetailsService</code></h5>
<div class="paragraph">
<p>Or, perhaps you would like to include user details from a legacy <code>UserDetailsService</code>.
In that case, the response authentication converter can come in handy, as can be seen below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Autowired
    UserDetailsService userDetailsService;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        OpenSamlAuthenticationProvider authenticationProvider = new OpenSamlAuthenticationProvider();
        authenticationProvider.setResponseAuthenticationConverter(responseToken -&gt; {
        	Saml2Authentication authentication = OpenSamlAuthenticationProvider
                    .createDefaultResponseAuthenticationConverter() <i class="conum" data-value="1"></i><b>(1)</b>
                    .convert(responseToken);
        	Assertion assertion = responseToken.getResponse().getAssertions().get(0);
            String username = assertion.getSubject().getNameID().getValue();
            UserDetails userDetails = this.userDetailsService.loadUserByUsername(username); <i class="conum" data-value="2"></i><b>(2)</b>
            return MySaml2Authentication(userDetails, authentication); <i class="conum" data-value="3"></i><b>(3)</b>
        });

        http
            .authorizeRequests(authz -&gt; authz
                .anyRequest().authenticated()
            )
            .saml2Login(saml2 -&gt; saml2
                .authenticationManager(new ProviderManager(authenticationProvider))
            );
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>First, call the default converter, which extracts attributes and authorities from the response</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Second, call the <a href="#servlet-authentication-userdetailsservice"><code>UserDetailsService</code></a> using the relevant information</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Third, return a custom authentication that includes the user details</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It&#8217;s not required to call <code>OpenSamlAuthenticationProvider</code> 's default authentication converter.
It returns a <code>Saml2AuthenticatedPrincipal</code> containing the attributes it extracted from <code>AttributeStatement</code> s as well as the single <code>ROLE_USER</code> authority.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-opensamlauthenticationprovider-additionalvalidation"><a class="anchor" href="#servlet-saml2login-opensamlauthenticationprovider-additionalvalidation"></a>Performing Additional Validation</h5>
<div class="paragraph">
<p><code>OpenSamlAuthenticationProvider</code> performs minimal validation on SAML 2.0 Assertions.
After verifying the signature, it will:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Validate <code>&lt;AudienceRestriction&gt;</code> and <code>&lt;DelegationRestriction&gt;</code> conditions</p>
</li>
<li>
<p>Validate <code>&lt;SubjectConfirmation&gt;</code> s, expect for any IP address information</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>To perform additional validation, you can configure your own assertion validator that delegates to <code>OpenSamlAuthenticationProvider</code> 's default and then performs its own.</p>
</div>
<div id="servlet-saml2login-opensamlauthenticationprovider-onetimeuse" class="paragraph">
<p>For example, you can use OpenSAML&#8217;s <code>OneTimeUseConditionValidator</code> to also validate a <code>&lt;OneTimeUse&gt;</code> condition, like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">OpenSamlAuthenticationProvider provider = new OpenSamlAuthenticationProvider();
OneTimeUseConditionValidator validator = ...;
provider.setAssertionValidator(assertionToken -&gt; {
    Saml2ResponseValidatorResult result = OpenSamlAuthenticationProvider
            .createDefaultAssertionValidator()
            .convert(assertionToken);
    Assertion assertion = assertionToken.getAssertion();
    OneTimeUse oneTimeUse = assertion.getConditions().getOneTimeUse();
    ValidationContext context = new ValidationContext();
    try {
    	if (validator.validate(oneTimeUse, assertion, context) == ValidationResult.VALID) {
    		return result;
    	}
    } catch (Exception e) {
    	return result.concat(new Saml2Error(INVALID_ASSERTION, e.getMessage()));
    }
    return result.contact(new Saml2Error(INVALID_ASSERTION, context.getValidationFailureMessage()));
});</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
While recommended, it&#8217;s not necessary to call <code>OpenSamlAuthenticationProvider</code> 's default assertion validator.
A circumstance where you would skip it would be if you don&#8217;t need it to check the <code>&lt;AudienceRestriction&gt;</code> or the <code>&lt;SubjectConfirmation&gt;</code> since you are doing those yourself.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-opensamlauthenticationprovider-decryption"><a class="anchor" href="#servlet-saml2login-opensamlauthenticationprovider-decryption"></a>Customizing Decryption</h5>
<div class="paragraph">
<p>Spring Security decrypts <code>&lt;saml2:EncryptedAssertion&gt;</code>, <code>&lt;saml2:EncryptedAttribute&gt;</code>, and <code>&lt;saml2:EncryptedID&gt;</code> elements automatically by using the decryption <a href="#servlet-saml2login-rpr-credentials"><code>Saml2X509Credential</code> instances</a> registered in the <a href="#servlet-saml2login-relyingpartyregistration"><code>RelyingPartyRegistration</code></a>.</p>
</div>
<div class="paragraph">
<p><code>OpenSamlAuthenticationProvider</code> exposes <a href="#servlet-saml2login-architecture">two decryption strategies</a>.
The response decrypter is for decrypting encrypted elements of the <code>&lt;saml2:Response&gt;</code>, like <code>&lt;saml2:EncryptedAssertion&gt;</code>.
The assertion decrypter is for decrypting encrypted elements of the <code>&lt;saml2:Assertion&gt;</code>, like <code>&lt;saml2:EncryptedAttribute&gt;</code> and <code>&lt;saml2:EncryptedID&gt;</code>.</p>
</div>
<div class="paragraph">
<p>You can replace <code>OpenSamlAuthenticationProvider&#8217;s default decryption strategy with your own.
For example, if you have a separate service that decrypts the assertions in a `&lt;saml2:Response&gt;</code>, you can use it instead like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MyDecryptionService decryptionService = ...;
OpenSamlAuthenticationProvider provider = new OpenSamlAuthenticationProvider();
provider.setResponseElementsDecrypter((responseToken) -&gt; decryptionService.decrypt(responseToken.getResponse()));</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you are also decrypting individual elements in a <code>&lt;saml2:Assertion&gt;</code>, you can customize the assertion decrypter, too:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">provider.setAssertionElementsDecrypter((assertionToken) -&gt; decryptionService.decrypt(assertionToken.getAssertion()));</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There are two separate decrypters since assertions can be signed separately from responses.
Trying to decrypt a signed assertion&#8217;s elements before signature verification may invalidate the signature.
If your asserting party signs the response only, then it&#8217;s safe to decrypt all elements using only the response decrypter.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-authenticationmanager-custom"><a class="anchor" href="#servlet-saml2login-authenticationmanager-custom"></a>Using a Custom Authentication Manager</h5>
<div id="servlet-saml2login-opensamlauthenticationprovider-authenticationmanager" class="paragraph">
<p>Of course, the <code>authenticationManager</code> DSL method can be also used to perform a completely custom SAML 2.0 authentication.
This authentication manager should expect a <code>Saml2AuthenticationToken</code> object containing the SAML 2.0 Response XML data.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        AuthenticationManager authenticationManager = new MySaml2AuthenticationManager(...);
        http
            .authorizeRequests(authorize -&gt; authorize
                .anyRequest().authenticated()
            )
            .saml2Login(saml2 -&gt; saml2
                .authenticationManager(authenticationManager)
            )
        ;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-saml2login-authenticatedprincipal"><a class="anchor" href="#servlet-saml2login-authenticatedprincipal"></a>Using <code>Saml2AuthenticatedPrincipal</code></h4>
<div class="paragraph">
<p>With the relying party correctly configured for a given asserting party, it&#8217;s ready to accept assertions.
Once the relying party validates an assertion, the result is a <code>Saml2Authentication</code> with a <code>Saml2AuthenticatedPrincipal</code>.</p>
</div>
<div class="paragraph">
<p>This means that you can access the principal in your controller like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
public class MainController {
	@GetMapping("/")
	public String index(@AuthenticationPrincipal Saml2AuthenticatedPrincipal principal, Model model) {
		String email = principal.getFirstAttribute("email");
		model.setAttribute("email", email);
		return "index";
	}
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Because the SAML 2.0 specification allows for each attribute to have multiple values, you can either call <code>getAttribute</code> to get the list of attributes or <code>getFirstAttribute</code> to get the first in the list.
<code>getFirstAttribute</code> is quite handy when you know that there is only one value.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="servlet-saml2login-metadata"><a class="anchor" href="#servlet-saml2login-metadata"></a>Producing <code>&lt;saml2:SPSSODescriptor&gt;</code> Metadata</h4>
<div class="paragraph">
<p>You can publish a metadata endpoint by adding the <code>Saml2MetadataFilter</code> to the filter chain, as you&#8217;ll see below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Converter&lt;HttpServletRequest, RelyingPartyRegistration&gt; relyingPartyRegistrationResolver =
        new DefaultRelyingPartyRegistrationResolver(this.relyingPartyRegistrationRepository);
Saml2MetadataFilter filter = new Saml2MetadataFilter(
		relyingPartyRegistrationResolver,
        new OpenSamlMetadataResolver());

http
    // ...
    .saml2Login(withDefaults())
    .addFilterBefore(new Saml2MetadataFilter(r), Saml2WebSsoAuthenticationFilter.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use this metadata endpoint to register your relying party with your asserting party.
This is often as simple as finding the correct form field to supply the metadata endpoint.</p>
</div>
<div class="paragraph">
<p>By default, the metadata endpoint is <code>/saml2/service-provider-metadata/{registrationId}</code>.
You can change this by calling the <code>setRequestMatcher</code> method on the filter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">filter.setRequestMatcher(new AntPathRequestMatcher("/saml2/metadata/{registrationId}", "GET"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>ensuring that the <code>registrationId</code> hint is at the end of the path.</p>
</div>
<div class="paragraph">
<p>Or, if you have registered a custom relying party registration resolver in the constructor, then you can specify a path without a <code>registrationId</code> hint, like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">filter.setRequestMatcher(new AntPathRequestMatcher("/saml2/metadata", "GET"));</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-saml2login-logout"><a class="anchor" href="#servlet-saml2login-logout"></a>Performing Single Logout</h4>
<div class="paragraph">
<p>Spring Security does not yet support single logout.</p>
</div>
<div class="paragraph">
<p>Generally speaking, though, you can achieve this by creating and registering a custom <code>LogoutSuccessHandler</code> and <code>RequestMatcher</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">http
    // ...
    .logout(logout -&gt; logout
        .logoutSuccessHandler(myCustomSuccessHandler())
        .logoutRequestMatcher(myRequestMatcher())
    )</code></pre>
</div>
</div>
<div class="paragraph">
<p>The success handler will send logout requests to the asserting party.</p>
</div>
<div class="paragraph">
<p>The request matcher will detect logout requests from the asserting party.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-exploits"><a class="anchor" href="#servlet-exploits"></a>Protection Against Exploits</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section discusses protection against servlet exploits.</p>
</div>
<div class="paragraph">
<p>Unresolved include directive in modules/ROOT/pages/servlet/index.adoc - include::integrations/index.adoc[]</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jc"><a class="anchor" href="#jc"></a>Java Configuration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>General support for <a href="https://docs.spring.io/spring/docs/3.1.x/spring-framework-reference/html/beans.html#beans-java">Java Configuration</a> was added to Spring Framework in Spring 3.1.
Since Spring Security 3.2 there has been Spring Security Java Configuration support which enables users to easily configure Spring Security without the use of any XML.</p>
</div>
<div class="paragraph">
<p>If you are familiar with the <a href="#ns-config">Security Namespace Configuration</a> then you should find quite a few similarities between it and the Security Java Configuration support.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Security provides <a href="https://github.com/spring-projects/spring-security-samples/tree/main/servlet/java-configuration">lots of sample applications</a> which demonstrate the use of Spring Security Java Configuration.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_hello_web_security_java_configuration"><a class="anchor" href="#_hello_web_security_java_configuration"></a>Hello Web Security Java Configuration</h3>
<div class="paragraph">
<p>The first step is to create our Spring Security Java Configuration.
The configuration creates a Servlet Filter known as the <code>springSecurityFilterChain</code> which is responsible for all the security (protecting the application URLs, validating submitted username and passwords, redirecting to the log in form, etc) within your application.
You can find the most basic example of a Spring Security Java Configuration below:</p>
</div>
<div id="jc-hello-wsca" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.beans.factory.annotation.Autowired;

import org.springframework.context.annotation.*;
import org.springframework.security.config.annotation.authentication.builders.*;
import org.springframework.security.config.annotation.web.configuration.*;

@EnableWebSecurity
public class WebSecurityConfig {

	@Bean
	public UserDetailsService userDetailsService() {
		InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
		manager.createUser(User.withDefaultPasswordEncoder().username("user").password("password").roles("USER").build());
		return manager;
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There really isn&#8217;t much to this configuration, but it does a lot.
You can find a summary of the features below:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Require authentication to every URL in your application</p>
</li>
<li>
<p>Generate a login form for you</p>
</li>
<li>
<p>Allow the user with the <strong>Username</strong> <em>user</em> and the <strong>Password</strong> <em>password</em> to authenticate with form based authentication</p>
</li>
<li>
<p>Allow the user to logout</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery">CSRF attack</a> prevention</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Session_fixation">Session Fixation</a> protection</p>
</li>
<li>
<p>Security Header integration</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security">HTTP Strict Transport Security</a> for secure requests</p>
</li>
<li>
<p><a href="https://msdn.microsoft.com/en-us/library/ie/gg622941(v=vs.85).aspx">X-Content-Type-Options</a> integration</p>
</li>
<li>
<p>Cache Control (can be overridden later by your application to allow caching of your static resources)</p>
</li>
<li>
<p><a href="https://msdn.microsoft.com/en-us/library/dd565647(v=vs.85).aspx">X-XSS-Protection</a> integration</p>
</li>
<li>
<p>X-Frame-Options integration to help prevent <a href="https://en.wikipedia.org/wiki/Clickjacking">Clickjacking</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>Integrate with the following Servlet API methods</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getRemoteUser()">HttpServletRequest#getRemoteUser()</a></p>
</li>
<li>
<p><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getUserPrincipal()">HttpServletRequest#getUserPrincipal()</a></p>
</li>
<li>
<p><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#isUserInRole(java.lang.String)">HttpServletRequest#isUserInRole(java.lang.String)</a></p>
</li>
<li>
<p><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#login(java.lang.String,%20java.lang.String)">HttpServletRequest#login(java.lang.String, java.lang.String)</a></p>
</li>
<li>
<p><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#logout()">HttpServletRequest#logout()</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_abstractsecuritywebapplicationinitializer"><a class="anchor" href="#_abstractsecuritywebapplicationinitializer"></a>AbstractSecurityWebApplicationInitializer</h4>
<div class="paragraph">
<p>The next step is to register the <code>springSecurityFilterChain</code> with the war.
This can be done in Java Configuration with <a href="https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/mvc.html#mvc-container-config">Spring&#8217;s WebApplicationInitializer support</a> in a Servlet 3.0+ environment.
Not suprisingly, Spring Security provides a base class <code>AbstractSecurityWebApplicationInitializer</code> that will ensure the <code>springSecurityFilterChain</code> gets registered for you.
The way in which we use <code>AbstractSecurityWebApplicationInitializer</code> differs depending on if we are already using Spring or if Spring Security is the only Spring component in our application.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#abstractsecuritywebapplicationinitializer-without-existing-spring">[abstractsecuritywebapplicationinitializer-without-existing-spring]</a> - Use these instructions if you are not using Spring already</p>
</li>
<li>
<p><a href="#abstractsecuritywebapplicationinitializer-with-spring-mvc">[abstractsecuritywebapplicationinitializer-with-spring-mvc]</a> - Use these instructions if you are already using Spring</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_abstractsecuritywebapplicationinitializer_without_existing_spring"><a class="anchor" href="#_abstractsecuritywebapplicationinitializer_without_existing_spring"></a>AbstractSecurityWebApplicationInitializer without Existing Spring</h4>
<div class="paragraph">
<p>If you are not using Spring or Spring MVC, you will need to pass in the <code>WebSecurityConfig</code> into the superclass to ensure the configuration is picked up.
You can find an example below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.security.web.context.*;

public class SecurityWebApplicationInitializer
	extends AbstractSecurityWebApplicationInitializer {

	public SecurityWebApplicationInitializer() {
		super(WebSecurityConfig.class);
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>SecurityWebApplicationInitializer</code> will do the following things:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Automatically register the springSecurityFilterChain Filter for every URL in your application</p>
</li>
<li>
<p>Add a ContextLoaderListener that loads the <a href="#jc-hello-wsca">WebSecurityConfig</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_abstractsecuritywebapplicationinitializer_with_spring_mvc"><a class="anchor" href="#_abstractsecuritywebapplicationinitializer_with_spring_mvc"></a>AbstractSecurityWebApplicationInitializer with Spring MVC</h4>
<div class="paragraph">
<p>If we were using Spring elsewhere in our application we probably already had a <code>WebApplicationInitializer</code> that is loading our Spring Configuration.
If we use the previous configuration we would get an error.
Instead, we should register Spring Security with the existing <code>ApplicationContext</code>.
For example, if we were using Spring MVC our <code>SecurityWebApplicationInitializer</code> would look something like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.security.web.context.*;

public class SecurityWebApplicationInitializer
	extends AbstractSecurityWebApplicationInitializer {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This would simply only register the springSecurityFilterChain Filter for every URL in your application.
After that we would ensure that <code>WebSecurityConfig</code> was loaded in our existing ApplicationInitializer.
For example, if we were using Spring MVC it would be added in the <code>getRootConfigClasses()</code></p>
</div>
<div id="message-web-application-inititializer-java" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MvcWebApplicationInitializer extends
		AbstractAnnotationConfigDispatcherServletInitializer {

	@Override
	protected Class&lt;?&gt;[] getRootConfigClasses() {
		return new Class[] { WebSecurityConfig.class };
	}

	// ... other overrides ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jc-httpsecurity"><a class="anchor" href="#jc-httpsecurity"></a>HttpSecurity</h3>
<div class="paragraph">
<p>Thus far our <a href="#jc-hello-wsca">WebSecurityConfig</a> only contains information about how to authenticate our users.
How does Spring Security know that we want to require all users to be authenticated?
How does Spring Security know we want to support form based authentication?
Actually, there is a configuration class that is being invoked behind the scenes called <code>WebSecurityConfigurerAdapter</code>.
It has a method called <code>configure</code> with the following default implementation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">protected void configure(HttpSecurity http) throws Exception {
	http
		.authorizeRequests(authorize -&gt; authorize
			.anyRequest().authenticated()
		)
		.formLogin(withDefaults())
		.httpBasic(withDefaults());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The default configuration above:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ensures that any request to our application requires the user to be authenticated</p>
</li>
<li>
<p>Allows users to authenticate with form based login</p>
</li>
<li>
<p>Allows users to authenticate with HTTP Basic authentication</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You will notice that this configuration is quite similar the XML Namespace configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;intercept-url pattern="/**" access="authenticated"/&gt;
	&lt;form-login /&gt;
	&lt;http-basic /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_multiple_httpsecurity"><a class="anchor" href="#_multiple_httpsecurity"></a>Multiple HttpSecurity</h3>
<div class="paragraph">
<p>We can configure multiple HttpSecurity instances just as we can have multiple <code>&lt;http&gt;</code> blocks.
The key is to extend the <code>WebSecurityConfigurerAdapter</code> multiple times.
For example, the following is an example of having a different configuration for URL&#8217;s that start with <code>/api/</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class MultiHttpSecurityConfig {
	@Bean                                                             <i class="conum" data-value="1"></i><b>(1)</b>
	public UserDetailsService userDetailsService() throws Exception {
		// ensure the passwords are encoded properly
		UserBuilder users = User.withDefaultPasswordEncoder();
		InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
		manager.createUser(users.username("user").password("password").roles("USER").build());
		manager.createUser(users.username("admin").password("password").roles("USER","ADMIN").build());
		return manager;
	}

	@Configuration
	@Order(1)                                                        <i class="conum" data-value="2"></i><b>(2)</b>
	public static class ApiWebSecurityConfigurationAdapter extends WebSecurityConfigurerAdapter {
		protected void configure(HttpSecurity http) throws Exception {
			http
				.antMatcher("/api/**")                               <i class="conum" data-value="3"></i><b>(3)</b>
				.authorizeRequests(authorize -&gt; authorize
					.anyRequest().hasRole("ADMIN")
			    )
				.httpBasic(withDefaults());
		}
	}

	@Configuration                                                   <i class="conum" data-value="4"></i><b>(4)</b>
	public static class FormLoginWebSecurityConfigurerAdapter extends WebSecurityConfigurerAdapter {

		@Override
		protected void configure(HttpSecurity http) throws Exception {
			http
				.authorizeRequests(authorize -&gt; authorize
					.anyRequest().authenticated()
				)
				.formLogin(withDefaults());
		}
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Configure Authentication as normal</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Create an instance of <code>WebSecurityConfigurerAdapter</code> that contains <code>@Order</code> to specify which <code>WebSecurityConfigurerAdapter</code> should be considered first.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>http.antMatcher</code> states that this <code>HttpSecurity</code> will only be applicable to URLs that start with <code>/api/</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Create another instance of <code>WebSecurityConfigurerAdapter</code>.
If the URL does not start with <code>/api/</code> this configuration will be used.
This configuration is considered after <code>ApiWebSecurityConfigurationAdapter</code> since it has an <code>@Order</code> value after <code>1</code> (no <code>@Order</code> defaults to last).</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="jc-custom-dsls"><a class="anchor" href="#jc-custom-dsls"></a>Custom DSLs</h3>
<div class="paragraph">
<p>You can provide your own custom DSLs in Spring Security.
For example, you might have something that looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyCustomDsl extends AbstractHttpConfigurer&lt;MyCustomDsl, HttpSecurity&gt; {
	private boolean flag;

	@Override
	public void init(HttpSecurity http) throws Exception {
		// any method that adds another configurer
		// must be done in the init method
		http.csrf().disable();
	}

	@Override
	public void configure(HttpSecurity http) throws Exception {
		ApplicationContext context = http.getSharedObject(ApplicationContext.class);

		// here we lookup from the ApplicationContext. You can also just create a new instance.
		MyFilter myFilter = context.getBean(MyFilter.class);
		myFilter.setFlag(flag);
		http.addFilterBefore(myFilter, UsernamePasswordAuthenticationFilter.class);
	}

	public MyCustomDsl flag(boolean value) {
		this.flag = value;
		return this;
	}

	public static MyCustomDsl customDsl() {
		return new MyCustomDsl();
	}
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This is actually how methods like <code>HttpSecurity.authorizeRequests()</code> are implemented.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The custom DSL can then be used like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class Config extends WebSecurityConfigurerAdapter {
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.apply(customDsl())
				.flag(true)
				.and()
			...;
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code is invoked in the following order:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Code in `Config`s configure method is invoked</p>
</li>
<li>
<p>Code in `MyCustomDsl`s init method is invoked</p>
</li>
<li>
<p>Code in `MyCustomDsl`s configure method is invoked</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you want, you can have <code>WebSecurityConfigurerAdapter</code> add <code>MyCustomDsl</code> by default by using <code>SpringFactories</code>.
For example, you would create a resource on the classpath named <code>META-INF/spring.factories</code> with the following contents:</p>
</div>
<div class="listingblock">
<div class="title">META-INF/spring.factories</div>
<div class="content">
<pre>org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer = sample.MyCustomDsl</pre>
</div>
</div>
<div class="paragraph">
<p>Users wishing to disable the default can do so explicitly.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class Config extends WebSecurityConfigurerAdapter {
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.apply(customDsl()).disable()
			...;
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="post-processing-configured-objects"><a class="anchor" href="#post-processing-configured-objects"></a>Post Processing Configured Objects</h3>
<div class="paragraph">
<p>Spring Security&#8217;s Java Configuration does not expose every property of every object that it configures.
This simplifies the configuration for a majority of users.
Afterall, if every property was exposed, users could use standard bean configuration.</p>
</div>
<div class="paragraph">
<p>While there are good reasons to not directly expose every property, users may still need more advanced configuration options.
To address this Spring Security introduces the concept of an <code>ObjectPostProcessor</code> which can be used to modify or replace many of the Object instances created by the Java Configuration.
For example, if you wanted to configure the <code>filterSecurityPublishAuthorizationSuccess</code> property on <code>FilterSecurityInterceptor</code> you could use the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Override
protected void configure(HttpSecurity http) throws Exception {
	http
		.authorizeRequests(authorize -&gt; authorize
			.anyRequest().authenticated()
			.withObjectPostProcessor(new ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() {
				public &lt;O extends FilterSecurityInterceptor&gt; O postProcess(
						O fsi) {
					fsi.setPublishAuthorizationSuccess(true);
					return fsi;
				}
			})
		);
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="kotlin-config"><a class="anchor" href="#kotlin-config"></a>Kotlin Configuration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security Kotlin Configuration support has been available since Spring Security 5.3.
It enables users to easily configure Spring Security using a native Kotlin DSL.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Security provides <a href="https://github.com/spring-projects/spring-security-samples/tree/main/servlet/spring-boot/kotlin/hello-security">a sample application</a> which demonstrates the use of Spring Security Kotlin Configuration.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="kotlin-config-httpsecurity"><a class="anchor" href="#kotlin-config-httpsecurity"></a>HttpSecurity</h3>
<div class="paragraph">
<p>How does Spring Security know that we want to require all users to be authenticated?
How does Spring Security know we want to support form based authentication?
There is a configuration class that is being invoked behind the scenes called <code>WebSecurityConfigurerAdapter</code>.
It has a method called <code>configure</code> with the following default implementation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun configure(http: HttpSecurity) {
   http {
        authorizeRequests {
            authorize(anyRequest, authenticated)
        }
       formLogin { }
       httpBasic { }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The default configuration above:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ensures that any request to our application requires the user to be authenticated</p>
</li>
<li>
<p>Allows users to authenticate with form based login</p>
</li>
<li>
<p>Allows users to authenticate with HTTP Basic authentication</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You will notice that this configuration is quite similar the XML Namespace configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;intercept-url pattern="/**" access="authenticated"/&gt;
	&lt;form-login /&gt;
	&lt;http-basic /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_multiple_httpsecurity_2"><a class="anchor" href="#_multiple_httpsecurity_2"></a>Multiple HttpSecurity</h3>
<div class="paragraph">
<p>We can configure multiple HttpSecurity instances just as we can have multiple <code>&lt;http&gt;</code> blocks.
The key is to extend the <code>WebSecurityConfigurerAdapter</code> multiple times.
For example, the following is an example of having a different configuration for URL&#8217;s that start with <code>/api/</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class MultiHttpSecurityConfig {
    @Bean                                                            <i class="conum" data-value="1"></i><b>(1)</b>
    public fun userDetailsService(): UserDetailsService {
        val users: User.UserBuilder = User.withDefaultPasswordEncoder()
        val manager = InMemoryUserDetailsManager()
        manager.createUser(users.username("user").password("password").roles("USER").build())
        manager.createUser(users.username("admin").password("password").roles("USER","ADMIN").build())
        return manager
    }

    @Configuration
    @Order(1)                                                        <i class="conum" data-value="2"></i><b>(2)</b>
    class ApiWebSecurityConfigurationAdapter: WebSecurityConfigurerAdapter() {
        override fun configure(http: HttpSecurity) {
            http {
                securityMatcher("/api/**")                           <i class="conum" data-value="3"></i><b>(3)</b>
                authorizeRequests {
                    authorize(anyRequest, hasRole("ADMIN"))
                }
                httpBasic { }
            }
        }
    }

    @Configuration                                                   <i class="conum" data-value="4"></i><b>(4)</b>
    class FormLoginWebSecurityConfigurerAdapter: WebSecurityConfigurerAdapter() {
        override fun configure(http: HttpSecurity) {
            http {
                authorizeRequests {
                    authorize(anyRequest, authenticated)
                }
                formLogin { }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Configure Authentication as normal</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Create an instance of <code>WebSecurityConfigurerAdapter</code> that contains <code>@Order</code> to specify which <code>WebSecurityConfigurerAdapter</code> should be considered first.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>http.antMatcher</code> states that this <code>HttpSecurity</code> will only be applicable to URLs that start with <code>/api/</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Create another instance of <code>WebSecurityConfigurerAdapter</code>.
If the URL does not start with <code>/api/</code> this configuration will be used.
This configuration is considered after <code>ApiWebSecurityConfigurationAdapter</code> since it has an <code>@Order</code> value after <code>1</code> (no <code>@Order</code> defaults to last).</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ns-config"><a class="anchor" href="#ns-config"></a>Security Namespace Configuration</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_introduction"><a class="anchor" href="#_introduction"></a>Introduction</h3>
<div class="paragraph">
<p>Namespace configuration has been available since version 2.0 of the Spring Framework.
It allows you to supplement the traditional Spring beans application context syntax with elements from additional XML schema.
You can find more information in the Spring <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/">Reference Documentation</a>.
A namespace element can be used simply to allow a more concise way of configuring an individual bean or, more powerfully, to define an alternative configuration syntax which more closely matches the problem domain and hides the underlying complexity from the user.
A simple element may conceal the fact that multiple beans and processing steps are being added to the application context.
For example, adding the following element from the security namespace to an application context will start up an embedded LDAP server for testing use within the application:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;security:ldap-server /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is much simpler than wiring up the equivalent Apache Directory Server beans.
The most common alternative configuration requirements are supported by attributes on the <code>ldap-server</code> element and the user is isolated from worrying about which beans they need to create and what the bean property names are.
<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup>.
Use of a good XML editor while editing the application context file should provide information on the attributes and elements that are available.
We would recommend that you try out the <a href="https://spring.io/tools">Eclipse IDE with Spring Tools</a> as it has special features for working with standard Spring namespaces.</p>
</div>
<div class="paragraph">
<p>To start using the security namespace in your application context, you need to have the <code>spring-security-config</code> jar on your classpath.
Then all you need to do is add the schema declaration to your application context file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
xmlns:security="http://www.springframework.org/schema/security"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans-3.0.xsd
		http://www.springframework.org/schema/security
		https://www.springframework.org/schema/security/spring-security.xsd"&gt;
	...
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In many of the examples you will see (and in the sample applications), we will often use "security" as the default namespace rather than "beans", which means we can omit the prefix on all the security namespace elements, making the content easier to read.
You may also want to do this if you have your application context divided up into separate files and have most of your security configuration in one of them.
Your security application context file would then start like this</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;beans:beans xmlns="http://www.springframework.org/schema/security"
xmlns:beans="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans-3.0.xsd
		http://www.springframework.org/schema/security
		https://www.springframework.org/schema/security/spring-security.xsd"&gt;
	...
&lt;/beans:beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;ll assume this syntax is being used from now on in this chapter.</p>
</div>
<div class="sect3">
<h4 id="_design_of_the_namespace"><a class="anchor" href="#_design_of_the_namespace"></a>Design of the Namespace</h4>
<div class="paragraph">
<p>The namespace is designed to capture the most common uses of the framework and provide a simplified and concise syntax for enabling them within an application.
The design is based around the large-scale dependencies within the framework, and can be divided up into the following areas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Web/HTTP Security</em> - the most complex part.
Sets up the filters and related service beans used to apply the framework authentication mechanisms, to secure URLs, render login and error pages and much more.</p>
</li>
<li>
<p><em>Business Object (Method) Security</em> - options for securing the service layer.</p>
</li>
<li>
<p><em>AuthenticationManager</em> - handles authentication requests from other parts of the framework.</p>
</li>
<li>
<p><em>AccessDecisionManager</em> - provides access decisions for web and method security.
A default one will be registered, but you can also choose to use a custom one, declared using normal Spring bean syntax.</p>
</li>
<li>
<p><em>AuthenticationProvider</em>s - mechanisms against which the authentication manager authenticates users.
The namespace provides supports for several standard options and also a means of adding custom beans declared using a traditional syntax.</p>
</li>
<li>
<p><em>UserDetailsService</em> - closely related to authentication providers, but often also required by other beans.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We&#8217;ll see how to configure these in the following sections.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ns-getting-started"><a class="anchor" href="#ns-getting-started"></a>Getting Started with Security Namespace Configuration</h3>
<div class="paragraph">
<p>In this section, we&#8217;ll look at how you can build up a namespace configuration to use some of the main features of the framework.
Let&#8217;s assume you initially want to get up and running as quickly as possible and add authentication support and access control to an existing web application, with a few test logins.
Then we&#8217;ll look at how to change over to authenticating against a database or other security repository.
In later sections we&#8217;ll introduce more advanced namespace configuration options.</p>
</div>
<div class="sect3">
<h4 id="ns-web-xml"><a class="anchor" href="#ns-web-xml"></a>web.xml Configuration</h4>
<div class="paragraph">
<p>The first thing you need to do is add the following filter declaration to your <code>web.xml</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;filter&gt;
&lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;
&lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;
&lt;/filter&gt;

&lt;filter-mapping&gt;
&lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;
&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This provides a hook into the Spring Security web infrastructure.
<code>DelegatingFilterProxy</code> is a Spring Framework class which delegates to a filter implementation which is defined as a Spring bean in your application context.
In this case, the bean is named "springSecurityFilterChain", which is an internal infrastructure bean created by the namespace to handle web security.
Note that you should not use this bean name yourself.
Once you&#8217;ve added this to your <code>web.xml</code>, you&#8217;re ready to start editing your application context file.
Web security services are configured using the <code>&lt;http&gt;</code> element.</p>
</div>
</div>
<div class="sect3">
<h4 id="ns-minimal"><a class="anchor" href="#ns-minimal"></a>A Minimal &lt;http&gt; Configuration</h4>
<div class="paragraph">
<p>All you need to enable web security to begin with is</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
&lt;intercept-url pattern="/**" access="hasRole('USER')" /&gt;
&lt;form-login /&gt;
&lt;logout /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which says that we want all URLs within our application to be secured, requiring the role <code>ROLE_USER</code> to access them, we want to log in to the application using a form with username and password, and that we want a logout URL registered which will allow us to log out of the application.
<code>&lt;http&gt;</code> element is the parent for all web-related namespace functionality.
The <code>&lt;intercept-url&gt;</code> element defines a <code>pattern</code> which is matched against the URLs of incoming requests using an ant path style syntax <sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup>.
You can also use regular-expression matching as an alternative (see the namespace appendix for more details).
The <code>access</code> attribute defines the access requirements for requests matching the given pattern.
With the default configuration, this is typically a comma-separated list of roles, one of which a user must have to be allowed to make the request.
The prefix "ROLE_" is a marker which indicates that a simple comparison with the user&#8217;s authorities should be made.
In other words, a normal role-based check should be used.
Access-control in Spring Security is not limited to the use of simple roles (hence the use of the prefix to differentiate between different types of security attributes).
We&#8217;ll see later how the interpretation can vary <sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnotedef_3" title="View footnote.">3</a>]</sup>.
In Spring Security 3.0, the attribute can also be populated with an <a href="#el-access">EL expression</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You can use multiple <code>&lt;intercept-url&gt;</code> elements to define different access requirements for different sets of URLs, but they will be evaluated in the order listed and the first match will be used.
So you must put the most specific matches at the top.
You can also add a <code>method</code> attribute to limit the match to a particular HTTP method (<code>GET</code>, <code>POST</code>, <code>PUT</code> etc.).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To add some users, you can define a set of test data directly in the namespace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;authentication-manager&gt;
&lt;authentication-provider&gt;
	&lt;user-service&gt;
	&lt;!-- Password is prefixed with {noop} to indicate to DelegatingPasswordEncoder that
	NoOpPasswordEncoder should be used. This is not safe for production, but makes reading
	in samples easier. Normally passwords should be hashed using BCrypt --&gt;
	&lt;user name="jimi" password="{noop}jimispassword" authorities="ROLE_USER, ROLE_ADMIN" /&gt;
	&lt;user name="bob" password="{noop}bobspassword" authorities="ROLE_USER" /&gt;
	&lt;/user-service&gt;
&lt;/authentication-provider&gt;
&lt;/authentication-manager&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is an example of a secure way of storing the same passwords.
The password is prefixed with <code>{bcrypt}</code> to instruct <code>DelegatingPasswordEncoder</code>, which supports any configured <code>PasswordEncoder</code> for matching, that the passwords are hashed using BCrypt:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;authentication-manager&gt;
&lt;authentication-provider&gt;
	&lt;user-service&gt;
	&lt;user name="jimi" password="{bcrypt}$2a$10$ddEWZUl8aU0GdZPPpy7wbu82dvEw/pBpbRvDQRqA41y6mK1CoH00m"
			authorities="ROLE_USER, ROLE_ADMIN" /&gt;
	&lt;user name="bob" password="{bcrypt}$2a$10$/elFpMBnAYYig6KRR5bvOOYeZr1ie1hSogJryg9qDlhza4oCw1Qka"
			authorities="ROLE_USER" /&gt;
	&lt;user name="jimi" password="{noop}jimispassword" authorities="ROLE_USER, ROLE_ADMIN" /&gt;
	&lt;user name="bob" password="{noop}bobspassword" authorities="ROLE_USER" /&gt;
	&lt;/user-service&gt;
&lt;/authentication-provider&gt;
&lt;/authentication-manager&gt;</code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>If you are familiar with pre-namespace versions of the framework, you can probably already guess roughly what&#8217;s going on here.
The <code>&lt;http&gt;</code> element is responsible for creating a <code>FilterChainProxy</code> and the filter beans which it uses.
Common problems like incorrect filter ordering are no longer an issue as the filter positions are predefined.</p>
</div>
<div class="paragraph">
<p>The <code>&lt;authentication-provider&gt;</code> element creates a <code>DaoAuthenticationProvider</code> bean and the <code>&lt;user-service&gt;</code> element creates an <code>InMemoryDaoImpl</code>.
All <code>authentication-provider</code> elements must be children of the <code>&lt;authentication-manager&gt;</code> element, which creates a <code>ProviderManager</code> and registers the authentication providers with it.
You can find more detailed information on the beans that are created in the <a href="#appendix-namespace">namespace appendix</a>.
It&#8217;s worth cross-checking this if you want to start understanding what the important classes in the framework are and how they are used, particularly if you want to customise things later.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>The configuration above defines two users, their passwords and their roles within the application (which will be used for access control).
It is also possible to load user information from a standard properties file using the <code>properties</code> attribute on <code>user-service</code>.
See the section on <a href="#servlet-authentication-inmemory">in-memory authentication</a> for more details on the file format.
Using the <code>&lt;authentication-provider&gt;</code> element means that the user information will be used by the authentication manager to process authentication requests.
You can have multiple <code>&lt;authentication-provider&gt;</code> elements to define different authentication sources and each will be consulted in turn.</p>
</div>
<div class="paragraph">
<p>At this point you should be able to start up your application and you will be required to log in to proceed.
Try it out, or try experimenting with the "tutorial" sample application that comes with the project.</p>
</div>
<div class="sect4">
<h5 id="ns-form-target"><a class="anchor" href="#ns-form-target"></a>Setting a Default Post-Login Destination</h5>
<div class="paragraph">
<p>If a form login isn&#8217;t prompted by an attempt to access a protected resource, the <code>default-target-url</code> option comes into play.
This is the URL the user will be taken to after successfully logging in, and defaults to "/".
You can also configure things so that the user <em>always</em> ends up at this page (regardless of whether the login was "on-demand" or they explicitly chose to log in) by setting the <code>always-use-default-target</code> attribute to "true".
This is useful if your application always requires that the user starts at a "home" page, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http pattern="/login.htm*" security="none"/&gt;
&lt;http use-expressions="false"&gt;
&lt;intercept-url pattern='/**' access='ROLE_USER' /&gt;
&lt;form-login login-page='/login.htm' default-target-url='/home.htm'
		always-use-default-target='true' /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>For even more control over the destination, you can use the <code>authentication-success-handler-ref</code> attribute as an alternative to <code>default-target-url</code>.
The referenced bean should be an instance of <code>AuthenticationSuccessHandler</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ns-web-advanced"><a class="anchor" href="#ns-web-advanced"></a>Advanced Web Features</h3>
<div class="sect3">
<h4 id="ns-custom-filters"><a class="anchor" href="#ns-custom-filters"></a>Adding in Your Own Filters</h4>
<div class="paragraph">
<p>If you&#8217;ve used Spring Security before, you&#8217;ll know that the framework maintains a chain of filters in order to apply its services.
You may want to add your own filters to the stack at particular locations or use a Spring Security filter for which there isn&#8217;t currently a namespace configuration option (CAS, for example).
Or you might want to use a customized version of a standard namespace filter, such as the <code>UsernamePasswordAuthenticationFilter</code> which is created by the <code>&lt;form-login&gt;</code> element, taking advantage of some of the extra configuration options which are available by using the bean explicitly.
How can you do this with namespace configuration, since the filter chain is not directly exposed?</p>
</div>
<div class="paragraph">
<p>The order of the filters is always strictly enforced when using the namespace.
When the application context is being created, the filter beans are sorted by the namespace handling code and the standard Spring Security filters each have an alias in the namespace and a well-known position.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In previous versions, the sorting took place after the filter instances had been created, during post-processing of the application context.
In version 3.0+ the sorting is now done at the bean metadata level, before the classes have been instantiated.
This has implications for how you add your own filters to the stack as the entire filter list must be known during the parsing of the <code>&lt;http&gt;</code> element, so the syntax has changed slightly in 3.0.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The filters, aliases and namespace elements/attributes which create the filters are shown in <a href="#filter-stack">Standard Filter Aliases and Ordering</a>.
The filters are listed in the order in which they occur in the filter chain.</p>
</div>
<table id="filter-stack" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Standard Filter Aliases and Ordering</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Alias</th>
<th class="tableblock halign-left valign-top">Filter Class</th>
<th class="tableblock halign-left valign-top">Namespace Element or Attribute</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CHANNEL_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ChannelProcessingFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/intercept-url@requires-channel</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SECURITY_CONTEXT_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SecurityContextPersistenceFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CONCURRENT_SESSION_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ConcurrentSessionFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>session-management/concurrency-control</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HEADERS_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HeaderWriterFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/headers</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CSRF_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CsrfFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/csrf</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LOGOUT_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LogoutFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/logout</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">X509_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>X509AuthenticationFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/x509</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PRE_AUTH_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AbstractPreAuthenticatedProcessingFilter</code> Subclasses</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CAS_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CasAuthenticationFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">FORM_LOGIN_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UsernamePasswordAuthenticationFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/form-login</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BASIC_AUTH_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BasicAuthenticationFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/http-basic</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SERVLET_API_SUPPORT_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SecurityContextHolderAwareRequestFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/@servlet-api-provision</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">JAAS_API_SUPPORT_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JaasApiIntegrationFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/@jaas-api-provision</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">REMEMBER_ME_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RememberMeAuthenticationFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/remember-me</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ANONYMOUS_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AnonymousAuthenticationFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/anonymous</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SESSION_MANAGEMENT_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SessionManagementFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>session-management</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">EXCEPTION_TRANSLATION_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ExceptionTranslationFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">FILTER_SECURITY_INTERCEPTOR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FilterSecurityInterceptor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SWITCH_USER_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SwitchUserFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>You can add your own filter to the stack, using the <code>custom-filter</code> element and one of these names to specify the position your filter should appear at:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
&lt;custom-filter position="FORM_LOGIN_FILTER" ref="myFilter" /&gt;
&lt;/http&gt;

&lt;beans:bean id="myFilter" class="com.mycompany.MySpecialAuthenticationFilter"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also use the <code>after</code> or <code>before</code> attributes if you want your filter to be inserted before or after another filter in the stack.
The names "FIRST" and "LAST" can be used with the <code>position</code> attribute to indicate that you want your filter to appear before or after the entire stack, respectively.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">Avoiding filter position conflicts</div>
<div class="paragraph">
<p>If you are inserting a custom filter which may occupy the same position as one of the standard filters created by the namespace then it&#8217;s important that you don&#8217;t include the namespace versions by mistake.
Remove any elements which create filters whose functionality you want to replace.</p>
</div>
<div class="paragraph">
<p>Note that you can&#8217;t replace filters which are created by the use of the <code>&lt;http&gt;</code> element itself - <code>SecurityContextPersistenceFilter</code>, <code>ExceptionTranslationFilter</code> or <code>FilterSecurityInterceptor</code>.
Some other filters are added by default, but you can disable them.
An <code>AnonymousAuthenticationFilter</code> is added by default and unless you have <a href="#ns-session-fixation">session-fixation protection</a> disabled, a <code>SessionManagementFilter</code> will also be added to the filter chain.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you&#8217;re replacing a namespace filter which requires an authentication entry point (i.e. where the authentication process is triggered by an attempt by an unauthenticated user to access to a secured resource), you will need to add a custom entry point bean too.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ns-method-security"><a class="anchor" href="#ns-method-security"></a>Method Security</h3>
<div class="paragraph">
<p>From version 2.0 onwards Spring Security has improved support substantially for adding security to your service layer methods.
It provides support for JSR-250 annotation security as well as the framework&#8217;s original <code>@Secured</code> annotation.
From 3.0 you can also make use of new <a href="#el-access">expression-based annotations</a>.
You can apply security to a single bean, using the <code>intercept-methods</code> element to decorate the bean declaration, or you can secure multiple beans across the entire service layer using the AspectJ style pointcuts.</p>
</div>
</div>
<div class="sect2">
<h3 id="ns-access-manager"><a class="anchor" href="#ns-access-manager"></a>The Default AccessDecisionManager</h3>
<div class="paragraph">
<p>This section assumes you have some knowledge of the underlying architecture for access-control within Spring Security.
If you don&#8217;t you can skip it and come back to it later, as this section is only really relevant for people who need to do some customization in order to use more than simple role-based security.</p>
</div>
<div class="paragraph">
<p>When you use a namespace configuration, a default instance of <code>AccessDecisionManager</code> is automatically registered for you and will be used for making access decisions for method invocations and web URL access, based on the access attributes you specify in your <code>intercept-url</code> and <code>protect-pointcut</code> declarations (and in annotations if you are using annotation secured methods).</p>
</div>
<div class="paragraph">
<p>The default strategy is to use an <code>AffirmativeBased</code> <code>AccessDecisionManager</code> with a <code>RoleVoter</code> and an <code>AuthenticatedVoter</code>.
You can find out more about these in the chapter on <a href="#authz-arch">authorization</a>.</p>
</div>
<div class="sect3">
<h4 id="ns-custom-access-mgr"><a class="anchor" href="#ns-custom-access-mgr"></a>Customizing the AccessDecisionManager</h4>
<div class="paragraph">
<p>If you need to use a more complicated access control strategy then it is easy to set an alternative for both method and web security.</p>
</div>
<div class="paragraph">
<p>For method security, you do this by setting the <code>access-decision-manager-ref</code> attribute on <code>global-method-security</code> to the <code>id</code> of the appropriate <code>AccessDecisionManager</code> bean in the application context:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;global-method-security access-decision-manager-ref="myAccessDecisionManagerBean"&gt;
...
&lt;/global-method-security&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The syntax for web security is the same, but on the <code>http</code> element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http access-decision-manager-ref="myAccessDecisionManagerBean"&gt;
...
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unresolved include directive in modules/ROOT/pages/servlet/index.adoc - include::test/index.adoc[]</p>
</div>
<div class="paragraph">
<p>Unresolved include directive in modules/ROOT/pages/servlet/index.adoc - include::crypto/index.adoc[]</p>
</div>
<div class="paragraph">
<p>Unresolved include directive in modules/ROOT/pages/servlet/index.adoc - include::appendix/index.adoc[]</p>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. You can find out more about the use of the <code>ldap-server</code> element in the chapter on <a href="#servlet-authentication-ldap">[servlet-authentication-ldap]</a>.
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. See the section on <a href="#servlet-httpfirewall">`HttpFirewall`</a> for more details on how matches are actually performed.
</div>
<div class="footnote" id="_footnotedef_3">
<a href="#_footnoteref_3">3</a>. The interpretation of the comma-separated values in the <code>access</code> attribute depends on the implementation of the <a href="#ns-access-manager">AccessDecisionManager</a> which is used.
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer flex">
    <div id="spring-links flex">
        <img id="springlogo" src="../../_/img/spring-logo.svg" alt="Spring">
        <p class="smallest antialiased"> <script>var d = new Date();
        document.write(d.getFullYear());</script> <a href="https://www.vmware.com/">VMware</a>, Inc. or its affiliates. <a href="https://www.vmware.com/help/legal.html">Terms of Use</a>  <a href="https://www.vmware.com/help/privacy.html" rel="noopener noreferrer">Privacy</a>  <a href="https://spring.io/trademarks">Trademark Guidelines</a> <span id="thank-you-mobile"> <a href="https://spring.io/thank-you">Thank you</a></span>  <a href="https://www.vmware.com/help/privacy/california-privacy-rights.html">Your California Privacy Rights</a>  <a class="ot-sdk-show-settings">Cookie Settings</a> <span id="teconsent"></span></p>
        <p class="smallest antialiased">Apache, Apache Tomcat, Apache Kafka, Apache Cassandra&trade;, and Apache Geode&trade; are trademarks or registered trademarks of the Apache Software Foundation in the United States and/or other countries. Java&trade;, Java&trade; SE, Java&trade; EE, and OpenJDK&trade; are trademarks of Oracle and/or its affiliates. Kubernetes is a registered trademark of the Linux Foundation in the United States and other countries. Linux is the registered trademark of Linus Torvalds in the United States and other countries. Windows and Microsoft Azure are registered trademarks of Microsoft Corporation. AWS and Amazon Web Services are trademarks or registered trademarks of Amazon.com Inc. or its affiliates. All other trademarks and copyrights are property of their respective owners and are only mentioned for informative purposes. Other names may be trademarks of their respective owners.</p>
    </div>
    <div id="social-icons" class="flex jc-between">
        <a href="https://www.youtube.com/user/SpringSourceDev" title="Youtube"><svg id="youtube-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 40 40"><circle class="cls-1" cx="20" cy="20" r="20"/><path class="cls-2" d="M30.91,14.53a2.89,2.89,0,0,0-2-2C27.12,12,20,12,20,12s-7.12,0-8.9.47a2.9,2.9,0,0,0-2,2A30.56,30.56,0,0,0,8.63,20a30.44,30.44,0,0,0,.46,5.47,2.89,2.89,0,0,0,2,2C12.9,28,20,28,20,28s7.12,0,8.9-.47a2.87,2.87,0,0,0,2-2A30.56,30.56,0,0,0,31.37,20,28.88,28.88,0,0,0,30.91,14.53ZM17.73,23.41V16.59L23.65,20Z"/></svg></a>
        <a href="https://github.com/spring-projects" title="Github"><svg id="github-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 75.93 75.93"><path class="cls-1" d="M38,0a38,38,0,1,0,38,38A38,38,0,0,0,38,0Z"/></g><path class="cls-2" d="M38,15.59A22.95,22.95,0,0,0,30.71,60.3c1.15.21,1.57-.5,1.57-1.11s0-2,0-3.9c-6.38,1.39-7.73-3.07-7.73-3.07A6.09,6.09,0,0,0,22,48.86c-2.09-1.42.15-1.39.15-1.39a4.81,4.81,0,0,1,3.52,2.36c2,3.5,5.37,2.49,6.67,1.91a4.87,4.87,0,0,1,1.46-3.07c-5.09-.58-10.45-2.55-10.45-11.34a8.84,8.84,0,0,1,2.36-6.15,8.29,8.29,0,0,1,.23-6.07s1.92-.62,6.3,2.35a21.82,21.82,0,0,1,11.49,0c4.38-3,6.3-2.35,6.3-2.35a8.29,8.29,0,0,1,.23,6.07,8.84,8.84,0,0,1,2.36,6.15c0,8.81-5.37,10.75-10.48,11.32a5.46,5.46,0,0,1,1.56,4.25c0,3.07,0,5.54,0,6.29s.42,1.33,1.58,1.1A22.94,22.94,0,0,0,38,15.59Z"/></svg></a>
        <a href="https://twitter.com/springcentral" title="Twitter"><svg id="twitter-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 75.93 75.93"><circle class="cls-1" cx="37.97" cy="37.97" r="37.97"/><path id="Twitter-2" data-name="Twitter" class="cls-2" d="M55.2,22.73a15.43,15.43,0,0,1-4.88,1.91,7.56,7.56,0,0,0-5.61-2.49A7.78,7.78,0,0,0,37,30a7.56,7.56,0,0,0,.2,1.79,21.63,21.63,0,0,1-15.84-8.23,8,8,0,0,0,2.37,10.52,7.66,7.66,0,0,1-3.48-1v.09A7.84,7.84,0,0,0,26.45,41a7.54,7.54,0,0,1-2,.28A7.64,7.64,0,0,1,23,41.09a7.71,7.71,0,0,0,7.18,5.47,15.21,15.21,0,0,1-9.55,3.37,15.78,15.78,0,0,1-1.83-.11,21.41,21.41,0,0,0,11.78,3.54c14.13,0,21.86-12,21.86-22.42,0-.34,0-.68,0-1a15.67,15.67,0,0,0,3.83-4.08,14.9,14.9,0,0,1-4.41,1.24A7.8,7.8,0,0,0,55.2,22.73Z"/></svg></a>
    </div>
</footer>
<script src="../../_/js/site.js"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
<script async src="../../_/js/vendor/tabs.js"></script>
<script src="../../_/js/vendor/docsearch.min.js"></script>
<script src="../../_/js/vendor/switchtheme.js"></script>
<!-- fetched from https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js -->
<script>
docsearch({
  apiKey: '82c7ead946afbac3cf98c32446154691',
  appId: '244V8V9FGG',
  indexName: 'spring-docs',
  inputSelector: '#search-input',
  algoliaOptions: { hitsPerPage: 10 }
})
</script>
  </body>
</html>
